import {
  _defineProperty
} from "./chunk-LNW67B6E.js";

// node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js
function getMeshBoundingBox(attributes) {
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  const positions = attributes.POSITION ? attributes.POSITION.value : [];
  const len = positions && positions.length;
  for (let i = 0; i < len; i += 3) {
    const x = positions[i];
    const y = positions[i + 1];
    const z = positions[i + 2];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }
  return [[minX, minY, minZ], [maxX, maxY, maxZ]];
}

// node_modules/@loaders.gl/schema/dist/esm/lib/batches/base-table-batch-aggregator.js
var DEFAULT_ROW_COUNT = 100;
var RowTableBatchAggregator = class {
  constructor(schema, options) {
    _defineProperty(this, "schema", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "length", 0);
    _defineProperty(this, "rows", null);
    _defineProperty(this, "cursor", 0);
    _defineProperty(this, "_headers", []);
    this.options = options;
    this.schema = schema;
    if (!Array.isArray(schema)) {
      this._headers = [];
      for (const key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }
  rowCount() {
    return this.length;
  }
  addArrayRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }
    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
    this.rows[this.length] = row;
    this.length++;
  }
  addObjectRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }
    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
    this.rows[this.length] = row;
    this.length++;
  }
  getBatch() {
    let rows = this.rows;
    if (!rows) {
      return null;
    }
    rows = rows.slice(0, this.length);
    this.rows = null;
    const batch = {
      shape: this.options.shape,
      batchType: "data",
      data: rows,
      length: this.length,
      schema: this.schema,
      cursor: this.cursor
    };
    return batch;
  }
};

// node_modules/@loaders.gl/schema/dist/esm/lib/utils/row-utils.js
function convertToObjectRow(arrayRow, headers) {
  if (!arrayRow) {
    throw new Error("null row");
  }
  if (!headers) {
    throw new Error("no headers");
  }
  const objectRow = {};
  for (let i = 0; i < headers.length; i++) {
    objectRow[headers[i]] = arrayRow[i];
  }
  return objectRow;
}
function convertToArrayRow(objectRow, headers) {
  if (!objectRow) {
    throw new Error("null row");
  }
  if (!headers) {
    throw new Error("no headers");
  }
  const arrayRow = new Array(headers.length);
  for (let i = 0; i < headers.length; i++) {
    arrayRow[i] = objectRow[headers[i]];
  }
  return arrayRow;
}

// node_modules/@loaders.gl/schema/dist/esm/lib/batches/row-table-batch-aggregator.js
var DEFAULT_ROW_COUNT2 = 100;
var RowTableBatchAggregator2 = class {
  constructor(schema, options) {
    _defineProperty(this, "schema", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "length", 0);
    _defineProperty(this, "objectRows", null);
    _defineProperty(this, "arrayRows", null);
    _defineProperty(this, "cursor", 0);
    _defineProperty(this, "_headers", []);
    this.options = options;
    this.schema = schema;
    if (!Array.isArray(schema)) {
      this._headers = [];
      for (const key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }
  rowCount() {
    return this.length;
  }
  addArrayRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }
    switch (this.options.shape) {
      case "object-row-table":
        const rowObject = convertToObjectRow(row, this._headers);
        this.addObjectRow(rowObject, cursor);
        break;
      case "array-row-table":
        this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT2);
        this.arrayRows[this.length] = row;
        this.length++;
        break;
    }
  }
  addObjectRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }
    switch (this.options.shape) {
      case "array-row-table":
        const rowArray = convertToArrayRow(row, this._headers);
        this.addArrayRow(rowArray, cursor);
        break;
      case "object-row-table":
        this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT2);
        this.objectRows[this.length] = row;
        this.length++;
        break;
    }
  }
  getBatch() {
    let rows = this.arrayRows || this.objectRows;
    if (!rows) {
      return null;
    }
    rows = rows.slice(0, this.length);
    this.arrayRows = null;
    this.objectRows = null;
    return {
      shape: this.options.shape,
      batchType: "data",
      data: rows,
      length: this.length,
      schema: this.schema,
      cursor: this.cursor
    };
  }
};

// node_modules/@loaders.gl/schema/dist/esm/lib/batches/columnar-table-batch-aggregator.js
var DEFAULT_ROW_COUNT3 = 100;
var ColumnarTableBatchAggregator = class {
  constructor(schema, options) {
    _defineProperty(this, "schema", void 0);
    _defineProperty(this, "length", 0);
    _defineProperty(this, "allocated", 0);
    _defineProperty(this, "columns", {});
    this.schema = schema;
    this._reallocateColumns();
  }
  rowCount() {
    return this.length;
  }
  addArrayRow(row) {
    this._reallocateColumns();
    let i = 0;
    for (const fieldName in this.columns) {
      this.columns[fieldName][this.length] = row[i++];
    }
    this.length++;
  }
  addObjectRow(row) {
    this._reallocateColumns();
    for (const fieldName in row) {
      this.columns[fieldName][this.length] = row[fieldName];
    }
    this.length++;
  }
  getBatch() {
    this._pruneColumns();
    const columns = Array.isArray(this.schema) ? this.columns : {};
    if (!Array.isArray(this.schema)) {
      for (const fieldName in this.schema) {
        const field = this.schema[fieldName];
        columns[field.name] = this.columns[field.index];
      }
    }
    this.columns = {};
    const batch = {
      shape: "columnar-table",
      batchType: "data",
      data: columns,
      schema: this.schema,
      length: this.length
    };
    return batch;
  }
  _reallocateColumns() {
    if (this.length < this.allocated) {
      return;
    }
    this.allocated = this.allocated > 0 ? this.allocated *= 2 : DEFAULT_ROW_COUNT3;
    this.columns = {};
    for (const fieldName in this.schema) {
      const field = this.schema[fieldName];
      const ArrayType = field.type || Float32Array;
      const oldColumn = this.columns[field.index];
      if (oldColumn && ArrayBuffer.isView(oldColumn)) {
        const typedArray = new ArrayType(this.allocated);
        typedArray.set(oldColumn);
        this.columns[field.index] = typedArray;
      } else if (oldColumn) {
        oldColumn.length = this.allocated;
        this.columns[field.index] = oldColumn;
      } else {
        this.columns[field.index] = new ArrayType(this.allocated);
      }
    }
  }
  _pruneColumns() {
    for (const [columnName, column] of Object.entries(this.columns)) {
      this.columns[columnName] = column.slice(0, this.length);
    }
  }
};

// node_modules/@loaders.gl/schema/dist/esm/lib/batches/table-batch-builder.js
var DEFAULT_OPTIONS = {
  shape: "array-row-table",
  batchSize: "auto",
  batchDebounceMs: 0,
  limit: 0,
  _limitMB: 0
};
var ERR_MESSAGE = "TableBatchBuilder";
var TableBatchBuilder = class {
  constructor(schema, options) {
    _defineProperty(this, "schema", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "aggregator", null);
    _defineProperty(this, "batchCount", 0);
    _defineProperty(this, "bytesUsed", 0);
    _defineProperty(this, "isChunkComplete", false);
    _defineProperty(this, "lastBatchEmittedMs", Date.now());
    _defineProperty(this, "totalLength", 0);
    _defineProperty(this, "totalBytes", 0);
    _defineProperty(this, "rowBytes", 0);
    this.schema = schema;
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
  }
  limitReached() {
    var _this$options, _this$options2;
    if (Boolean((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.limit) && this.totalLength >= this.options.limit) {
      return true;
    }
    if (Boolean((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {
      return true;
    }
    return false;
  }
  addRow(row) {
    if (this.limitReached()) {
      return;
    }
    this.totalLength++;
    this.rowBytes = this.rowBytes || this._estimateRowMB(row);
    this.totalBytes += this.rowBytes;
    if (Array.isArray(row)) {
      this.addArrayRow(row);
    } else {
      this.addObjectRow(row);
    }
  }
  addArrayRow(row) {
    if (!this.aggregator) {
      const TableBatchType = this._getTableBatchType();
      this.aggregator = new TableBatchType(this.schema, this.options);
    }
    this.aggregator.addArrayRow(row);
  }
  addObjectRow(row) {
    if (!this.aggregator) {
      const TableBatchType = this._getTableBatchType();
      this.aggregator = new TableBatchType(this.schema, this.options);
    }
    this.aggregator.addObjectRow(row);
  }
  chunkComplete(chunk) {
    if (chunk instanceof ArrayBuffer) {
      this.bytesUsed += chunk.byteLength;
    }
    if (typeof chunk === "string") {
      this.bytesUsed += chunk.length;
    }
    this.isChunkComplete = true;
  }
  getFullBatch(options) {
    return this._isFull() ? this._getBatch(options) : null;
  }
  getFinalBatch(options) {
    return this._getBatch(options);
  }
  _estimateRowMB(row) {
    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;
  }
  _isFull() {
    if (!this.aggregator || this.aggregator.rowCount() === 0) {
      return false;
    }
    if (this.options.batchSize === "auto") {
      if (!this.isChunkComplete) {
        return false;
      }
    } else if (this.options.batchSize > this.aggregator.rowCount()) {
      return false;
    }
    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {
      return false;
    }
    this.isChunkComplete = false;
    this.lastBatchEmittedMs = Date.now();
    return true;
  }
  _getBatch(options) {
    if (!this.aggregator) {
      return null;
    }
    if (options !== null && options !== void 0 && options.bytesUsed) {
      this.bytesUsed = options.bytesUsed;
    }
    const normalizedBatch = this.aggregator.getBatch();
    normalizedBatch.count = this.batchCount;
    normalizedBatch.bytesUsed = this.bytesUsed;
    Object.assign(normalizedBatch, options);
    this.batchCount++;
    this.aggregator = null;
    return normalizedBatch;
  }
  _getTableBatchType() {
    switch (this.options.shape) {
      case "row-table":
        return RowTableBatchAggregator;
      case "array-row-table":
      case "object-row-table":
        return RowTableBatchAggregator2;
      case "columnar-table":
        return ColumnarTableBatchAggregator;
      case "arrow-table":
        if (!TableBatchBuilder.ArrowBatch) {
          throw new Error(ERR_MESSAGE);
        }
        return TableBatchBuilder.ArrowBatch;
      default:
        throw new Error(ERR_MESSAGE);
    }
  }
};
_defineProperty(TableBatchBuilder, "ArrowBatch", void 0);

// node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}

// node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js
var Schema = class {
  constructor(fields, metadata) {
    _defineProperty(this, "fields", void 0);
    _defineProperty(this, "metadata", void 0);
    assert(Array.isArray(fields));
    checkNames(fields);
    this.fields = fields;
    this.metadata = metadata || /* @__PURE__ */ new Map();
  }
  compareTo(other) {
    if (this.metadata !== other.metadata) {
      return false;
    }
    if (this.fields.length !== other.fields.length) {
      return false;
    }
    for (let i = 0; i < this.fields.length; ++i) {
      if (!this.fields[i].compareTo(other.fields[i])) {
        return false;
      }
    }
    return true;
  }
  select() {
    const nameMap = /* @__PURE__ */ Object.create(null);
    for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {
      columnNames[_key] = arguments[_key];
    }
    for (const name of columnNames) {
      nameMap[name] = true;
    }
    const selectedFields = this.fields.filter((field) => nameMap[field.name]);
    return new Schema(selectedFields, this.metadata);
  }
  selectAt() {
    for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      columnIndices[_key2] = arguments[_key2];
    }
    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);
    return new Schema(selectedFields, this.metadata);
  }
  assign(schemaOrFields) {
    let fields;
    let metadata = this.metadata;
    if (schemaOrFields instanceof Schema) {
      const otherSchema = schemaOrFields;
      fields = otherSchema.fields;
      metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), otherSchema.metadata);
    } else {
      fields = schemaOrFields;
    }
    const fieldMap = /* @__PURE__ */ Object.create(null);
    for (const field of this.fields) {
      fieldMap[field.name] = field;
    }
    for (const field of fields) {
      fieldMap[field.name] = field;
    }
    const mergedFields = Object.values(fieldMap);
    return new Schema(mergedFields, metadata);
  }
};
function checkNames(fields) {
  const usedNames = {};
  for (const field of fields) {
    if (usedNames[field.name]) {
      console.warn("Schema: duplicated field name", field.name, field);
    }
    usedNames[field.name] = true;
  }
}
function mergeMaps(m1, m2) {
  return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
}

// node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js
var Field = class {
  constructor(name, type) {
    let nullable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let metadata = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ new Map();
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "nullable", void 0);
    _defineProperty(this, "metadata", void 0);
    this.name = name;
    this.type = type;
    this.nullable = nullable;
    this.metadata = metadata;
  }
  get typeId() {
    return this.type && this.type.typeId;
  }
  clone() {
    return new Field(this.name, this.type, this.nullable, this.metadata);
  }
  compareTo(other) {
    return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
  }
  toString() {
    return "".concat(this.type).concat(this.nullable ? ", nullable" : "").concat(this.metadata ? ", metadata: ".concat(this.metadata) : "");
  }
};

// node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js
var Type = function(Type2) {
  Type2[Type2["NONE"] = 0] = "NONE";
  Type2[Type2["Null"] = 1] = "Null";
  Type2[Type2["Int"] = 2] = "Int";
  Type2[Type2["Float"] = 3] = "Float";
  Type2[Type2["Binary"] = 4] = "Binary";
  Type2[Type2["Utf8"] = 5] = "Utf8";
  Type2[Type2["Bool"] = 6] = "Bool";
  Type2[Type2["Decimal"] = 7] = "Decimal";
  Type2[Type2["Date"] = 8] = "Date";
  Type2[Type2["Time"] = 9] = "Time";
  Type2[Type2["Timestamp"] = 10] = "Timestamp";
  Type2[Type2["Interval"] = 11] = "Interval";
  Type2[Type2["List"] = 12] = "List";
  Type2[Type2["Struct"] = 13] = "Struct";
  Type2[Type2["Union"] = 14] = "Union";
  Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
  Type2[Type2["Map"] = 17] = "Map";
  Type2[Type2["Dictionary"] = -1] = "Dictionary";
  Type2[Type2["Int8"] = -2] = "Int8";
  Type2[Type2["Int16"] = -3] = "Int16";
  Type2[Type2["Int32"] = -4] = "Int32";
  Type2[Type2["Int64"] = -5] = "Int64";
  Type2[Type2["Uint8"] = -6] = "Uint8";
  Type2[Type2["Uint16"] = -7] = "Uint16";
  Type2[Type2["Uint32"] = -8] = "Uint32";
  Type2[Type2["Uint64"] = -9] = "Uint64";
  Type2[Type2["Float16"] = -10] = "Float16";
  Type2[Type2["Float32"] = -11] = "Float32";
  Type2[Type2["Float64"] = -12] = "Float64";
  Type2[Type2["DateDay"] = -13] = "DateDay";
  Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
  Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
  Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
  Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
  Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
  Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  return Type2;
}({});

// node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js
var _Symbol$toStringTag;
var _Symbol$toStringTag2;
var _Symbol$toStringTag3;
var _Symbol$toStringTag4;
var _Symbol$toStringTag5;
var _Symbol$toStringTag6;
var _Symbol$toStringTag7;
var _Symbol$toStringTag8;
var DataType = class {
  static isNull(x) {
    return x && x.typeId === Type.Null;
  }
  static isInt(x) {
    return x && x.typeId === Type.Int;
  }
  static isFloat(x) {
    return x && x.typeId === Type.Float;
  }
  static isBinary(x) {
    return x && x.typeId === Type.Binary;
  }
  static isUtf8(x) {
    return x && x.typeId === Type.Utf8;
  }
  static isBool(x) {
    return x && x.typeId === Type.Bool;
  }
  static isDecimal(x) {
    return x && x.typeId === Type.Decimal;
  }
  static isDate(x) {
    return x && x.typeId === Type.Date;
  }
  static isTime(x) {
    return x && x.typeId === Type.Time;
  }
  static isTimestamp(x) {
    return x && x.typeId === Type.Timestamp;
  }
  static isInterval(x) {
    return x && x.typeId === Type.Interval;
  }
  static isList(x) {
    return x && x.typeId === Type.List;
  }
  static isStruct(x) {
    return x && x.typeId === Type.Struct;
  }
  static isUnion(x) {
    return x && x.typeId === Type.Union;
  }
  static isFixedSizeBinary(x) {
    return x && x.typeId === Type.FixedSizeBinary;
  }
  static isFixedSizeList(x) {
    return x && x.typeId === Type.FixedSizeList;
  }
  static isMap(x) {
    return x && x.typeId === Type.Map;
  }
  static isDictionary(x) {
    return x && x.typeId === Type.Dictionary;
  }
  get typeId() {
    return Type.NONE;
  }
  compareTo(other) {
    return this === other;
  }
};
var Null = class extends DataType {
  get typeId() {
    return Type.Null;
  }
  get [Symbol.toStringTag]() {
    return "Null";
  }
  toString() {
    return "Null";
  }
};
var Bool = class extends DataType {
  get typeId() {
    return Type.Bool;
  }
  get [Symbol.toStringTag]() {
    return "Bool";
  }
  toString() {
    return "Bool";
  }
};
_Symbol$toStringTag = Symbol.toStringTag;
var Int = class extends DataType {
  constructor(isSigned, bitWidth) {
    super();
    _defineProperty(this, "isSigned", void 0);
    _defineProperty(this, "bitWidth", void 0);
    this.isSigned = isSigned;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type.Int;
  }
  get [_Symbol$toStringTag]() {
    return "Int";
  }
  toString() {
    return "".concat(this.isSigned ? "I" : "Ui", "nt").concat(this.bitWidth);
  }
};
var Int8 = class extends Int {
  constructor() {
    super(true, 8);
  }
};
var Int16 = class extends Int {
  constructor() {
    super(true, 16);
  }
};
var Int32 = class extends Int {
  constructor() {
    super(true, 32);
  }
};
var Uint8 = class extends Int {
  constructor() {
    super(false, 8);
  }
};
var Uint16 = class extends Int {
  constructor() {
    super(false, 16);
  }
};
var Uint32 = class extends Int {
  constructor() {
    super(false, 32);
  }
};
var Precision = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};
_Symbol$toStringTag2 = Symbol.toStringTag;
var Float = class extends DataType {
  constructor(precision) {
    super();
    _defineProperty(this, "precision", void 0);
    this.precision = precision;
  }
  get typeId() {
    return Type.Float;
  }
  get [_Symbol$toStringTag2]() {
    return "Float";
  }
  toString() {
    return "Float".concat(this.precision);
  }
};
var Float32 = class extends Float {
  constructor() {
    super(Precision.SINGLE);
  }
};
var Float64 = class extends Float {
  constructor() {
    super(Precision.DOUBLE);
  }
};
var Binary = class extends DataType {
  constructor() {
    super();
  }
  get typeId() {
    return Type.Binary;
  }
  toString() {
    return "Binary";
  }
  get [Symbol.toStringTag]() {
    return "Binary";
  }
};
var Utf8 = class extends DataType {
  get typeId() {
    return Type.Utf8;
  }
  get [Symbol.toStringTag]() {
    return "Utf8";
  }
  toString() {
    return "Utf8";
  }
};
var DateUnit = {
  DAY: 0,
  MILLISECOND: 1
};
_Symbol$toStringTag3 = Symbol.toStringTag;
var Date2 = class extends DataType {
  constructor(unit) {
    super();
    _defineProperty(this, "unit", void 0);
    this.unit = unit;
  }
  get typeId() {
    return Type.Date;
  }
  get [_Symbol$toStringTag3]() {
    return "Date";
  }
  toString() {
    return "Date".concat((this.unit + 1) * 32, "<").concat(DateUnit[this.unit], ">");
  }
};
var TimeUnit = {
  SECOND: 1,
  MILLISECOND: 1e3,
  MICROSECOND: 1e6,
  NANOSECOND: 1e9
};
_Symbol$toStringTag4 = Symbol.toStringTag;
var Time = class extends DataType {
  constructor(unit, bitWidth) {
    super();
    _defineProperty(this, "unit", void 0);
    _defineProperty(this, "bitWidth", void 0);
    this.unit = unit;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type.Time;
  }
  toString() {
    return "Time".concat(this.bitWidth, "<").concat(TimeUnit[this.unit], ">");
  }
  get [_Symbol$toStringTag4]() {
    return "Time";
  }
};
_Symbol$toStringTag5 = Symbol.toStringTag;
var Timestamp = class extends DataType {
  constructor(unit) {
    let timezone = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    super();
    _defineProperty(this, "unit", void 0);
    _defineProperty(this, "timezone", void 0);
    this.unit = unit;
    this.timezone = timezone;
  }
  get typeId() {
    return Type.Timestamp;
  }
  get [_Symbol$toStringTag5]() {
    return "Timestamp";
  }
  toString() {
    return "Timestamp<".concat(TimeUnit[this.unit]).concat(this.timezone ? ", ".concat(this.timezone) : "", ">");
  }
};
var IntervalUnit = {
  DAY_TIME: 0,
  YEAR_MONTH: 1
};
_Symbol$toStringTag6 = Symbol.toStringTag;
var Interval = class extends DataType {
  constructor(unit) {
    super();
    _defineProperty(this, "unit", void 0);
    this.unit = unit;
  }
  get typeId() {
    return Type.Interval;
  }
  get [_Symbol$toStringTag6]() {
    return "Interval";
  }
  toString() {
    return "Interval<".concat(IntervalUnit[this.unit], ">");
  }
};
_Symbol$toStringTag7 = Symbol.toStringTag;
var FixedSizeList = class extends DataType {
  constructor(listSize, child) {
    super();
    _defineProperty(this, "listSize", void 0);
    _defineProperty(this, "children", void 0);
    this.listSize = listSize;
    this.children = [child];
  }
  get typeId() {
    return Type.FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get [_Symbol$toStringTag7]() {
    return "FixedSizeList";
  }
  toString() {
    return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
  }
};
_Symbol$toStringTag8 = Symbol.toStringTag;
var Struct = class extends DataType {
  constructor(children) {
    super();
    _defineProperty(this, "children", void 0);
    this.children = children;
  }
  get typeId() {
    return Type.Struct;
  }
  toString() {
    return "Struct<{".concat(this.children.map((f) => "".concat(f.name, ":").concat(f.type)).join(", "), "}>");
  }
  get [_Symbol$toStringTag8]() {
    return "Struct";
  }
};

// node_modules/@loaders.gl/schema/dist/esm/lib/arrow/arrow-like-type-utils.js
function getArrowTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return new Int8();
    case Uint8Array:
      return new Uint8();
    case Int16Array:
      return new Int16();
    case Uint16Array:
      return new Uint16();
    case Int32Array:
      return new Int32();
    case Uint32Array:
      return new Uint32();
    case Float32Array:
      return new Float32();
    case Float64Array:
      return new Float64();
    default:
      throw new Error("array type not supported");
  }
}

// node_modules/@loaders.gl/schema/dist/esm/category/mesh/deduce-mesh-schema.js
function deduceMeshField(attributeName, attribute, optionalMetadata) {
  const type = getArrowTypeFromTypedArray(attribute.value);
  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
  const field = new Field(attributeName, new FixedSizeList(attribute.size, new Field("value", type)), false, metadata);
  return field;
}
function makeMeshAttributeMetadata(attribute) {
  const result = /* @__PURE__ */ new Map();
  if ("byteOffset" in attribute) {
    result.set("byteOffset", attribute.byteOffset.toString(10));
  }
  if ("byteStride" in attribute) {
    result.set("byteStride", attribute.byteStride.toString(10));
  }
  if ("normalized" in attribute) {
    result.set("normalized", attribute.normalized.toString());
  }
  return result;
}

// node_modules/@loaders.gl/schema/dist/esm/lib/utils/async-queue.js
var _Symbol$asyncIterator;
var ArrayQueue = class extends Array {
  enqueue(value) {
    return this.push(value);
  }
  dequeue() {
    return this.shift();
  }
};
_Symbol$asyncIterator = Symbol.asyncIterator;
var AsyncQueue = class {
  constructor() {
    _defineProperty(this, "_values", void 0);
    _defineProperty(this, "_settlers", void 0);
    _defineProperty(this, "_closed", void 0);
    this._values = new ArrayQueue();
    this._settlers = new ArrayQueue();
    this._closed = false;
  }
  close() {
    while (this._settlers.length > 0) {
      this._settlers.dequeue().resolve({
        done: true
      });
    }
    this._closed = true;
  }
  [_Symbol$asyncIterator]() {
    return this;
  }
  enqueue(value) {
    if (this._closed) {
      throw new Error("Closed");
    }
    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error("Illegal internal state");
      }
      const settler = this._settlers.dequeue();
      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({
          value
        });
      }
    } else {
      this._values.enqueue(value);
    }
  }
  next() {
    if (this._values.length > 0) {
      const value = this._values.dequeue();
      if (value instanceof Error) {
        return Promise.reject(value);
      }
      return Promise.resolve({
        value
      });
    }
    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error("Illegal internal state");
      }
      return Promise.resolve({
        done: true
      });
    }
    return new Promise((resolve, reject) => {
      this._settlers.enqueue({
        resolve,
        reject
      });
    });
  }
};

export {
  getMeshBoundingBox,
  Schema,
  Field,
  FixedSizeList,
  getArrowTypeFromTypedArray,
  deduceMeshField
};
//# sourceMappingURL=chunk-YHHWGHBR.js.map
