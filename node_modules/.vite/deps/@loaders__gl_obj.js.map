{
  "version": 3,
  "sources": ["../../@loaders.gl/obj/src/lib/parse-obj-meshes.ts", "../../@loaders.gl/obj/src/lib/get-obj-schema.ts", "../../@loaders.gl/obj/src/lib/parse-obj.ts", "../../@loaders.gl/obj/src/lib/parse-mtl.ts", "../../@loaders.gl/obj/src/obj-loader.ts", "../../@loaders.gl/obj/src/mtl-loader.ts", "../../@loaders.gl/obj/src/index.ts"],
  "sourcesContent": ["// OBJ Loader, adapted from THREE.js (MIT license)\n//\n// Attributions per original THREE.js source file:\n//\n// @author mrdoob / http://mrdoob.com/\n\n// @ts-nocheck\n\n// o object_name | g group_name\nconst OBJECT_RE = /^[og]\\s*(.+)?/;\n// mtllib file_reference\nconst MATERIAL_RE = /^mtllib /;\n// usemtl material_name\nconst MATERIAL_USE_RE = /^usemtl /;\n\nclass MeshMaterial {\n  constructor({index, name = '', mtllib, smooth, groupStart}) {\n    this.index = index;\n    this.name = name;\n    this.mtllib = mtllib;\n    this.smooth = smooth;\n    this.groupStart = groupStart;\n    this.groupEnd = -1;\n    this.groupCount = -1;\n    this.inherited = false;\n  }\n\n  clone(index = this.index) {\n    return new MeshMaterial({\n      index,\n      name: this.name,\n      mtllib: this.mtllib,\n      smooth: this.smooth,\n      groupStart: 0\n    });\n  }\n}\n\nclass MeshObject {\n  constructor(name = '') {\n    this.name = name;\n\n    this.geometry = {\n      vertices: [],\n      normals: [],\n      colors: [],\n      uvs: []\n    };\n\n    this.materials = [];\n    this.smooth = true;\n\n    this.fromDeclaration = null;\n  }\n\n  startMaterial(name, libraries) {\n    const previous = this._finalize(false);\n\n    // New usemtl declaration overwrites an inherited material, except if faces were declared\n    // after the material, then it must be preserved for proper MultiMaterial continuation.\n    if (previous && (previous.inherited || previous.groupCount <= 0)) {\n      this.materials.splice(previous.index, 1);\n    }\n\n    const material = new MeshMaterial({\n      index: this.materials.length,\n      name,\n      mtllib:\n        Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n      smooth: previous !== undefined ? previous.smooth : this.smooth,\n      groupStart: previous !== undefined ? previous.groupEnd : 0\n    });\n\n    this.materials.push(material);\n\n    return material;\n  }\n\n  currentMaterial() {\n    if (this.materials.length > 0) {\n      return this.materials[this.materials.length - 1];\n    }\n\n    return undefined;\n  }\n\n  _finalize(end) {\n    const lastMultiMaterial = this.currentMaterial();\n    if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n      lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n      lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n      lastMultiMaterial.inherited = false;\n    }\n\n    // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n    if (end && this.materials.length > 1) {\n      for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n        if (this.materials[mi].groupCount <= 0) {\n          this.materials.splice(mi, 1);\n        }\n      }\n    }\n\n    // Guarantee at least one empty material, this makes the creation later more straight forward.\n    if (end && this.materials.length === 0) {\n      this.materials.push({\n        name: '',\n        smooth: this.smooth\n      });\n    }\n\n    return lastMultiMaterial;\n  }\n}\n\nclass ParserState {\n  constructor() {\n    this.objects = [];\n    this.object = null;\n\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n\n    this.materialLibraries = [];\n\n    this.startObject('', false);\n  }\n\n  startObject(name, fromDeclaration = true) {\n    // If the current object (initial from reset) is not from a g/o declaration in the parsed\n    // file. We need to use it for the first parsed g/o to keep things in sync.\n    if (this.object && !this.object.fromDeclaration) {\n      this.object.name = name;\n      this.object.fromDeclaration = fromDeclaration;\n      return;\n    }\n\n    const previousMaterial =\n      this.object && typeof this.object.currentMaterial === 'function'\n        ? this.object.currentMaterial()\n        : undefined;\n\n    if (this.object && typeof this.object._finalize === 'function') {\n      this.object._finalize(true);\n    }\n\n    this.object = new MeshObject(name);\n    this.object.fromDeclaration = fromDeclaration;\n\n    // Inherit previous objects material.\n    // Spec tells us that a declared material must be set to all objects until a new material is declared.\n    // If a usemtl declaration is encountered while this new object is being parsed, it will\n    // overwrite the inherited material. Exception being that there was already face declarations\n    // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n    if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n      const declared = previousMaterial.clone(0);\n      declared.inherited = true;\n      this.object.materials.push(declared);\n    }\n\n    this.objects.push(this.object);\n  }\n\n  finalize() {\n    if (this.object && typeof this.object._finalize === 'function') {\n      this.object._finalize(true);\n    }\n  }\n\n  parseVertexIndex(value, len) {\n    const index = parseInt(value);\n    return (index >= 0 ? index - 1 : index + len / 3) * 3;\n  }\n\n  parseNormalIndex(value, len) {\n    const index = parseInt(value);\n    return (index >= 0 ? index - 1 : index + len / 3) * 3;\n  }\n\n  parseUVIndex(value, len) {\n    const index = parseInt(value);\n    return (index >= 0 ? index - 1 : index + len / 2) * 2;\n  }\n\n  addVertex(a, b, c) {\n    const src = this.vertices;\n    const dst = this.object.geometry.vertices;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    dst.push(src[b + 0], src[b + 1], src[b + 2]);\n    dst.push(src[c + 0], src[c + 1], src[c + 2]);\n  }\n\n  addVertexPoint(a) {\n    const src = this.vertices;\n    const dst = this.object.geometry.vertices;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n  }\n\n  addVertexLine(a) {\n    const src = this.vertices;\n    const dst = this.object.geometry.vertices;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n  }\n\n  addNormal(a, b, c) {\n    const src = this.normals;\n    const dst = this.object.geometry.normals;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    dst.push(src[b + 0], src[b + 1], src[b + 2]);\n    dst.push(src[c + 0], src[c + 1], src[c + 2]);\n  }\n\n  addColor(a, b, c) {\n    const src = this.colors;\n    const dst = this.object.geometry.colors;\n\n    dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    dst.push(src[b + 0], src[b + 1], src[b + 2]);\n    dst.push(src[c + 0], src[c + 1], src[c + 2]);\n  }\n\n  addUV(a, b, c) {\n    const src = this.uvs;\n    const dst = this.object.geometry.uvs;\n\n    dst.push(src[a + 0], src[a + 1]);\n    dst.push(src[b + 0], src[b + 1]);\n    dst.push(src[c + 0], src[c + 1]);\n  }\n\n  addUVLine(a) {\n    const src = this.uvs;\n    const dst = this.object.geometry.uvs;\n\n    dst.push(src[a + 0], src[a + 1]);\n  }\n\n  // eslint-disable-next-line max-params\n  addFace(a, b, c, ua, ub, uc, na, nb, nc) {\n    const vLen = this.vertices.length;\n\n    let ia = this.parseVertexIndex(a, vLen);\n    let ib = this.parseVertexIndex(b, vLen);\n    let ic = this.parseVertexIndex(c, vLen);\n\n    this.addVertex(ia, ib, ic);\n\n    if (ua !== undefined && ua !== '') {\n      const uvLen = this.uvs.length;\n      ia = this.parseUVIndex(ua, uvLen);\n      ib = this.parseUVIndex(ub, uvLen);\n      ic = this.parseUVIndex(uc, uvLen);\n      this.addUV(ia, ib, ic);\n    }\n\n    if (na !== undefined && na !== '') {\n      // Normals are many times the same. If so, skip function call and parseInt.\n      const nLen = this.normals.length;\n      ia = this.parseNormalIndex(na, nLen);\n\n      ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n      ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n\n      this.addNormal(ia, ib, ic);\n    }\n\n    if (this.colors.length > 0) {\n      this.addColor(ia, ib, ic);\n    }\n  }\n\n  addPointGeometry(vertices) {\n    this.object.geometry.type = 'Points';\n\n    const vLen = this.vertices.length;\n\n    for (const vertex of vertices) {\n      this.addVertexPoint(this.parseVertexIndex(vertex, vLen));\n    }\n  }\n\n  addLineGeometry(vertices, uvs) {\n    this.object.geometry.type = 'Line';\n\n    const vLen = this.vertices.length;\n    const uvLen = this.uvs.length;\n\n    for (const vertex of vertices) {\n      this.addVertexLine(this.parseVertexIndex(vertex, vLen));\n    }\n\n    for (const uv of uvs) {\n      this.addUVLine(this.parseUVIndex(uv, uvLen));\n    }\n  }\n}\n\n// eslint-disable-next-line max-statements, complexity\nexport function parseOBJMeshes(text) {\n  const state = new ParserState();\n\n  if (text.indexOf('\\r\\n') !== -1) {\n    // This is faster than String.split with regex that splits on both\n    text = text.replace(/\\r\\n/g, '\\n');\n  }\n\n  if (text.indexOf('\\\\\\n') !== -1) {\n    // join lines separated by a line continuation character (\\)\n    text = text.replace(/\\\\\\n/g, '');\n  }\n\n  const lines = text.split('\\n');\n  let line = '';\n  let lineFirstChar = '';\n  let lineLength = 0;\n  let result = [];\n\n  // Faster to just trim left side of the line. Use if available.\n  const trimLeft = typeof ''.trimLeft === 'function';\n\n  /* eslint-disable no-continue, max-depth */\n  for (let i = 0, l = lines.length; i < l; i++) {\n    line = lines[i];\n    line = trimLeft ? line.trimLeft() : line.trim();\n    lineLength = line.length;\n\n    if (lineLength === 0) continue;\n\n    lineFirstChar = line.charAt(0);\n\n    // @todo invoke passed in handler if any\n    if (lineFirstChar === '#') continue;\n\n    if (lineFirstChar === 'v') {\n      const data = line.split(/\\s+/);\n\n      switch (data[0]) {\n        case 'v':\n          state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n          if (data.length === 8) {\n            state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n          }\n          break;\n        case 'vn':\n          state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n          break;\n        case 'vt':\n          state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n          break;\n        default:\n      }\n    } else if (lineFirstChar === 'f') {\n      const lineData = line.substr(1).trim();\n      const vertexData = lineData.split(/\\s+/);\n      const faceVertices = [];\n\n      // Parse the face vertex data into an easy to work with format\n\n      for (let j = 0, jl = vertexData.length; j < jl; j++) {\n        const vertex = vertexData[j];\n\n        if (vertex.length > 0) {\n          const vertexParts = vertex.split('/');\n          faceVertices.push(vertexParts);\n        }\n      }\n\n      // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n      const v1 = faceVertices[0];\n\n      for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n        const v2 = faceVertices[j];\n        const v3 = faceVertices[j + 1];\n\n        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n      }\n    } else if (lineFirstChar === 'l') {\n      const lineParts = line.substring(1).trim().split(' ');\n      let lineVertices;\n      const lineUVs = [];\n\n      if (line.indexOf('/') === -1) {\n        lineVertices = lineParts;\n      } else {\n        lineVertices = [];\n        for (let li = 0, llen = lineParts.length; li < llen; li++) {\n          const parts = lineParts[li].split('/');\n\n          if (parts[0] !== '') lineVertices.push(parts[0]);\n          if (parts[1] !== '') lineUVs.push(parts[1]);\n        }\n      }\n      state.addLineGeometry(lineVertices, lineUVs);\n    } else if (lineFirstChar === 'p') {\n      const lineData = line.substr(1).trim();\n      const pointData = lineData.split(' ');\n\n      state.addPointGeometry(pointData);\n    } else if ((result = OBJECT_RE.exec(line)) !== null) {\n      // o object_name\n      // or\n      // g group_name\n\n      // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n      // var name = result[ 0 ].substr( 1 ).trim();\n      const name = (' ' + result[0].substr(1).trim()).substr(1); // eslint-disable-line\n\n      state.startObject(name);\n    } else if (MATERIAL_USE_RE.test(line)) {\n      // material\n\n      state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n    } else if (MATERIAL_RE.test(line)) {\n      // mtl file\n\n      state.materialLibraries.push(line.substring(7).trim());\n    } else if (lineFirstChar === 's') {\n      result = line.split(' ');\n\n      // smooth shading\n\n      // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n      // but does not define a usemtl for each face set.\n      // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n      // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n      // where explicit usemtl defines geometry groups.\n      // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n      /*\n       * http://paulbourke.net/dataformats/obj/\n       * or\n       * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n       *\n       * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n       * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n       * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n       * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n       * than 0.\"\n       */\n      if (result.length > 1) {\n        const value = result[1].trim().toLowerCase();\n        state.object.smooth = value !== '0' && value !== 'off';\n      } else {\n        // ZBrush can produce \"s\" lines #11707\n        state.object.smooth = true;\n      }\n      const material = state.object.currentMaterial();\n      if (material) material.smooth = state.object.smooth;\n    } else {\n      // Handle null terminated files without exception\n      if (line === '\\0') continue;\n\n      throw new Error(`Unexpected line: \"${line}\"`);\n    }\n  }\n\n  state.finalize();\n\n  const meshes = [];\n  const materials = [];\n\n  for (const object of state.objects) {\n    const {geometry} = object;\n\n    // Skip o/g line declarations that did not follow with any faces\n    if (geometry.vertices.length === 0) continue;\n\n    const mesh = {\n      header: {\n        vertexCount: geometry.vertices.length / 3\n      },\n      attributes: {}\n    };\n\n    switch (geometry.type) {\n      case 'Points':\n        mesh.mode = 0; // GL.POINTS\n        break;\n      case 'Line':\n        mesh.mode = 1; // GL.LINES\n        break;\n      default:\n        mesh.mode = 4; // GL.TRIANGLES\n        break;\n    }\n\n    mesh.attributes.POSITION = {value: new Float32Array(geometry.vertices), size: 3};\n\n    if (geometry.normals.length > 0) {\n      mesh.attributes.NORMAL = {value: new Float32Array(geometry.normals), size: 3};\n    }\n\n    if (geometry.colors.length > 0) {\n      mesh.attributes.COLOR_0 = {value: new Float32Array(geometry.colors), size: 3};\n    }\n\n    if (geometry.uvs.length > 0) {\n      mesh.attributes.TEXCOORD_0 = {value: new Float32Array(geometry.uvs), size: 2};\n    }\n\n    // Create materials\n    mesh.materials = [];\n    for (const sourceMaterial of object.materials) {\n      // TODO - support full spec\n      const _material = {\n        name: sourceMaterial.name,\n        flatShading: !sourceMaterial.smooth\n      };\n      mesh.materials.push(_material);\n      materials.push(_material);\n    }\n\n    mesh.name = object.name;\n    meshes.push(mesh);\n  }\n\n  return {meshes, materials};\n}\n", "import {Schema, Field, FixedSizeList, getArrowTypeFromTypedArray} from '@loaders.gl/schema';\n\nexport function getOBJSchema(attributes, metadata = {}) {\n  let metadataMap;\n  for (const key in metadata) {\n    metadataMap = metadataMap || new Map();\n    if (key !== 'value') {\n      metadataMap.set(key, JSON.stringify(metadata[key]));\n    }\n  }\n\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(attributeName, attribute);\n    fields.push(field);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction getArrowFieldFromAttribute(attributeName, attribute) {\n  const metadataMap = new Map();\n  for (const key in attribute) {\n    if (key !== 'value') {\n      metadataMap.set(key, JSON.stringify(attribute[key]));\n    }\n  }\n\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  const isSingleValue = !('size' in attribute) || attribute.size === 1;\n  return isSingleValue\n    ? new Field(attributeName, type, false, metadataMap)\n    : new Field(\n      attributeName,\n      new FixedSizeList(attribute.size, new Field('value', type)),\n      false,\n      metadataMap\n    );\n}\n", "import type {MeshAttributes} from '@loaders.gl/schema';\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {parseOBJMeshes} from './parse-obj-meshes';\nimport {getOBJSchema} from './get-obj-schema';\n\nexport function parseOBJ(text, options) {\n  const {meshes} = parseOBJMeshes(text);\n\n  // @ts-expect-error\n  const vertexCount = meshes.reduce((s, mesh) => s + mesh.header.vertexCount, 0);\n  // TODO - render objects separately\n  const attributes = mergeAttributes(meshes, vertexCount);\n\n  const header = {\n    vertexCount,\n    // @ts-ignore Need to export Attributes type\n    boundingBox: getMeshBoundingBox(attributes)\n  };\n\n  const schema = getOBJSchema(attributes, {\n    mode: 4,\n    boundingBox: header.boundingBox\n  });\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n\n    // Normalised data\n    schema,\n    header,\n    mode: 4, // TRIANGLES\n\n    attributes\n  };\n}\n\n// eslint-disable-next-line max-statements\nfunction mergeAttributes(meshes, vertexCount) {\n  const positions = new Float32Array(vertexCount * 3);\n  let normals;\n  let colors;\n  let uvs;\n  let i = 0;\n\n  for (const mesh of meshes) {\n    const {POSITION, NORMAL, COLOR_0, TEXCOORD_0} = mesh.attributes;\n\n    positions.set(POSITION.value, i * 3);\n\n    if (NORMAL) {\n      normals = normals || new Float32Array(vertexCount * 3);\n      normals.set(NORMAL.value, i * 3);\n    }\n    if (COLOR_0) {\n      colors = colors || new Float32Array(vertexCount * 3);\n      colors.set(COLOR_0.value, i * 3);\n    }\n    if (TEXCOORD_0) {\n      uvs = uvs || new Float32Array(vertexCount * 2);\n      uvs.set(TEXCOORD_0.value, i * 2);\n    }\n\n    i += POSITION.value.length / 3;\n  }\n\n  const attributes: MeshAttributes = {};\n  attributes.POSITION = {value: positions, size: 3};\n\n  if (normals) {\n    attributes.NORMAL = {value: normals, size: 3};\n  }\n  if (colors) {\n    attributes.COLOR_0 = {value: colors, size: 3};\n  }\n  if (uvs) {\n    attributes.TEXCOORD_0 = {value: uvs, size: 2};\n  }\n\n  return attributes;\n}\n", "// loaders.gl, MIT license\n// Forked from THREE.js under MIT license\n// https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/MTLLoader.js\n\n// import type {DiffuseMaterial} from '@loaders.gl/schema';\n\nexport type MTLMaterial = {\n  name: string;\n  ambientColor?: [number, number, number];\n  diffuseColor?: [number, number, number];\n  specularColor?: [number, number, number];\n  emissiveColor?: [number, number, number];\n  // specular?: number;\n  shininess?: number;\n  refraction?: number;\n  illumination?: number;\n  diffuseTextureUrl?: string;\n  emissiveTextureUrl?: string;\n  specularTextureUrl?: string;\n};\n\nconst DELIMITER_PATTERN = /\\s+/;\n\n/**\n * Set of options on how to construct materials\n * @param normalizeRGB: RGBs need to be normalized to 0-1 from 0-255 (Default: false, assumed to be already normalized)\n * @param ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's Default: false\n * @param baseUrl - Url relative to which textures are loaded\n */\nexport type ParseMTLOptions = {\n  normalizeRGB?: boolean;\n  ignoreZeroRGBs?: boolean;\n  baseUrl?: string;\n};\n\n/**\n * Parses a MTL file.\n * Parses a Wavefront .mtl file specifying materials\n * http://paulbourke.net/dataformats/mtl/\n * https://www.loc.gov/preservation/digital/formats/fdd/fdd000508.shtml\n *\n * @param  text - Content of MTL file\n */\n// eslint-disable-next-line complexity\nexport function parseMTL(text: string, options?: ParseMTLOptions): MTLMaterial[] {\n  // const materialsInfo: Record<string, MTLMaterial> = {};\n  const materials: MTLMaterial[] = [];\n\n  let currentMaterial: MTLMaterial = {name: 'placeholder'};\n\n  const lines = text.split('\\n');\n  for (let line of lines) {\n    line = line.trim();\n\n    if (line.length === 0 || line.charAt(0) === '#') {\n      // Blank line or comment ignore\n      continue; // eslint-disable-line no-continue\n    }\n\n    const pos = line.indexOf(' ');\n\n    let key = pos >= 0 ? line.substring(0, pos) : line;\n    key = key.toLowerCase();\n\n    let value = pos >= 0 ? line.substring(pos + 1) : '';\n    value = value.trim();\n\n    switch (key) {\n      case 'newmtl':\n        // New material\n        currentMaterial = {name: value};\n        // insert into map\n        materials.push(currentMaterial);\n        break;\n\n      case 'ka': // Ka\n        currentMaterial.ambientColor = parseColor(value);\n        break;\n\n      case 'kd':\n        // Kd: Diffuse color (color under white light) using RGB values\n        currentMaterial.diffuseColor = parseColor(value);\n        break;\n      case 'map_kd':\n        // Diffuse texture map\n        currentMaterial.diffuseTextureUrl = value;\n        //         setMapForType('map', value);\n        break;\n\n      case 'ks':\n        // Specular color (color when light is reflected from shiny surface) using RGB values\n        currentMaterial.specularColor = parseColor(value);\n        break;\n      case 'map_ks':\n        // Specular map\n        currentMaterial.specularTextureUrl = value;\n        // setMapForType('specularMap', value);\n        break;\n\n      case 'ke':\n        // Emissive using RGB values\n        currentMaterial.emissiveColor = parseColor(value);\n        break;\n      case 'map_ke':\n        // Emissive map\n        currentMaterial.emissiveTextureUrl = value;\n        // setMapForType('emissiveMap', value);\n        break;\n\n      case 'ns':\n        // Ns is material specular exponent (defines the focus of the specular highlight)\n        // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n        currentMaterial.shininess = parseFloat(value);\n        break;\n      case 'map_ns':\n        // Ns is material specular exponent\n        // TODO?\n        // currentMaterial.shininessMap = parseFloat(value);\n        break;\n      case 'ni':\n        currentMaterial.refraction = parseFloat(value);\n        break;\n      case 'illum':\n        currentMaterial.illumination = parseFloat(value);\n        break;\n\n      default:\n        // log unknown message?\n        break;\n\n      /*\n      case 'norm':\n        setMapForType('normalMap', value);\n        break;\n\n      case 'map_bump':\n      case 'bump':\n        // Bump texture map\n        setMapForType('bumpMap', value);\n        break;\n\n      case 'd':\n        n = parseFloat(value);\n        if (n < 1) {\n          params.opacity = n;\n          params.transparent = true;\n        }\n        break;\n\n      case 'map_d':\n        // Alpha map\n        setMapForType('alphaMap', value);\n        params.transparent = true;\n        break;\n\n      case 'tr':\n        n = parseFloat(value);\n        if (this.options && this.options.invertTrProperty) n = 1 - n;\n        if (n > 0) {\n          params.opacity = 1 - n;\n          params.transparent = true;\n        }\n      */\n    }\n  }\n\n  return materials;\n}\n\nfunction parseColor(value: string, options?: ParseMTLOptions): [number, number, number] {\n  const rgb = value.split(DELIMITER_PATTERN, 3);\n  const color: [number, number, number] = [\n    parseFloat(rgb[0]),\n    parseFloat(rgb[1]),\n    parseFloat(rgb[2])\n  ];\n  // TODO auto detect big values?\n  // if (this.options && this.options.normalizeRGB) {\n  //   value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n  // }\n\n  // if (this.options && this.options.ignoreZeroRGBs) {\n  //   if (value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0) {\n  //     // ignore\n  //     save = false;\n  //   }\n  // }\n  return color;\n}\n\n/* TODO parse url options\nfunction parseTexture(value, matParams) {\n  const texParams = {\n    scale: new Vector2(1, 1),\n    offset: new Vector2(0, 0)\n  };\n\n  const items = value.split(/\\s+/);\n  let pos;\n\n  pos = items.indexOf('-bm');\n  if (pos >= 0) {\n    matParams.bumpScale = parseFloat(items[ pos + 1 ]);\n    items.splice(pos, 2);\n  }\n\n  pos = items.indexOf('-s');\n  if (pos >= 0) {\n    texParams.scale.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n    items.splice(pos, 4); // we expect 3 parameters here!\n\n  }\n\n  pos = items.indexOf('-o');\n\n  if (pos >= 0) {\n    texParams.offset.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n    items.splice(pos, 4); // we expect 3 parameters here!\n  }\n\n  texParams.url = items.join(' ').trim();\n  return texParams;\n}\n\n *function resolveURL(baseUrl, url) {\n * baseUrl?: string;\n    // Absolute URL\n    if (/^https?:\\/\\//i.test(url)) return url;\n    return baseUrl + url;\n  }\n\n  function setMapForType(mapType, value) {\n    if (params[ mapType ]) return; // Keep the first encountered texture\n\n    const texParams = scope.getTextureParams(value, params);\n    const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n\n    map.repeat.copy(texParams.scale);\n    map.offset.copy(texParams.offset);\n\n    map.wrapS = scope.wrap;\n    map.wrapT = scope.wrap;\n\n    params[ mapType ] = map;\n  }\n*/\n", "import type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type OBJLoaderOptions = LoaderOptions & {\n  obj?: {};\n};\n\n/**\n * Worker loader for the OBJ geometry format\n */\nexport const OBJLoader = {\n  name: 'OBJ',\n  id: 'obj',\n  module: 'obj',\n  version: VERSION,\n  worker: true,\n  extensions: ['obj'],\n  mimeTypes: ['text/plain'],\n  testText: testOBJFile,\n  options: {\n    obj: {}\n  }\n};\n\nfunction testOBJFile(text: string): boolean {\n  // TODO - There could be comment line first\n  return text[0] === 'v';\n}\n\nexport const _typecheckOBJLoader: Loader = OBJLoader;\n", "// loaders.gl, MIT license\nimport type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {ParseMTLOptions} from './lib/parse-mtl';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type MTLLoaderOptions = LoaderOptions & {\n  mtl?: ParseMTLOptions;\n};\n\n/**\n * Loader for the MTL material format\n * Parses a Wavefront .mtl file specifying materials\n */\nexport const MTLLoader = {\n  name: 'MTL',\n  id: 'mtl',\n  module: 'mtl',\n  version: VERSION,\n  worker: true,\n  extensions: ['mtl'],\n  mimeTypes: ['text/plain'],\n  testText: (text: string): boolean => text.includes('newmtl'),\n  options: {\n    mtl: {}\n  }\n};\n\nexport const _typecheckMTLLoader: Loader = MTLLoader;\n", "import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {parseOBJ} from './lib/parse-obj';\nimport {parseMTL} from './lib/parse-mtl';\nimport type {OBJLoaderOptions} from './obj-loader';\nimport {OBJLoader as OBJWorkerLoader} from './obj-loader';\nimport type {MTLLoaderOptions} from './mtl-loader';\nimport {MTLLoader as MTLWorkerLoader} from './mtl-loader';\n\n// OBJLoader\n\nexport {OBJWorkerLoader};\n\n/**\n * Loader for the OBJ geometry format\n */\nexport const OBJLoader = {\n  ...OBJWorkerLoader,\n  parse: async (arrayBuffer: ArrayBuffer, options?: OBJLoaderOptions) =>\n    parseOBJ(new TextDecoder().decode(arrayBuffer), options),\n  parseTextSync: (text: string, options?: OBJLoaderOptions) => parseOBJ(text, options)\n};\n\n// MTLLoader\n\n/**\n * Loader for the MTL material format\n */\nexport const MTLLoader = {\n  ...MTLWorkerLoader,\n  parse: async (arrayBuffer: ArrayBuffer, options?: MTLLoaderOptions) =>\n    parseMTL(new TextDecoder().decode(arrayBuffer), options?.mtl),\n  parseTextSync: (text: string, options?: MTLLoaderOptions) => parseMTL(text, options?.mtl)\n};\n\nexport const _typecheckOBJLoader: LoaderWithParser = OBJLoader;\nexport const _typecheckMTLLoader: LoaderWithParser = MTLLoader;\n"],
  "mappings": "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",
  "names": ["OBJECT_RE", "MATERIAL_RE", "MATERIAL_USE_RE", "MeshMaterial", "constructor", "_ref", "index", "name", "mtllib", "smooth", "groupStart", "groupEnd", "groupCount", "inherited", "clone", "arguments", "length", "undefined", "MeshObject", "geometry", "vertices", "normals", "colors", "uvs", "materials", "fromDeclaration", "startMaterial", "libraries", "previous", "_finalize", "splice", "material", "Array", "isArray", "push", "currentMaterial", "end", "lastMultiMaterial", "mi", "ParserState", "objects", "object", "materialLibraries", "startObject", "previousMaterial", "declared", "finalize", "parseVertexIndex", "value", "len", "parseInt", "parseNormalIndex", "parseUVIndex", "addVertex", "a", "b", "c", "src", "dst", "addVertexPoint", "addVertexLine", "addNormal", "addColor", "addUV", "addUVLine", "addFace", "ua", "ub", "uc", "na", "nb", "nc", "vLen", "ia", "ib", "ic", "uvLen", "nLen", "addPointGeometry", "type", "vertex", "addLineGeometry", "uv", "parseOBJMeshes", "text", "state", "indexOf", "replace", "lines", "split", "line", "lineFirstChar", "lineLength", "result", "trimLeft", "i", "l", "trim", "charAt", "data", "parseFloat", "lineData", "substr", "vertexData", "faceVertices", "j", "jl", "vertexParts", "v1", "v2", "v3", "lineParts", "substring", "lineVertices", "lineUVs", "li", "llen", "parts", "pointData", "exec", "test", "toLowerCase", "Error", "concat", "meshes", "mesh", "header", "vertexCount", "attributes", "mode", "POSITION", "Float32Array", "size", "NORMAL", "COLOR_0", "TEXCOORD_0", "sourceMaterial", "_material", "flatShading", "getOBJSchema", "attributes", "metadata", "arguments", "length", "undefined", "metadataMap", "key", "Map", "set", "JSON", "stringify", "fields", "attributeName", "attribute", "field", "getArrowFieldFromAttribute", "push", "Schema", "type", "getArrowTypeFromTypedArray", "value", "isSingleValue", "size", "Field", "FixedSizeList", "parseOBJ", "text", "options", "meshes", "parseOBJMeshes", "vertexCount", "reduce", "s", "mesh", "header", "attributes", "mergeAttributes", "boundingBox", "getMeshBoundingBox", "schema", "getOBJSchema", "mode", "loaderData", "positions", "Float32Array", "normals", "colors", "uvs", "i", "POSITION", "NORMAL", "COLOR_0", "TEXCOORD_0", "set", "value", "length", "size", "DELIMITER_PATTERN", "parseMTL", "text", "options", "materials", "currentMaterial", "name", "lines", "split", "line", "trim", "length", "charAt", "pos", "indexOf", "key", "substring", "toLowerCase", "value", "push", "ambientColor", "parseColor", "diffuseColor", "diffuseTextureUrl", "specularColor", "specularTextureUrl", "emissiveColor", "emissiveTextureUrl", "shininess", "parseFloat", "refraction", "illumination", "rgb", "color", "VERSION", "OBJLoader", "name", "id", "module", "version", "worker", "extensions", "mimeTypes", "testText", "testOBJFile", "options", "obj", "text", "VERSION", "MTLLoader", "name", "id", "module", "version", "worker", "extensions", "mimeTypes", "testText", "text", "includes", "options", "mtl", "OBJLoader", "OBJWorkerLoader", "parse", "arrayBuffer", "options", "parseOBJ", "TextDecoder", "decode", "parseTextSync", "text", "MTLLoader", "MTLWorkerLoader", "parseMTL", "mtl", "_typecheckOBJLoader", "_typecheckMTLLoader"]
}
