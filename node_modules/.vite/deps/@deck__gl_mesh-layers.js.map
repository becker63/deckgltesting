{
  "version": 3,
  "sources": ["../../@deck.gl/mesh-layers/src/utils/matrix.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer.ts", "../../@luma.gl/experimental/src/scenegraph/scenegraph-node.js", "../../@luma.gl/experimental/src/scenegraph/group-node.js", "../../@luma.gl/experimental/src/gltf/gltf-animator.js", "../../@luma.gl/experimental/src/scenegraph/model-node.js", "../../@luma.gl/experimental/src/gltf/gltf-material-parser.js", "../../@luma.gl/experimental/src/gltf/create-gltf-model.js", "../../@luma.gl/experimental/src/gltf/gltf-instantiator.js", "../../@luma.gl/experimental/src/gltf/create-gltf-objects.js", "../../@luma.gl/experimental/src/gpgpu/point-in-polygon/polygon.js", "../../@loaders.gl/gltf/src/lib/utils/version.ts", "../../@loaders.gl/textures/src/lib/utils/version.ts", "../../@loaders.gl/textures/src/lib/parsers/basis-module-loader.ts", "../../@loaders.gl/textures/src/lib/gl-extensions.ts", "../../@loaders.gl/textures/src/lib/utils/texture-formats.ts", "../../ktx-parse/src/constants.ts", "../../ktx-parse/src/container.ts", "../../ktx-parse/src/buffer-reader.ts", "../../ktx-parse/src/util.ts", "../../ktx-parse/src/read.ts", "../../ktx-parse/src/write.ts", "../../@loaders.gl/textures/src/lib/utils/extract-mipmap-images.ts", "../../@loaders.gl/textures/src/lib/utils/ktx-format-helper.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-ktx.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-basis.ts", "../../@loaders.gl/textures/src/basis-loader.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-dds.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-pvr.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-compressed-texture.ts", "../../@loaders.gl/textures/src/compressed-texture-loader.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-npy.ts", "../../@loaders.gl/textures/src/npy-loader.ts", "../../@loaders.gl/gltf/src/lib/utils/assert.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/resolve-url.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/get-typed-array.ts", "../../@loaders.gl/gltf/src/lib/extensions/EXT_meshopt_compression.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/gltf-utils.ts", "../../@loaders.gl/gltf/src/lib/api/gltf-scenegraph.ts", "../../@loaders.gl/gltf/src/meshopt/meshopt-decoder.ts", "../../@loaders.gl/gltf/src/lib/extensions/EXT_texture_webp.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_texture_basisu.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_draco_mesh_compression.ts", "../../@loaders.gl/draco/src/lib/utils/version.ts", "../../@loaders.gl/draco/src/draco-loader.ts", "../../@loaders.gl/draco/src/lib/utils/get-draco-schema.ts", "../../@loaders.gl/draco/src/lib/draco-parser.ts", "../../@loaders.gl/draco/src/lib/draco-module-loader.ts", "../../@loaders.gl/draco/src/index.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/gltf-attribute-utils.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_texture_transform.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/gltf-constants.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_lights_punctual.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_materials_unlit.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_techniques_webgl.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/EXT_feature_metadata.ts", "../../@loaders.gl/gltf/src/lib/api/gltf-extensions.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_binary_gltf.ts", "../../@loaders.gl/gltf/src/lib/api/normalize-gltf-v1.ts", "../../@loaders.gl/gltf/src/lib/api/post-process-gltf.ts", "../../@loaders.gl/gltf/src/lib/parsers/parse-glb.ts", "../../@loaders.gl/gltf/src/lib/parsers/parse-gltf.ts", "../../@loaders.gl/gltf/src/gltf-loader.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/gltf-utils.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-vertex.glsl.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-fragment.glsl.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer.ts"],
  "sourcesContent": ["import {COORDINATE_SYSTEM, createIterable} from '@deck.gl/core';\n\n/* eslint-disable max-statements, complexity, camelcase */\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\n\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  const pitch = orientation[0] * RADIAN_PER_DEGREE;\n  const yaw = orientation[1] * RADIAN_PER_DEGREE;\n  const roll = orientation[2] * RADIAN_PER_DEGREE;\n\n  const sr = Math.sin(roll);\n  const sp = Math.sin(pitch);\n  const sw = Math.sin(yaw);\n\n  const cr = Math.cos(roll);\n  const cp = Math.cos(pitch);\n  const cw = Math.cos(yaw);\n\n  const scx = scale[0];\n  const scy = scale[1];\n  const scz = scale[2];\n\n  targetMatrix[0] = scx * cw * cp; // 0,0\n  targetMatrix[1] = scx * sw * cp; // 1,0\n  targetMatrix[2] = scx * -sp; // 2,0\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1\n  targetMatrix[5] = scy * cp * sr; // 2,1\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2\n  targetMatrix[8] = scz * cp * cr; // 2,2\n}\n\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n\n  return mat4.subarray(0, 12);\n}\n\nexport const MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrix__LOCATION_0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrix__LOCATION_1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrix__LOCATION_2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  } as const,\n\n  update(attribute, {startRow, endRow}) {\n    // @ts-expect-error: \"this\" will be bound to a layer when this function is called\n    const {data, getOrientation, getScale, getTranslation, getTransformMatrix} = this.props;\n\n    const arrayMatrix = Array.isArray(getTransformMatrix);\n    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    const constantScale = Array.isArray(getScale);\n    const constantOrientation = Array.isArray(getOrientation);\n    const constantTranslation = Array.isArray(getTranslation);\n\n    const hasMatrix = constantMatrix || (!arrayMatrix && Boolean(getTransformMatrix(data[0])));\n\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n\n    const instanceModelMatrixData = attribute.value;\n\n    if (attribute.constant) {\n      let matrix;\n\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n\n        const orientation = getOrientation;\n        const scale = getScale;\n\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n\n      attribute.value = new Float32Array(matrix);\n    } else {\n      let i = startRow * attribute.size;\n      const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n      for (const object of iterable) {\n        objectInfo.index++;\n        let matrix;\n\n        if (hasMatrix) {\n          modelMatrix.set(\n            constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)\n          );\n          matrix = getExtendedMat3FromMat4(modelMatrix);\n        } else {\n          matrix = valueArray;\n\n          const orientation = constantOrientation\n            ? getOrientation\n            : getOrientation(object, objectInfo);\n          const scale = constantScale ? getScale : getScale(object, objectInfo);\n\n          calculateTransformMatrix(matrix, orientation, scale);\n          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n        }\n\n        instanceModelMatrixData[i++] = matrix[0];\n        instanceModelMatrixData[i++] = matrix[1];\n        instanceModelMatrixData[i++] = matrix[2];\n        instanceModelMatrixData[i++] = matrix[3];\n        instanceModelMatrixData[i++] = matrix[4];\n        instanceModelMatrixData[i++] = matrix[5];\n        instanceModelMatrixData[i++] = matrix[6];\n        instanceModelMatrixData[i++] = matrix[7];\n        instanceModelMatrixData[i++] = matrix[8];\n        instanceModelMatrixData[i++] = matrix[9];\n        instanceModelMatrixData[i++] = matrix[10];\n        instanceModelMatrixData[i++] = matrix[11];\n      }\n    }\n  }\n};\n\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return (\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n    (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial)\n  );\n}\n", "export default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\n\n// Scale the model\nuniform float sizeScale;\nuniform bool composeModelMatrix;\n\n// Primitive attributes\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\n\n// Outputs to fragment shader\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project_uCameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\n\n  if (composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "export default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (flatShading) {\n\n// NOTE(Tarek): This is necessary because\n// headless.gl reports the extension as\n// available but does not support it in\n// the shader.\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * opacity);\n}\n`;\n", "// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Layer,\n  project32,\n  phongLighting,\n  picking,\n  DefaultProps,\n  log,\n  LayerContext,\n  Material\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, Texture2D, isWebGL2} from '@luma.gl/core';\nimport {hasFeature, FEATURES} from '@luma.gl/webgl';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport vs from './simple-mesh-layer-vertex.glsl';\nimport fs from './simple-mesh-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  UpdateParameters,\n  Accessor,\n  Position,\n  Color,\n  Texture\n} from '@deck.gl/core';\nimport type {MeshAttribute, MeshAttributes} from '@loaders.gl/schema';\nimport type {Geometry as GeometryType} from '@luma.gl/engine';\nimport {GLTFMaterialParser} from '@luma.gl/experimental';\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\n\nfunction validateGeometryAttributes(attributes: Record<string, any>, useMeshColors: boolean): void {\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n  const useColorAttribute = hasColorAttribute && useMeshColors;\n  if (!useColorAttribute) {\n    attributes.colors = {constant: true, value: new Float32Array([1, 1, 1])};\n  }\n  log.assert(\n    attributes.positions || attributes.POSITION,\n    'no \"postions\" or \"POSITION\" attribute in mesh'\n  );\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data: Mesh, useMeshColors: boolean): Geometry {\n  if ((data as any).attributes) {\n    validateGeometryAttributes((data as any).attributes, useMeshColors);\n    if (data instanceof Geometry) {\n      return data;\n    } else {\n      return new Geometry(data);\n    }\n  } else if ((data as MeshAttributes).positions || (data as MeshAttributes).POSITION) {\n    validateGeometryAttributes(data, useMeshColors);\n    return new Geometry({\n      attributes: data\n    });\n  }\n  throw Error('Invalid mesh');\n}\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\ntype Mesh =\n  | GeometryType\n  | {\n      attributes: MeshAttributes;\n      indices?: MeshAttribute;\n    }\n  | MeshAttributes;\n\ntype _SimpleMeshLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  mesh: string | Mesh | Promise<Mesh> | null;\n  texture?: string | Texture | Promise<Texture>;\n  /** Customize the [texture parameters](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter). */\n  textureParameters?: Record<number, number> | null;\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * If `mesh` does not contain vertex colors, use this color to render each object.\n   * If `mesh` contains vertex colors, then the two colors are mixed together.\n   * Use `[255, 255, 255]` to use the original mesh colors.\n   * If `texture` is assigned, then both colors will be ignored.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * @deprecated Whether to color pixels using vertex colors supplied in the mesh (the `COLOR_0` or `colors` attribute).\n   * If set to `false` vertex colors will be ignored.\n   * This prop will be removed and set to always true in the next major release.\n   * @default false\n   */\n  _useMeshColors?: boolean;\n\n  /**\n   * (Experimental) If rendering only one instance of the mesh, set this to false to treat mesh positions\n   * as deltas of the world coordinates of the anchor.\n   * E.g. in LNGLAT coordinates, mesh positions are interpreted as meter offsets by default.\n   * setting _instanced to false interpreted mesh positions as lnglat deltas.\n   * @default true\n   */\n  _instanced?: boolean; // TODO - formalize API\n  /**\n   * Whether to render the mesh in wireframe mode.\n   * @default false\n   */\n  wireframe?: boolean;\n  /**\n   * Material props for lighting effect.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting#constructing-a-material-instance\n   */\n  material?: Material;\n};\n\nexport type SimpleMeshLayerProps<DataT = any> = _SimpleMeshLayerProps<DataT> & LayerProps;\n\nconst defaultProps: DefaultProps<SimpleMeshLayerProps> = {\n  mesh: {type: 'object', value: null, async: true},\n  texture: {type: 'image', value: null, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n  // Whether the color attribute in a mesh will be used\n  // This prop will be removed and set to true in next major release\n  _useMeshColors: {type: 'boolean', value: false},\n\n  // _instanced is a hack to use world position instead of meter offsets in mesh\n  // TODO - formalize API\n  _instanced: true,\n  // NOTE(Tarek): Quick and dirty wireframe. Just draws\n  // the same mesh with LINE_STRIPS. Won't follow edges\n  // of the original mesh.\n  wireframe: false,\n  // Optional material for 'lighting' shader module\n  material: true,\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  textureParameters: {type: 'object', ignore: true}\n};\n\n/** Render a number of instances of an arbitrary 3D geometry. */\nexport default class SimpleMeshLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_SimpleMeshLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'SimpleMeshLayer';\n\n  state!: {\n    materialParser?: GLTFMaterialParser;\n    model?: Model;\n    emptyTexture: Texture2D;\n    hasNormals?: boolean;\n    positionBounds?: [number[], number[]] | null;\n  };\n\n  getShaders() {\n    const transpileToGLSL100 = !isWebGL2(this.context.gl);\n\n    const defines: any = {};\n\n    if (hasFeature(this.context.gl, FEATURES.GLSL_DERIVATIVES)) {\n      defines.DERIVATIVES_AVAILABLE = 1;\n    }\n\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, phongLighting, picking],\n      transpileToGLSL100,\n      defines\n    });\n  }\n\n  getBounds(): [number[], number[]] | null {\n    if (this.props._instanced) {\n      return super.getBounds();\n    }\n    let result = this.state.positionBounds;\n    if (result) {\n      return result;\n    }\n    const {mesh} = this.props;\n    if (!mesh) {\n      return null;\n    }\n    // @ts-ignore Detect if mesh is generated by loaders.gl\n    result = mesh.header?.boundingBox;\n\n    if (!result) {\n      // Otherwise, calculate bounding box from positions\n      const {attributes} = getGeometry(mesh as Mesh, this.props._useMeshColors);\n      attributes.POSITION = attributes.POSITION || attributes.positions;\n      result = getMeshBoundingBox(attributes);\n    }\n\n    this.state.positionBounds = result;\n    return result;\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined in a primitive layer\n    attributeManager!.addInstanced({\n      instancePositions: {\n        transition: true,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        size: 3,\n        accessor: 'getPosition'\n      },\n      instanceColors: {\n        type: GL.UNSIGNED_BYTE,\n        transition: true,\n        size: this.props.colorFormat.length,\n        normalized: true,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n\n    this.setState({\n      // Avoid luma.gl's missing uniform warning\n      // TODO - add feature to luma.gl to specify ignored uniforms?\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {\n      this.state.positionBounds = null;\n      this.state.model?.delete();\n      if (props.mesh) {\n        this.state.model = this.getModel(props.mesh as Mesh);\n\n        const attributes = (props.mesh as any).attributes || props.mesh;\n        this.setState({\n          hasNormals: Boolean(attributes.NORMAL || attributes.normals)\n        });\n      }\n      // attributeManager is always defined in a primitive layer\n      this.getAttributeManager()!.invalidateAll();\n    }\n\n    if (props.texture !== oldProps.texture) {\n      this.setTexture(props.texture);\n    }\n\n    if (this.state.model) {\n      this.state.model.setDrawMode(this.props.wireframe ? GL.LINE_STRIP : GL.TRIANGLES);\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n\n    this.state.emptyTexture.delete();\n  }\n\n  draw({uniforms}) {\n    if (!this.state.model) {\n      return;\n    }\n\n    const {viewport} = this.context;\n    const {sizeScale, coordinateSystem, _instanced} = this.props;\n\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms({\n        sizeScale,\n        composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),\n        flatShading: !this.state.hasNormals\n      })\n      .draw();\n  }\n\n  protected getModel(mesh: Mesh): Model {\n    const model = new Model(this.context.gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: getGeometry(mesh, this.props._useMeshColors),\n      isInstanced: true\n    });\n\n    const {texture} = this.props;\n    const {emptyTexture} = this.state;\n    model.setUniforms({\n      sampler: texture || emptyTexture,\n      hasTexture: Boolean(texture)\n    });\n\n    return model;\n  }\n\n  private setTexture(texture: Texture2D): void {\n    const {emptyTexture, model} = this.state;\n\n    // props.mesh may not be ready at this time.\n    // The sampler will be set when `getModel` is called\n    if (model) {\n      model.setUniforms({\n        sampler: texture || emptyTexture,\n        hasTexture: Boolean(texture)\n      });\n    }\n  }\n}\n", "import {Vector3, Matrix4} from '@math.gl/core';\nimport {assert, uid} from '@luma.gl/webgl';\n\nexport default class ScenegraphNode {\n  constructor(props = {}) {\n    const {id} = props;\n\n    this.id = id || uid(this.constructor.name);\n\n    this.display = true; // whether to display the object at all\n    this.position = new Vector3();\n    this.rotation = new Vector3();\n    this.scale = new Vector3(1, 1, 1);\n    this.matrix = new Matrix4();\n    this.userData = {};\n\n    this.props = {};\n    this._setScenegraphNodeProps(props);\n  }\n\n  delete() {}\n\n  setProps(props) {\n    this._setScenegraphNodeProps(props);\n    return this;\n  }\n\n  toString() {\n    return `{type: ScenegraphNode, id: ${this.id})}`;\n  }\n\n  getBounds() {\n    return null;\n  }\n\n  setPosition(position) {\n    assert(position.length === 3, 'setPosition requires vector argument');\n    this.position = position;\n    return this;\n  }\n\n  setRotation(rotation) {\n    assert(rotation.length === 3, 'setRotation requires vector argument');\n    this.rotation = rotation;\n    return this;\n  }\n\n  setScale(scale) {\n    assert(scale.length === 3, 'setScale requires vector argument');\n    this.scale = scale;\n    return this;\n  }\n\n  setMatrix(matrix, copyMatrix = true) {\n    if (copyMatrix) {\n      this.matrix.copy(matrix);\n    } else {\n      this.matrix = matrix;\n    }\n  }\n\n  setMatrixComponents({position, rotation, scale, update = true}) {\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    if (update) {\n      this.updateMatrix();\n    }\n    return this;\n  }\n\n  updateMatrix() {\n    const pos = this.position;\n    const rot = this.rotation;\n    const scale = this.scale;\n\n    this.matrix.identity();\n    this.matrix.translate(pos);\n    this.matrix.rotateXYZ(rot);\n    this.matrix.scale(scale);\n    return this;\n  }\n\n  update(options = {}) {\n    const {position, rotation, scale} = options;\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    this.updateMatrix();\n    return this;\n  }\n\n  getCoordinateUniforms(viewMatrix, modelMatrix) {\n    // TODO - solve multiple class problem\n    // assert(viewMatrix instanceof Matrix4);\n    assert(viewMatrix);\n    modelMatrix = modelMatrix || this.matrix;\n    const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix);\n    const worldInverse = worldMatrix.invert();\n    const worldInverseTranspose = worldInverse.transpose();\n\n    return {\n      viewMatrix,\n      modelMatrix,\n      objectMatrix: modelMatrix,\n      worldMatrix,\n      worldInverseMatrix: worldInverse,\n      worldInverseTransposeMatrix: worldInverseTranspose\n    };\n  }\n\n  // TODO - copied code, not yet vetted\n  /*\n  transform() {\n    if (!this.parent) {\n      this.endPosition.set(this.position);\n      this.endRotation.set(this.rotation);\n      this.endScale.set(this.scale);\n    } else {\n      const parent = this.parent;\n      this.endPosition.set(this.position.add(parent.endPosition));\n      this.endRotation.set(this.rotation.add(parent.endRotation));\n      this.endScale.set(this.scale.add(parent.endScale));\n    }\n\n    const ch = this.children;\n    for (let i = 0; i < ch.length; ++i) {\n      ch[i].transform();\n    }\n\n    return this;\n  }\n  */\n\n  _setScenegraphNodeProps(props) {\n    if ('display' in props) {\n      this.display = props.display;\n    }\n\n    if ('position' in props) {\n      this.setPosition(props.position);\n    }\n    if ('rotation' in props) {\n      this.setRotation(props.rotation);\n    }\n    if ('scale' in props) {\n      this.setScale(props.scale);\n    }\n\n    // Matrix overwrites other props\n    if ('matrix' in props) {\n      this.setMatrix(props.matrix);\n    }\n\n    Object.assign(this.props, props);\n  }\n}\n", "import {Matrix4, Vector3} from '@math.gl/core';\nimport {log} from '@luma.gl/webgl';\nimport ScenegraphNode from './scenegraph-node';\n\nexport default class GroupNode extends ScenegraphNode {\n  constructor(props = {}) {\n    props = Array.isArray(props) ? {children: props} : props;\n    const {children = []} = props;\n    log.assert(\n      children.every(child => child instanceof ScenegraphNode),\n      'every child must an instance of ScenegraphNode'\n    );\n    super(props);\n    this.children = children;\n  }\n\n  // Unpacks arrays and nested arrays of children\n  add(...children) {\n    for (const child of children) {\n      if (Array.isArray(child)) {\n        this.add(...child);\n      } else {\n        this.children.push(child);\n      }\n    }\n    return this;\n  }\n\n  remove(child) {\n    const children = this.children;\n    const indexOf = children.indexOf(child);\n    if (indexOf > -1) {\n      children.splice(indexOf, 1);\n    }\n    return this;\n  }\n\n  removeAll() {\n    this.children = [];\n    return this;\n  }\n\n  delete() {\n    this.children.forEach(child => child.delete());\n    this.removeAll();\n    super.delete();\n  }\n\n  getBounds() {\n    /** @type [number[], number[]] */\n    const result = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n\n    this.traverse((node, {worldMatrix}) => {\n      const bounds = node.getBounds();\n      if (!bounds) {\n        return;\n      }\n      const [min, max] = bounds;\n      const center = new Vector3(min).add(max).divide([2, 2, 2]);\n      worldMatrix.transformAsPoint(center, center);\n      const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);\n      worldMatrix.transformAsVector(halfSize, halfSize);\n\n      for (let v = 0; v < 8; v++) {\n        // Test all 8 corners of the box\n        const position = new Vector3(v & 0b001 ? -1 : 1, v & 0b010 ? -1 : 1, v & 0b100 ? -1 : 1)\n          .multiply(halfSize)\n          .add(center);\n\n        for (let i = 0; i < 3; i++) {\n          result[0][i] = Math.min(result[0][i], position[i]);\n          result[1][i] = Math.max(result[1][i], position[i]);\n        }\n      }\n    });\n    if (!Number.isFinite(result[0][0])) {\n      return null;\n    }\n    return result;\n  }\n\n  traverse(visitor, {worldMatrix = new Matrix4()} = {}) {\n    const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n\n    for (const child of this.children) {\n      if (child instanceof GroupNode) {\n        child.traverse(visitor, {worldMatrix: modelMatrix});\n      } else {\n        visitor(child, {worldMatrix: modelMatrix});\n      }\n    }\n  }\n}\n", "import {assert, log} from '@luma.gl/webgl';\nimport {Matrix4, Quaternion} from '@math.gl/core';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  // TODO(Tarek): This should be removed? (deck.gl is using this)\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n", "import {Model} from '@luma.gl/engine';\nimport ScenegraphNode from './scenegraph-node';\n\nexport default class ModelNode extends ScenegraphNode {\n  constructor(gl, props = {}) {\n    super(props);\n\n    // pverride callbacks to make sure we call them with this\n    this.onBeforeRender = null;\n    this.AfterRender = null;\n\n    // Create new Model or used supplied Model\n    if (gl instanceof Model) {\n      this.model = gl;\n      this._setModelNodeProps(props);\n    } else {\n      this.model = new Model(gl, props);\n    }\n\n    this.bounds = null;\n    this.managedResources = props.managedResources || [];\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelNodeProps(props);\n    return this;\n  }\n\n  getBounds() {\n    return this.bounds;\n  }\n\n  delete() {\n    if (this.model) {\n      this.model.delete();\n      this.model = null;\n    }\n\n    this.managedResources.forEach(resource => resource.delete());\n    this.managedResources = [];\n  }\n\n  // Forward node methods\n  draw(...args) {\n    // Return value indicates if something was actually drawn\n    return this.model.draw(...args);\n  }\n\n  setUniforms(...args) {\n    this.model.setUniforms(...args);\n    return this;\n  }\n\n  setAttributes(...args) {\n    this.model.setAttributes(...args);\n    return this;\n  }\n\n  updateModuleSettings(...args) {\n    this.model.updateModuleSettings(...args);\n    return this;\n  }\n\n  // PRIVATE\n\n  _setModelNodeProps(props) {\n    this.model.setProps(props);\n  }\n}\n", "import {Texture2D, hasFeature, FEATURES, log} from '@luma.gl/webgl';\n\nexport default class GLTFMaterialParser {\n  constructor(\n    gl,\n    {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents}\n  ) {\n    this.gl = gl;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      u_Camera: [0, 0, 0], // Model should override\n\n      u_MetallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  defineIfPresent(value, name) {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  parseTexture(gltfTexture, name, define = null) {\n    const parameters =\n      (gltfTexture.texture &&\n        gltfTexture.texture.sampler &&\n        gltfTexture.texture.sampler.parameters) ||\n      {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [this.gl.TEXTURE_MIN_FILTER]:\n          image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture = new Texture2D(this.gl, {\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [this.gl.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.uniforms[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'u_BaseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'u_MetallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  parseMaterial(material) {\n    this.uniforms.pbr_uUnlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.u_NormalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.u_OcclusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: this.gl.FUNC_ADD,\n        blendFunc: [\n          this.gl.SRC_ALPHA,\n          this.gl.ONE_MINUS_SRC_ALPHA,\n          this.gl.ONE,\n          this.gl.ONE_MINUS_SRC_ALPHA\n        ]\n      });\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   */\n  delete() {\n    this.generatedTextures.forEach(texture => texture.delete());\n  }\n}\n", "import {isWebGL2} from '@luma.gl/gltools';\nimport {log} from '@luma.gl/webgl';\nimport {pbr} from '@luma.gl/shadertools';\nimport ModelNode from '../scenegraph/model-node';\nimport GLTFMaterialParser from './gltf-material-parser';\n\nconst vs = `\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n`;\n\nconst fs = `\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n`;\n\nfunction addVersionToShader(gl, source) {\n  if (isWebGL2(gl)) {\n    return `#version 300 es\\n${source}`;\n  }\n\n  return source;\n}\n\nexport default function createGLTFModel(gl, options) {\n  const {id, drawMode, vertexCount, attributes, modelOptions} = options;\n  const materialParser = new GLTFMaterialParser(gl, options);\n\n  log.info(4, 'createGLTFModel defines: ', materialParser.defines)();\n\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources = [];\n  managedResources.push(...materialParser.generatedTextures);\n  managedResources.push(...Object.values(attributes).map(attribute => attribute.buffer));\n\n  const model = new ModelNode(\n    gl,\n    Object.assign(\n      {\n        id,\n        drawMode,\n        vertexCount,\n        modules: [pbr],\n        defines: materialParser.defines,\n        parameters: materialParser.parameters,\n        vs: addVersionToShader(gl, vs),\n        fs: addVersionToShader(gl, fs),\n        managedResources\n      },\n      modelOptions\n    )\n  );\n\n  model.setProps({attributes});\n  model.setUniforms(materialParser.uniforms);\n\n  return model;\n}\n", "import {Matrix4} from '@math.gl/core';\nimport {Buffer, Accessor, log} from '@luma.gl/webgl';\nimport GroupNode from '../scenegraph/group-node';\n\nimport GLTFAnimator from './gltf-animator';\nimport createGLTFModel from './create-gltf-model';\n\n// TODO: import {ATTRIBUTE_TYPE_TO_COMPONENTS} from '@loaders.gl/gltf';\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst DEFAULT_OPTIONS = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n\n// GLTF instantiator for luma.gl\n// Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\nexport default class GLTFInstantiator {\n  constructor(gl, options = {}) {\n    this.gl = gl;\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  }\n\n  instantiate(gltf) {\n    this.gltf = gltf;\n    const scenes = (gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n\n  createAnimator() {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n\n    return null;\n  }\n\n  createScene(gltfScene) {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n\n      // Node can have children nodes and meshes at the same time\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n\n        if (gltfNode.rotation) {\n          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n      gltfNode._node = node;\n    }\n\n    return gltfNode._node;\n  }\n\n  createMesh(gltfMesh) {\n    // TODO: avoid changing the gltf\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) =>\n        this.createPrimitive(gltfPrimitive, i, gltfMesh)\n      );\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n\n    return gltfMesh._mesh;\n  }\n\n  getVertexCount(attributes) {\n    // TODO: implement this\n    log.warn('getVertexCount() not found')();\n  }\n\n  createPrimitive(gltfPrimitive, i, gltfMesh) {\n    const model = createGLTFModel(\n      this.gl,\n      Object.assign(\n        {\n          id: gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`,\n          drawMode: gltfPrimitive.mode || 4,\n          vertexCount: gltfPrimitive.indices\n            ? gltfPrimitive.indices.count\n            : this.getVertexCount(gltfPrimitive.attributes),\n          attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),\n          material: gltfPrimitive.material\n        },\n        this.options\n      )\n    );\n\n    model.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];\n\n    return model;\n  }\n\n  createAttributes(attributes, indices) {\n    const loadedAttributes = {};\n\n    Object.keys(attributes).forEach(attrName => {\n      loadedAttributes[attrName] = this.createAccessor(\n        attributes[attrName],\n        this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER)\n      );\n    });\n\n    if (indices) {\n      loadedAttributes.indices = this.createAccessor(\n        indices,\n        this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER)\n      );\n    }\n\n    log.info(4, 'glTF Attributes', {attributes, indices, generated: loadedAttributes})();\n\n    return loadedAttributes;\n  }\n\n  createBuffer(attribute, target) {\n    if (!attribute.bufferView) {\n      // Draco decoded files do not have a bufferView\n      attribute.bufferView = {};\n    }\n\n    const {bufferView} = attribute;\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n\n    if (!bufferView.lumaBuffers[target]) {\n      bufferView.lumaBuffers[target] = new Buffer(this.gl, {\n        id: `from-${bufferView.id}`,\n        // Draco decoded files have attribute.value\n        data: bufferView.data || attribute.value,\n        target\n      });\n    }\n\n    return bufferView.lumaBuffers[target];\n  }\n\n  createAccessor(accessor, buffer) {\n    return new Accessor({\n      buffer,\n      offset: accessor.byteOffset || 0,\n      stride: accessor.bufferView.byteStride || 0,\n      type: accessor.componentType,\n      size: ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type]\n    });\n  }\n\n  // TODO - create sampler in WebGL2\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n\n  // Helper methods (move to GLTFLoader.resolve...?)\n\n  needsPOT() {\n    // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n    // Has a minification filter (minFilter) that uses mipmapping\n    // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n    // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n    return false;\n  }\n}\n", "import GLTFInstantiator from './gltf-instantiator';\n\nexport default function createGLTFObjects(gl, gltf, options) {\n  const instantiator = new GLTFInstantiator(gl, options);\n  const scenes = instantiator.instantiate(gltf);\n  const animator = instantiator.createAnimator();\n\n  return {scenes, animator};\n}\n", "// => COPIED FROM  deck.gl\n\n// Copyright (c) 2015 - 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\n\n// For Web Mercator projection\nconst PI_4 = Math.PI / 4;\nconst DEGREES_TO_RADIANS_HALF = Math.PI / 360;\n\n// 4 data formats are supported:\n// Simple Polygon: an array of points\n// Complex Polygon: an array of array of points (array of rings)\n//   with the first ring representing the outer hull and other rings representing holes\n// Simple Flat: an array of numbers (flattened \"simple polygon\")\n// Complex Flat: {position: array<number>, holeIndices: array<number>}\n//   (flattened \"complex polygon\")\n\n/**\n * Ensure a polygon is valid format\n * @param {Array|Object} polygon\n */\nfunction validate(polygon) {\n  polygon = (polygon && polygon.positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/**\n * Check if a polygon is simple or complex\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * @param {Array} simplePolygon - array of points\n * @return {Boolean} - true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon) {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} startIndex - start index of the path in the positions array\n * @param {Number} endIndex - end index of the path in the positions array\n * @return {Boolean} - true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} simplePolygon - array of points\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [srcStartIndex] - start index of the path in the positions array\n * @param {Number} [srcEndIndex] - end index of the path in the positions array\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Counts the number of vertices in a simple polygon, closes the polygon if needed.\n * @param {Array} simplePolygon - array of points\n * @returns {Number} vertex count\n */\nfunction getNestedVertexCount(simplePolygon) {\n  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;\n}\n\n/**\n * Counts the number of vertices in a simple flat array, closes the polygon if needed.\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [startIndex] - start index of the path in the positions array\n * @param {Number} [endIndex] - end index of the path in the positions array\n * @returns {Number} vertex count\n */\nfunction getFlatVertexCount(positions, size, startIndex = 0, endIndex) {\n  endIndex = endIndex || positions.length;\n  if (startIndex >= endIndex) {\n    return 0;\n  }\n  return (\n    (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) +\n    (endIndex - startIndex) / size\n  );\n}\n\n/**\n * Counts the number of vertices in any polygon representation.\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} vertex count\n */\nexport function getVertexCount(polygon, positionSize, normalization = true) {\n  if (!normalization) {\n    polygon = polygon.positions || polygon;\n    return polygon.length / positionSize;\n  }\n\n  validate(polygon);\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions, holeIndices} = polygon;\n\n    if (holeIndices) {\n      let vertexCount = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= holeIndices.length; i++) {\n        vertexCount += getFlatVertexCount(\n          polygon.positions,\n          positionSize,\n          holeIndices[i - 1],\n          holeIndices[i]\n        );\n      }\n      return vertexCount;\n    }\n    polygon = positions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    return getFlatVertexCount(polygon, positionSize);\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let vertexCount = 0;\n    for (const simplePolygon of polygon) {\n      vertexCount += getNestedVertexCount(simplePolygon);\n    }\n    return vertexCount;\n  }\n  // simple polygon\n  return getNestedVertexCount(polygon);\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [vertexCount] - pre-computed vertex count in the polygon.\n *   If provided, will skip counting.\n * @return {Object} - {positions: <Float64Array>, holeIndices: <Array|null>}\n */\n/* eslint-disable max-statements */\nexport function normalize(polygon, positionSize, vertexCount) {\n  validate(polygon);\n\n  vertexCount = vertexCount || getVertexCount(polygon, positionSize);\n\n  const positions = new Float64Array(vertexCount * positionSize);\n  const holeIndices = [];\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i]\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const simplePolygon of polygon) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize);\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Get vertex indices for drawing polygon mesh\n * @param {Object} normalizedPolygon - {positions, holeIndices}\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Array} array of indices\n */\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  let holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n  let positions = normalizedPolygon.positions || normalizedPolygon;\n\n  // TODO - handle other coordinate systems and projection modes\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the Web Mercator plane for accuracy\n    const n = positions.length;\n    // Clone the array\n    positions = positions.slice();\n    for (let i = 0; i < n; i += positionSize) {\n      // project points to a scaled version of the web-mercator plane\n      // It doesn't matter if x and y are scaled/translated, but the relationship must be linear\n      const y = positions[i + 1];\n      positions[i + 1] = Math.log(Math.tan(PI_4 + y * DEGREES_TO_RADIANS_HALF));\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\n// @ts-nocheck\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst BASIS_CDN_ENCODER_WASM = `https://unpkg.com/@loaders.gl/textures@${VERSION}/dist/libs/basis_encoder.wasm`;\nconst BASIS_CDN_ENCODER_JS = `https://unpkg.com/@loaders.gl/textures@${VERSION}/dist/libs/basis_encoder.js`;\n\nlet loadBasisTranscoderPromise;\n\n/**\n * Loads wasm transcoder module\n * @param options\n * @returns {BasisFile} promise\n */\nexport async function loadBasisTrascoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basis) {\n    return modules.basis;\n  }\n\n  loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);\n  return await loadBasisTranscoderPromise;\n}\n\n/**\n * Loads wasm transcoder module\n * @param options\n * @returns {BasisFile} promise\n */\nasync function loadBasisTrascoder(options) {\n  let BASIS = null;\n  let wasmBinary = null;\n\n  [BASIS, wasmBinary] = await Promise.all([\n    await loadLibrary('basis_transcoder.js', 'textures', options),\n    await loadLibrary('basis_transcoder.wasm', 'textures', options)\n  ]);\n\n  // Depends on how import happened...\n  // @ts-ignore TS2339: Property does not exist on type\n  BASIS = BASIS || globalThis.BASIS;\n  return await initializeBasisTrascoderModule(BASIS, wasmBinary);\n}\n\n/**\n * Initialize wasm transcoder module\n * @param BasisModule - js part of the module\n * @param wasmBinary - wasm part of the module\n * @returns {BasisFile} promise\n */\nfunction initializeBasisTrascoderModule(BasisModule, wasmBinary) {\n  const options: {wasmBinary?} = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    // if you try to return BasisModule the browser crashes!\n    BasisModule(options).then((module) => {\n      const {BasisFile, initializeBasis} = module;\n      initializeBasis();\n      resolve({BasisFile});\n    });\n  });\n}\n\nlet loadBasisEncoderPromise;\n\n/**\n * Loads wasm encoder module\n * @param options\n * @returns {BasisFile, KTX2File} promise\n */\nexport async function loadBasisEncoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basisEncoder) {\n    return modules.basisEncoder;\n  }\n\n  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);\n  return await loadBasisEncoderPromise;\n}\n\n/**\n * Loads wasm encoder module\n * @param options\n * @returns {BasisFile, KTX2File} promise\n */\nasync function loadBasisEncoder(options) {\n  let BASIS_ENCODER = null;\n  let wasmBinary = null;\n\n  [BASIS_ENCODER, wasmBinary] = await Promise.all([\n    await loadLibrary(BASIS_CDN_ENCODER_JS, 'textures', options),\n    await loadLibrary(BASIS_CDN_ENCODER_WASM, 'textures', options)\n  ]);\n\n  // Depends on how import happened...\n  // @ts-ignore TS2339: Property does not exist on type\n  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;\n  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);\n}\n\n/**\n * Initialize wasm transcoder module\n * @param BasisEncoderModule - js part of the module\n * @param wasmBinary - wasm part of the module\n * @returns {BasisFile, KTX2File} promise\n */\nfunction initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {\n  const options: {wasmBinary?} = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    // if you try to return BasisModule the browser crashes!\n    BasisEncoderModule(options).then((module) => {\n      const {BasisFile, KTX2File, initializeBasis, BasisEncoder} = module;\n      initializeBasis();\n      resolve({BasisFile, KTX2File, BasisEncoder});\n    });\n  });\n}\n", "/* eslint-disable camelcase */\nexport const GL_EXTENSIONS_CONSTANTS = {\n  // WEBGL_compressed_texture_s3tc\n\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,\n\n  // WEBGL_compressed_texture_es3\n\n  COMPRESSED_R11_EAC: 0x9270,\n  COMPRESSED_SIGNED_R11_EAC: 0x9271,\n  COMPRESSED_RG11_EAC: 0x9272,\n  COMPRESSED_SIGNED_RG11_EAC: 0x9273,\n  COMPRESSED_RGB8_ETC2: 0x9274,\n  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,\n  COMPRESSED_SRGB8_ETC2: 0x9276,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,\n\n  // WEBGL_compressed_texture_pvrtc\n\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,\n\n  // WEBGL_compressed_texture_etc1\n\n  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,\n\n  // WEBGL_compressed_texture_atc\n\n  COMPRESSED_RGB_ATC_WEBGL: 0x8c92,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8c93,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87ee,\n\n  // WEBGL_compressed_texture_astc\n\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 0x93b0,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 0x93b1,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 0x93b2,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 0x93b3,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 0x93b4,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 0x93b5,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 0x93b6,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 0x93b7,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 0x93b8,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 0x93b9,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 0x93ba,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 0x93bb,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 0x93bc,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 0x93bd,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 0x93d0,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 0x93d1,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 0x93d2,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 0x93d3,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 0x93d4,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 0x93d5,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 0x93d6,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 0x93d7,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 0x93d8,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 0x93d9,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 0x93da,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 0x93db,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 0x93dc,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 0x93dd,\n\n  // EXT_texture_compression_rgtc\n\n  COMPRESSED_RED_RGTC1_EXT: 0x8dbb,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8dbc,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8dbd,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8dbe,\n\n  // WEBGL_compressed_texture_s3tc_srgb\n\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8c4c,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8c4d,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8c4e,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8c4f\n};\n", "import type {GPUTextureFormat} from '@loaders.gl/schema';\n\nconst BROWSER_PREFIXES = ['', 'WEBKIT_', 'MOZ_'];\n\nconst WEBGL_EXTENSIONS: {[key: string]: GPUTextureFormat} = {\n  /* eslint-disable camelcase */\n  WEBGL_compressed_texture_s3tc: 'dxt',\n  WEBGL_compressed_texture_s3tc_srgb: 'dxt-srgb',\n  WEBGL_compressed_texture_etc1: 'etc1',\n  WEBGL_compressed_texture_etc: 'etc2',\n  WEBGL_compressed_texture_pvrtc: 'pvrtc',\n  WEBGL_compressed_texture_atc: 'atc',\n  WEBGL_compressed_texture_astc: 'astc',\n  EXT_texture_compression_rgtc: 'rgtc'\n  /* eslint-enable camelcase */\n};\n\nlet formats: Set<GPUTextureFormat> | null = null;\n\n/**\n * Returns a list of formats.\n * Creates a temporary WebGLRenderingContext if none is provided.\n *\n * @param gl - Optional context.\n */\nexport function getSupportedGPUTextureFormats(gl?: WebGLRenderingContext): Set<string> {\n  if (!formats) {\n    gl = gl || getWebGLContext() || undefined;\n\n    formats = new Set<GPUTextureFormat>();\n\n    for (const prefix of BROWSER_PREFIXES) {\n      for (const extension in WEBGL_EXTENSIONS) {\n        if (gl && gl.getExtension(`${prefix}${extension}`)) {\n          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];\n          formats.add(gpuTextureFormat);\n        }\n      }\n    }\n  }\n\n  return formats;\n}\n\n/**\n * @returns {WebGLRenderingContext?}\n */\nfunction getWebGLContext() {\n  try {\n    const canvas = document.createElement('canvas');\n    return canvas.getContext('webgl');\n  } catch (error) {\n    return null;\n  }\n}\n", "///////////////////////////////////////////////////\n// Common.\n///////////////////////////////////////////////////\n\n// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\nexport const KTX_WRITER = `KTX-Parse v${PACKAGE_VERSION}`;\n\nexport const NUL = new Uint8Array([0x00]);\n\n\n///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\n\nexport const KTX2_ID = [\n\t// '´', 'K', 'T', 'X', '2', '0', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n\t0xAB, 0x4B, 0x54, 0x58, 0x20, 0x32, 0x30, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n];\n\nexport const HEADER_BYTE_LENGTH = 68; // 13 * 4 + 2 * 8\n\nexport enum KTX2SupercompressionScheme {\n\tNONE = 0,\n\tBASISLZ = 1,\n\tZSTD = 2,\n\tZLIB = 3,\n};\n\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport enum KTX2DataFormatType {\n    BASICFORMAT = 0x00,\n};\n\nexport const KHR_DF_VENDORID_KHRONOS = 0;\n\nexport const KHR_DF_VERSION = 2;\n\nexport const KHR_DF_BLOCKSIZE = 40;\n\nexport const VK_FORMAT_UNDEFINED = 0;\n\nexport enum KTX2DataFormatModel {\n    UNSPECIFIED = 0,\n\tETC1S = 163,\n\tUASTC = 166,\n};\n\nexport enum KTX2DataFormatPrimaries {\n    UNSPECIFIED = 0,\n    SRGB = 1,\n};\n\nexport enum KTX2DataFormatTransfer {\n    UNSPECIFIED = 0,\n    LINEAR = 1,\n    SRGB = 2,\n    ITU = 3,\n    NTSC = 4,\n    SLOG = 5,\n    SLOG2 = 6,\n};\n\nexport enum KTX2DataFormatFlags {\n    ALPHA_STRAIGHT = 0,\n    ALPHA_PREMULTIPLIED = 1,\n};\n\nexport enum KTX2DataFormatChannelETC1S {\n    RGB = 0,\n    RRR = 3,\n    GGG = 4,\n    AAA = 15,\n};\n\nexport enum KTX2DataFormatChannelUASTC {\n    RGB = 0,\n    RGBA = 3,\n    RRR = 4,\n    RRRG = 5,\n};\n", "import { KHR_DF_BLOCKSIZE, KHR_DF_VENDORID_KHRONOS, KHR_DF_VERSION, KTX2DataFormatFlags, KTX2DataFormatModel, KTX2DataFormatPrimaries, KTX2DataFormatType, KTX2SupercompressionScheme, VK_FORMAT_UNDEFINED } from './constants';\n\n/**\n * Represents an unpacked KTX 2.0 texture container. Data for individual mip levels are stored in\n * the `.levels` array, typically compressed in Basis Universal formats. Additional properties\n * provide metadata required to process, transcode, and upload these textures.\n */\nexport class KTX2Container {\n\t/**\n\t * Specifies the image format using Vulkan VkFormat enum values. When using Basis Universal\n\t * texture formats, `vkFormat` must be VK_FORMAT_UNDEFINED.\n\t */\n\tpublic vkFormat = VK_FORMAT_UNDEFINED;\n\n\t/**\n\t * Size of the data type in bytes used to upload the data to a graphics API. When `vkFormat` is\n\t * VK_FORMAT_UNDEFINED, `typeSize` must be 1.\n\t */\n\tpublic typeSize: number = 1;\n\n\t/** Width of the texture image for level 0, in pixels. */\n\tpublic pixelWidth: number = 0;\n\n\t/** Height of the texture image for level 0, in pixels. */\n\tpublic pixelHeight: number = 0;\n\n\t/** Depth of the texture image for level 0, in pixels (3D textures only). */\n\tpublic pixelDepth: number = 0;\n\n\t/** Number of array elements (array textures only). */\n\tpublic layerCount: number = 0;\n\n\t/**\n\t * Number of cubemap faces. For cubemaps and cubemap arrays, `faceCount` must be 6. For all\n\t * other textures, `faceCount` must be 1. Cubemap faces are stored in +X, -X, +Y, -Y, +Z, -Z\n\t * order.\n\t */\n\tpublic faceCount: number = 1;\n\n\t/** Indicates which supercompression scheme has been applied to mip level images, if any. */\n\tpublic supercompressionScheme = KTX2SupercompressionScheme.NONE;\n\n\t/** Mip levels, ordered largest (original) to smallest (~1px). */\n\tpublic levels: KTX2Level[] = [];\n\n\t/** Data Format Descriptor. */\n\tpublic dataFormatDescriptor: KTX2DataFormatDescriptorBasicFormat[] = [{\n\t\tvendorId: KHR_DF_VENDORID_KHRONOS,\n\t\tdescriptorType: KTX2DataFormatType.BASICFORMAT,\n\t\tversionNumber: KHR_DF_VERSION,\n\t\tdescriptorBlockSize: KHR_DF_BLOCKSIZE,\n\t\tcolorModel: KTX2DataFormatModel.UNSPECIFIED,\n\t\tcolorPrimaries: KTX2DataFormatPrimaries.SRGB,\n\t\ttransferFunction: KTX2DataFormatPrimaries.SRGB,\n\t\tflags: KTX2DataFormatFlags.ALPHA_STRAIGHT,\n\t\ttexelBlockDimension: {x: 4, y: 4, z: 1, w: 1},\n\t\tbytesPlane: [],\n\t\tsamples: [],\n\t}];\n\n\t/** Key/Value Data. */\n\tpublic keyValue: {[key: string]: string | Uint8Array} = {};\n\n\t/** Supercompression Global Data. */\n\tpublic globalData: KTX2GlobalDataBasisLZ | null = null;\n}\n\n\n///////////////////////////////////////////////////\n// Mip Levels.\n///////////////////////////////////////////////////\n\nexport interface KTX2Level {\n\t/** Compressed data of the mip level. */\n\tlevelData: Uint8Array;\n\n\t/**\n\t * Size of the mip level after reflation from supercompression, if applicable. When\n\t * `supercompressionType` is BASISLZ, `uncompressedByteLength` must be 0. When\n\t * `supercompressionType` is `NONE`, `uncompressedByteLength` must match the `levelData` byte\n\t * length.\n\t *\n\t * _**NOTICE:** this implies that for formats such as UASTC, `uncompressedByteLength` may\n\t * indicate size after ZSTD reflation (and of transcoded ASTC data), but does _not_ indicate\n\t * size of decoded RGBA32 pixels._\n\t */\n\tuncompressedByteLength: number;\n};\n\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport interface KTX2DataFormatDescriptorBasicFormat {\n\tvendorId: number;\n\tdescriptorType: number;\n\tversionNumber: number;\n\tdescriptorBlockSize: number;\n\tcolorModel: number;\n\tcolorPrimaries: number;\n\ttransferFunction: number;\n\tflags: number;\n\ttexelBlockDimension: KTX2BasicFormatTexelBlockDimensions;\n\tbytesPlane: number[];\n\tsamples: KTX2BasicFormatSample[],\n};\n\nexport interface KTX2BasicFormatTexelBlockDimensions {\n\tx: number;\n\ty: number;\n\tz: number;\n\tw: number;\n};\n\nexport interface KTX2BasicFormatSample {\n\tbitOffset: number;\n\tbitLength: number;\n\tchannelID: number;\n\tsamplePosition: number[];\n\tsampleLower: number;\n\tsampleUpper: number;\n};\n\n\n///////////////////////////////////////////////////\n// Supercompression Global Data.\n///////////////////////////////////////////////////\n\nexport interface KTX2GlobalDataBasisLZ {\n\tendpointCount: number;\n\tselectorCount: number;\n\timageDescs: KTX2GlobalDataBasisLZImageDesc[];\n\tendpointsData: Uint8Array;\n\tselectorsData: Uint8Array;\n\ttablesData: Uint8Array;\n\textendedData: Uint8Array;\n};\n\ninterface KTX2GlobalDataBasisLZImageDesc {\n\timageFlags: number;\n\trgbSliceByteOffset: number;\n\trgbSliceByteLength: number;\n\talphaSliceByteOffset: number;\n\talphaSliceByteLength: number;\n};\n", "export class BufferReader {\n\tprivate _dataView: DataView;\n\tprivate _littleEndian: boolean;\n\tpublic _offset: number;\n\n\tconstructor(data: Uint8Array, byteOffset: number, byteLength: number, littleEndian: boolean) {\n\t\tthis._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);\n\t\tthis._littleEndian = littleEndian;\n\t\tthis._offset = 0;\n\t}\n\n\t_nextUint8() {\n\t\tconst value = this._dataView.getUint8(this._offset);\n\t\tthis._offset += 1;\n\t\treturn value;\n\t}\n\n\t_nextUint16() {\n\t\tconst value = this._dataView.getUint16(this._offset, this._littleEndian);\n\t\tthis._offset += 2;\n\t\treturn value;\n\t}\n\n\t_nextUint32() {\n\t\tconst value = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tthis._offset += 4;\n\t\treturn value;\n\t}\n\n\t_nextUint64() {\n\t\tconst left = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tconst right = this._dataView.getUint32(this._offset + 4, this._littleEndian);\n\t\t// TODO(cleanup): Just test this...\n\t\t// const value = this._littleEndian ? left + (2 ** 32 * right) : (2 ** 32 * left) + right;\n\t\tconst value = left + (2 ** 32 * right);\n\t\tthis._offset += 8;\n\t\treturn value;\n\t}\n\n\t_skip(bytes: number) {\n\t\tthis._offset += bytes;\n\t\treturn this;\n\t}\n\n\t_scan(maxByteLength: number, term: number = 0x00): Uint8Array {\n\t\tconst byteOffset = this._offset;\n\t\tlet byteLength = 0;\n\t\twhile (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {\n\t\t\tbyteLength++;\n\t\t\tthis._offset++;\n\t\t}\n\n\t\tif (byteLength < maxByteLength) this._offset++;\n\n\t\treturn new Uint8Array(\n\t\t\tthis._dataView.buffer,\n\t\t\tthis._dataView.byteOffset + byteOffset,\n\t\t\tbyteLength\n\t\t);\n\t}\n}\n", "\n/** Encodes text to an ArrayBuffer. */\nexport function encodeText(text: string): Uint8Array {\n\tif (typeof TextEncoder !== 'undefined') {\n\t\treturn new TextEncoder().encode(text);\n\t}\n\treturn Buffer.from(text);\n}\n\n/** Decodes an ArrayBuffer to text. */\nexport function decodeText(buffer: Uint8Array): string {\n\tif (typeof TextDecoder !== 'undefined') {\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\treturn Buffer.from(buffer).toString('utf8');\n}\n\n/** Concatenates N ArrayBuffers. */\nexport function concat (buffers: (ArrayBuffer | Uint8Array)[]): Uint8Array {\n\tlet totalByteLength = 0;\n\tfor (const buffer of buffers) {\n\t\ttotalByteLength += buffer.byteLength;\n\t}\n\n\tconst result = new Uint8Array(totalByteLength);\n\tlet byteOffset = 0;\n\n\tfor (const buffer of buffers) {\n\t\tresult.set(new Uint8Array(buffer), byteOffset);\n\t\tbyteOffset += buffer.byteLength;\n\t}\n\n\treturn result;\n}", "import { BufferReader } from './buffer-reader';\nimport { KTX2_ID } from './constants';\nimport { KTX2Container, KTX2DataFormatDescriptorBasicFormat } from './container';\nimport { decodeText } from './util';\n\n/**\n * Parses a KTX 2.0 file, returning an unpacked {@link KTX2Container} instance with all associated\n * data. The container's mip levels and other binary data are pointers into the original file, not\n * copies, so the original file should not be overwritten after reading.\n *\n * @param data Bytes of KTX 2.0 file, as Uint8Array or Buffer.\n */\nexport function read(data: Uint8Array): KTX2Container {\n\n\t///////////////////////////////////////////////////\n\t// KTX 2.0 Identifier.\n\t///////////////////////////////////////////////////\n\n\tconst id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);\n\tif (id[0] !== KTX2_ID[0] || // '´'\n\t\tid[1] !== KTX2_ID[1] || // 'K'\n\t\tid[2] !== KTX2_ID[2] || // 'T'\n\t\tid[3] !== KTX2_ID[3] || // 'X'\n\t\tid[4] !== KTX2_ID[4] || // ' '\n\t\tid[5] !== KTX2_ID[5] || // '2'\n\t\tid[6] !== KTX2_ID[6] || // '0'\n\t\tid[7] !== KTX2_ID[7] || // 'ª'\n\t\tid[8] !== KTX2_ID[8] || // '\\r'\n\t\tid[9] !== KTX2_ID[9] || // '\\n'\n\t\tid[10] !== KTX2_ID[10] || // '\\x1A'\n\t\tid[11] !== KTX2_ID[11] // '\\n'\n\t) {\n\t\tthrow new Error('Missing KTX 2.0 identifier.');\n\t}\n\n\tconst container = new KTX2Container();\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;\n\tconst headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);\n\n\tcontainer.vkFormat = headerReader._nextUint32();\n\tcontainer.typeSize = headerReader._nextUint32();\n\tcontainer.pixelWidth = headerReader._nextUint32();\n\tcontainer.pixelHeight = headerReader._nextUint32();\n\tcontainer.pixelDepth = headerReader._nextUint32();\n\tcontainer.layerCount = headerReader._nextUint32();\n\tcontainer.faceCount = headerReader._nextUint32();\n\n\tconst levelCount = headerReader._nextUint32();\n\n\tcontainer.supercompressionScheme = headerReader._nextUint32();\n\n\tconst dfdByteOffset = headerReader._nextUint32();\n\tconst dfdByteLength = headerReader._nextUint32();\n\tconst kvdByteOffset = headerReader._nextUint32();\n\tconst kvdByteLength = headerReader._nextUint32();\n\tconst sgdByteOffset = headerReader._nextUint64();\n\tconst sgdByteLength = headerReader._nextUint64();\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelByteLength = levelCount * 3 * 8;\n\tconst levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);\n\n\tfor (let i = 0; i < levelCount; i ++) {\n\t\tcontainer.levels.push({\n\t\t\tlevelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),\n\t\t\tuncompressedByteLength: levelReader._nextUint64(),\n\t\t});\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);\n\n\tconst dfd: KTX2DataFormatDescriptorBasicFormat = {\n\t\tvendorId: dfdReader._skip(4 /* totalSize */)._nextUint16(),\n\t\tdescriptorType: dfdReader._nextUint16(),\n\t\tversionNumber: dfdReader._nextUint16(),\n\t\tdescriptorBlockSize: dfdReader._nextUint16(),\n\t\tcolorModel: dfdReader._nextUint8(),\n\t\tcolorPrimaries: dfdReader._nextUint8(),\n\t\ttransferFunction: dfdReader._nextUint8(),\n\t\tflags: dfdReader._nextUint8(),\n\t\ttexelBlockDimension: {\n\t\t\tx: dfdReader._nextUint8() + 1,\n\t\t\ty: dfdReader._nextUint8() + 1,\n\t\t\tz: dfdReader._nextUint8() + 1,\n\t\t\tw: dfdReader._nextUint8() + 1,\n\t\t},\n\t\tbytesPlane: [\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t],\n\t\tsamples: [],\n\t};\n\n\tconst sampleStart = 6;\n\tconst sampleWords = 4;\n\tconst numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;\n\n\tfor (let i = 0; i < numSamples; i ++) {\n\t\tdfd.samples[ i ] = {\n\t\t\tbitOffset: dfdReader._nextUint16(),\n\t\t\tbitLength: dfdReader._nextUint8(),\n\t\t\tchannelID: dfdReader._nextUint8(),\n\t\t\tsamplePosition: [\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t],\n\t\t\tsampleLower: dfdReader._nextUint32(),\n\t\t\tsampleUpper: dfdReader._nextUint32(),\n\t\t};\n\t}\n\n\tcontainer.dataFormatDescriptor.length = 0;\n\tcontainer.dataFormatDescriptor.push(dfd);\n\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);\n\n\twhile (kvdReader._offset < kvdByteLength) {\n\t\tconst keyValueByteLength = kvdReader._nextUint32();\n\t\tconst keyData = kvdReader._scan(keyValueByteLength);\n\t\tconst key = decodeText(keyData);\n\t\tconst valueData = kvdReader._scan(keyValueByteLength - keyData.byteLength);\n\t\tcontainer.keyValue[key] = key.match(/^ktx/i) ? decodeText(valueData) : valueData;\n\n\t\t// 4-byte alignment.\n\t\tif (keyValueByteLength % 4) kvdReader._skip(4 - (keyValueByteLength % 4));\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tif (sgdByteLength <= 0) return container;\n\n\tconst sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);\n\n\tconst endpointCount = sgdReader._nextUint16();\n\tconst selectorCount = sgdReader._nextUint16();\n\tconst endpointsByteLength = sgdReader._nextUint32();\n\tconst selectorsByteLength = sgdReader._nextUint32();\n\tconst tablesByteLength = sgdReader._nextUint32();\n\tconst extendedByteLength = sgdReader._nextUint32();\n\n\tconst imageDescs = [];\n\tfor (let i = 0; i < levelCount; i ++) {\n\t\timageDescs.push({\n\t\t\timageFlags: sgdReader._nextUint32(),\n\t\t\trgbSliceByteOffset: sgdReader._nextUint32(),\n\t\t\trgbSliceByteLength: sgdReader._nextUint32(),\n\t\t\talphaSliceByteOffset: sgdReader._nextUint32(),\n\t\t\talphaSliceByteLength: sgdReader._nextUint32(),\n\t\t});\n\t}\n\n\tconst endpointsByteOffset = sgdByteOffset + sgdReader._offset;\n\tconst selectorsByteOffset = endpointsByteOffset + endpointsByteLength;\n\tconst tablesByteOffset = selectorsByteOffset + selectorsByteLength;\n\tconst extendedByteOffset = tablesByteOffset + tablesByteLength;\n\n\tconst endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);\n\tconst selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);\n\tconst tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);\n\tconst extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);\n\n\tcontainer.globalData = {\n\t\tendpointCount,\n\t\tselectorCount,\n\t\timageDescs,\n\t\tendpointsData,\n\t\tselectorsData,\n\t\ttablesData,\n\t\textendedData,\n\t};\n\n\treturn container;\n}\n", "import { HEADER_BYTE_LENGTH, KTX2DataFormatType, KTX2_ID, KTX_WRITER, NUL } from './constants';\nimport { KTX2Container } from './container';\nimport { concat, encodeText } from './util';\n\ninterface WriteOptions {keepWriter?: boolean};\nconst DEFAULT_OPTIONS: WriteOptions = {keepWriter: false};\n\n/**\n * Serializes a {@link KTX2Container} instance to a KTX 2.0 file. Mip levels and other binary data\n * are copied into the resulting Uint8Array, so the original container can safely be edited or\n * destroyed after it is serialized.\n *\n * Options:\n * - keepWriter: If true, 'KTXWriter' key/value field is written as provided by the container.\n * \t\tOtherwise, a string for the current ktx-parse version is generated. Default: false.\n *\n * @param container\n * @param options\n */\nexport function write(container: KTX2Container, options: WriteOptions = {}): Uint8Array {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tlet sgdBuffer = new ArrayBuffer(0);\n\tif (container.globalData) {\n\t\tconst sgdHeaderBuffer = new ArrayBuffer(20 + container.globalData.imageDescs.length * 5 * 4);\n\t\tconst sgdHeaderView = new DataView(sgdHeaderBuffer);\n\t\tsgdHeaderView.setUint16(0, container.globalData.endpointCount, true);\n\t\tsgdHeaderView.setUint16(2, container.globalData.selectorCount, true);\n\t\tsgdHeaderView.setUint32(4, container.globalData.endpointsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(8, container.globalData.selectorsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(12, container.globalData.tablesData.byteLength, true);\n\t\tsgdHeaderView.setUint32(16, container.globalData.extendedData.byteLength, true);\n\n\t\tfor (let i = 0; i < container.globalData.imageDescs.length; i++) {\n\t\t\tconst imageDesc = container.globalData.imageDescs[i];\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 0, imageDesc.imageFlags, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 4, imageDesc.rgbSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 8, imageDesc.rgbSliceByteLength, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 12, imageDesc.alphaSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 16, imageDesc.alphaSliceByteLength, true);\n\t\t}\n\n\t\tsgdBuffer = concat([\n\t\t\tsgdHeaderBuffer,\n\t\t\tcontainer.globalData.endpointsData,\n\t\t\tcontainer.globalData.selectorsData,\n\t\t\tcontainer.globalData.tablesData,\n\t\t\tcontainer.globalData.extendedData,\n\t\t]);\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst keyValueData: Uint8Array[] = [];\n\tlet keyValue = container.keyValue;\n\n\tif (!options.keepWriter) {\n\t\tkeyValue = {...container.keyValue, 'KTXwriter': KTX_WRITER};\n\t}\n\n\tfor (const key in keyValue) {\n\t\tconst value = keyValue[key];\n\t\tconst keyData = encodeText(key);\n\t\tconst valueData = typeof value === 'string' ? encodeText(value) : value;\n\t\tconst kvByteLength = keyData.byteLength + 1 + valueData.byteLength + 1;\n\t\tconst kvPadding = kvByteLength % 4 ? (4 - (kvByteLength % 4)) : 0; // align(4)\n\t\tkeyValueData.push(concat([\n\t\t\tnew Uint32Array([kvByteLength]),\n\t\t\tkeyData,\n\t\t\tNUL,\n\t\t\tvalueData,\n\t\t\tNUL,\n\t\t\tnew Uint8Array(kvPadding).fill(0x00), // align(4)\n\t\t]));\n\t}\n\n\tconst kvdBuffer = concat(keyValueData);\n\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdBuffer = new ArrayBuffer(44);\n\tconst dfdView = new DataView(dfdBuffer);\n\n\tif (container.dataFormatDescriptor.length !== 1\n\t\t\t|| container.dataFormatDescriptor[0].descriptorType !== KTX2DataFormatType.BASICFORMAT) {\n\t\tthrow new Error('Only BASICFORMAT Data Format Descriptor output supported.');\n\t}\n\n\tconst dfd = container.dataFormatDescriptor[0];\n\n\tdfdView.setUint32(0, 44, true);\n\tdfdView.setUint16(4, dfd.vendorId, true);\n\tdfdView.setUint16(6, dfd.descriptorType, true);\n\tdfdView.setUint16(8, dfd.versionNumber, true);\n\tdfdView.setUint16(10, dfd.descriptorBlockSize, true);\n\n\tdfdView.setUint8(12, dfd.colorModel);\n\tdfdView.setUint8(13, dfd.colorPrimaries);\n\tdfdView.setUint8(14, dfd.transferFunction);\n\tdfdView.setUint8(15, dfd.flags);\n\n\tdfdView.setUint8(16, dfd.texelBlockDimension.x - 1);\n\tdfdView.setUint8(17, dfd.texelBlockDimension.y - 1);\n\tdfdView.setUint8(18, dfd.texelBlockDimension.z - 1);\n\tdfdView.setUint8(19, dfd.texelBlockDimension.w - 1);\n\n\tfor (let i = 0; i < 8; i++) dfdView.setUint8(20 + i, dfd.bytesPlane[i]);\n\n\tfor (let i = 0; i < dfd.samples.length; i++) {\n\t\tconst sample = dfd.samples[i];\n\t\tconst sampleByteOffset = 28 + i * 16;\n\n\t\tdfdView.setUint16(sampleByteOffset + 0, sample.bitOffset, true);\n\t\tdfdView.setUint8(sampleByteOffset + 2, sample.bitLength);\n\t\tdfdView.setUint8(sampleByteOffset + 3, sample.channelID);\n\n\t\tdfdView.setUint8(sampleByteOffset + 4, sample.samplePosition[0]);\n\t\tdfdView.setUint8(sampleByteOffset + 5, sample.samplePosition[1]);\n\t\tdfdView.setUint8(sampleByteOffset + 6, sample.samplePosition[2]);\n\t\tdfdView.setUint8(sampleByteOffset + 7, sample.samplePosition[3]);\n\n\t\tdfdView.setUint32(sampleByteOffset + 8, sample.sampleLower, true);\n\t\tdfdView.setUint32(sampleByteOffset + 12, sample.sampleUpper, true);\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Data alignment.\n\t///////////////////////////////////////////////////\n\n\tconst dfdByteOffset = KTX2_ID.length + HEADER_BYTE_LENGTH + container.levels.length * 3 * 8;\n\tconst kvdByteOffset = dfdByteOffset + dfdBuffer.byteLength;\n\tlet sgdByteOffset = kvdByteOffset + kvdBuffer.byteLength;\n\tif (sgdByteOffset % 8) sgdByteOffset += 8 - (sgdByteOffset % 8); // align(8)\n\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelData: Uint8Array[] = [];\n\tconst levelIndex = new DataView(new ArrayBuffer(container.levels.length * 3 * 8));\n\n\tlet levelDataByteOffset = sgdByteOffset + sgdBuffer.byteLength;\n\tfor (let i = 0; i < container.levels.length; i++) {\n\t\tconst level = container.levels[i];\n\t\tlevelData.push(level.levelData);\n\t\tlevelIndex.setBigUint64(i * 24 + 0, BigInt(levelDataByteOffset), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 8, BigInt(level.levelData.byteLength), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 16, BigInt(level.uncompressedByteLength), true);\n\t\tlevelDataByteOffset += level.levelData.byteLength;\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerBuffer = new ArrayBuffer(HEADER_BYTE_LENGTH);\n\tconst headerView = new DataView(headerBuffer);\n\theaderView.setUint32(0, container.vkFormat, true);\n\theaderView.setUint32(4, container.typeSize, true);\n\theaderView.setUint32(8, container.pixelWidth, true);\n\theaderView.setUint32(12, container.pixelHeight, true);\n\theaderView.setUint32(16, container.pixelDepth, true);\n\theaderView.setUint32(20, container.layerCount, true);\n\theaderView.setUint32(24, container.faceCount, true);\n\theaderView.setUint32(28, container.levels.length, true);\n\theaderView.setUint32(32, container.supercompressionScheme, true);\n\n\theaderView.setUint32(36, dfdByteOffset, true);\n\theaderView.setUint32(40, dfdBuffer.byteLength, true);\n\theaderView.setUint32(44, kvdByteOffset, true);\n\theaderView.setUint32(48, kvdBuffer.byteLength, true);\n\theaderView.setBigUint64(52, BigInt(sgdByteOffset), true);\n\theaderView.setBigUint64(60, BigInt(sgdBuffer.byteLength), true);\n\n\n\t///////////////////////////////////////////////////\n\t// Compose.\n\t///////////////////////////////////////////////////\n\n\treturn new Uint8Array(concat([\n\t\tnew Uint8Array(KTX2_ID).buffer,\n\t\theaderBuffer,\n\t\tlevelIndex.buffer,\n\t\tdfdBuffer,\n\t\tkvdBuffer,\n\t\tnew ArrayBuffer(sgdByteOffset - (kvdByteOffset + kvdBuffer.byteLength)), // align(8)\n\t\tsgdBuffer,\n\t\t...levelData,\n\t]));\n}\n\n", "import type {TextureLevel} from '@loaders.gl/schema';\n\nexport type CompressedTextureExtractOptions = {\n  mipMapLevels: number;\n  width: number;\n  height: number;\n  sizeFunction: Function;\n  internalFormat: number;\n};\n\n/**\n * Extract mipmap images from compressed texture buffer\n * @param data - binary data of compressed texture or Array of level objects\n * @param options.mipMapLevels - number of mipmap level inside image\n * @param options.width - width of 0 - level\n * @param options.height - height of 0 - level\n * @param options.sizeFunction - format-related function to calculate level size in bytes\n * @param options.internalFormat - WebGL compatible format code\n * @returns Array of the texture levels\n */\nexport function extractMipmapImages(\n  data: Uint8Array | object[],\n  options: CompressedTextureExtractOptions\n): TextureLevel[] {\n  const images = new Array(options.mipMapLevels);\n\n  let levelWidth = options.width;\n  let levelHeight = options.height;\n  let offset = 0;\n\n  for (let i = 0; i < options.mipMapLevels; ++i) {\n    // @ts-expect-error\n    const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i);\n    // @ts-expect-error\n    const levelData = getLevelData(data, i, offset, levelSize);\n\n    images[i] = {\n      compressed: true,\n      format: options.internalFormat,\n      data: levelData,\n      width: levelWidth,\n      height: levelHeight,\n      levelSize\n    };\n\n    levelWidth = Math.max(1, levelWidth >> 1);\n    levelHeight = Math.max(1, levelHeight >> 1);\n\n    offset += levelSize;\n  }\n  return images;\n}\n\nfunction getLevelData(\n  data: Uint8Array,\n  index: number,\n  offset: number,\n  levelSize: number\n): Uint8Array {\n  if (!Array.isArray(data)) {\n    return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);\n  }\n\n  return data[index].levelData;\n}\n\nfunction getLevelSize(\n  options: CompressedTextureExtractOptions,\n  levelWidth: number,\n  levelHeight: number,\n  data: Uint8Array[] | object[],\n  index: number\n): number {\n  if (!Array.isArray(data)) {\n    return options.sizeFunction(levelWidth, levelHeight);\n  }\n  return options.sizeFunction(data[index]);\n}\n", "import {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\n\nconst VULKAN_TO_WEBGL_FORMAT_MAP: Record<number, number> = {\n  131: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n  132: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_S3TC_DXT1_EXT,\n  133: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  134: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n  135: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  136: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n  137: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  138: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n  139: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_RGTC1_EXT,\n  140: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n  141: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_GREEN_RGTC2_EXT,\n  142: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n  147: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2,\n  148: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ETC2,\n  149: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n  150: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n  151: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC,\n  152: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n  153: GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC,\n  154: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_R11_EAC,\n  155: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC,\n  156: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RG11_EAC,\n  // @ts-ignore\n  157: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n  // @ts-ignore\n  158: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n  // @ts-ignore\n  159: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,\n  // @ts-ignore\n  160: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,\n  // @ts-ignore\n  161: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,\n  // @ts-ignore\n  162: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n  // @ts-ignore\n  163: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,\n  // @ts-ignore\n  164: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n  // @ts-ignore\n  165: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,\n  // @ts-ignore\n  166: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n  // @ts-ignore\n  167: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,\n  // @ts-ignore\n  168: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n  // @ts-ignore\n  169: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,\n  // @ts-ignore\n  170: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n  // @ts-ignore\n  171: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,\n  // @ts-ignore\n  172: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n  // @ts-ignore\n  173: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,\n  // @ts-ignore\n  174: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n  // @ts-ignore\n  175: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,\n  // @ts-ignore\n  176: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n  // @ts-ignore\n  177: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,\n  // @ts-ignore\n  178: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n  // @ts-ignore\n  179: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,\n  // @ts-ignore\n  180: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n  // @ts-ignore\n  181: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,\n  // @ts-ignore\n  182: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n  // @ts-ignore\n  183: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR,\n  // @ts-ignore\n  184: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n  1000054000: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,\n  1000054001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n  // @ts-ignore\n  1000066000: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n  // @ts-ignore\n  1000066001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,\n  // @ts-ignore\n  1000066002: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,\n  // @ts-ignore\n  1000066003: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,\n  // @ts-ignore\n  1000066004: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,\n  // @ts-ignore\n  1000066005: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,\n  // @ts-ignore\n  1000066006: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,\n  // @ts-ignore\n  1000066007: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,\n  // @ts-ignore\n  1000066008: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,\n  // @ts-ignore\n  1000066009: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,\n  // @ts-ignore\n  1000066010: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,\n  // @ts-ignore\n  1000066011: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,\n  // @ts-ignore\n  1000066012: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,\n  // @ts-ignore\n  1000066013: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR\n};\n\n/**\n * Returns WebGl format based on Vulkan format\n * Vulkan to WebGl format mapping provided here http://github.khronos.org/KTX-Specification/#formatMapping\n * Vulkan name to format number mapping provided here: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormat.html\n * @param vkFormat\n * @returns WebGL / OpenGL constant\n */\nexport function mapVkFormatToWebGL(vkFormat: number): number {\n  return VULKAN_TO_WEBGL_FORMAT_MAP[vkFormat];\n}\n", "import type {TextureLevel} from '@loaders.gl/schema';\nimport {read} from 'ktx-parse';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\nimport {mapVkFormatToWebGL} from '../utils/ktx-format-helper';\n\nconst KTX2_ID = [\n  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n  0xab, 0x4b, 0x54, 0x58, 0x20, 0x32, 0x30, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a\n];\n\n// eslint-disable-next-line complexity\nexport function isKTX(data: ArrayBuffer) {\n  // const id = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  const id = new Uint8Array(data);\n  const notKTX =\n    id.byteLength < KTX2_ID.length ||\n    id[0] !== KTX2_ID[0] || // '´'\n    id[1] !== KTX2_ID[1] || // 'K'\n    id[2] !== KTX2_ID[2] || // 'T'\n    id[3] !== KTX2_ID[3] || // 'X'\n    id[4] !== KTX2_ID[4] || // ' '\n    id[5] !== KTX2_ID[5] || // '2'\n    id[6] !== KTX2_ID[6] || // '0'\n    id[7] !== KTX2_ID[7] || // 'ª'\n    id[8] !== KTX2_ID[8] || // '\\r'\n    id[9] !== KTX2_ID[9] || // '\\n'\n    id[10] !== KTX2_ID[10] || // '\\x1A'\n    id[11] !== KTX2_ID[11]; // '\\n'\n\n  return !notKTX;\n}\n\nexport function parseKTX(arrayBuffer: ArrayBuffer): TextureLevel[] {\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const ktx = read(uint8Array);\n  const mipMapLevels = Math.max(1, ktx.levels.length);\n  const width = ktx.pixelWidth;\n  const height = ktx.pixelHeight;\n  const internalFormat = mapVkFormatToWebGL(ktx.vkFormat);\n\n  return extractMipmapImages(ktx.levels, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction: (level: any): number => level.uncompressedByteLength,\n    internalFormat\n  });\n}\n", "/* eslint-disable indent */\nimport type {TextureLevel} from '@loaders.gl/schema';\nimport {loadBasisEncoderModule, loadBasisTrascoderModule} from './basis-module-loader';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {getSupportedGPUTextureFormats} from '../utils/texture-formats';\nimport {isKTX} from './parse-ktx';\n\nexport type BasisFormat =\n  | 'etc1'\n  | 'etc2'\n  | 'bc1'\n  | 'bc3'\n  | 'bc4'\n  | 'bc5'\n  | 'bc7-m6-opaque-only'\n  | 'bc7-m5'\n  | 'pvrtc1-4-rgb'\n  | 'pvrtc1-4-rgba'\n  | 'astc-4x4'\n  | 'atc-rgb'\n  | 'atc-rgba-interpolated-alpha'\n  | 'rgba32'\n  | 'rgb565'\n  | 'bgr565'\n  | 'rgba4444';\n\ntype BasisOutputOptions = {\n  basisFormat: number;\n  compressed: boolean;\n  format?: number;\n};\n\nconst OutputFormat: Record<string, BasisOutputOptions> = {\n  etc1: {\n    basisFormat: 0,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {basisFormat: 1, compressed: true},\n  bc1: {\n    basisFormat: 2,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {basisFormat: 4, compressed: true},\n  bc5: {basisFormat: 5, compressed: true},\n  'bc7-m6-opaque-only': {basisFormat: 6, compressed: true},\n  'bc7-m5': {basisFormat: 7, compressed: true},\n  'pvrtc1-4-rgb': {\n    basisFormat: 8,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  'pvrtc1-4-rgba': {\n    basisFormat: 9,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  'astc-4x4': {\n    basisFormat: 10,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  'atc-rgb': {basisFormat: 11, compressed: true},\n  'atc-rgba-interpolated-alpha': {basisFormat: 12, compressed: true},\n  rgba32: {basisFormat: 13, compressed: false},\n  rgb565: {basisFormat: 14, compressed: false},\n  bgr565: {basisFormat: 15, compressed: false},\n  rgba4444: {basisFormat: 16, compressed: false}\n};\n\n/**\n * parse data with a Binomial Basis_Universal module\n * @param data\n * @param options\n * @returns compressed texture data\n */\nexport default async function parseBasis(data: ArrayBuffer, options): Promise<TextureLevel[][]> {\n  if (options.basis.containerFormat === 'auto') {\n    if (isKTX(data)) {\n      const fileConstructors = await loadBasisEncoderModule(options);\n      return parseKTX2File(fileConstructors.KTX2File, data, options);\n    }\n    const {BasisFile} = await loadBasisTrascoderModule(options);\n    return parseBasisFile(BasisFile, data, options);\n  }\n  switch (options.basis.module) {\n    case 'encoder':\n      const fileConstructors = await loadBasisEncoderModule(options);\n      switch (options.basis.containerFormat) {\n        case 'ktx2':\n          return parseKTX2File(fileConstructors.KTX2File, data, options);\n        case 'basis':\n        default:\n          return parseBasisFile(fileConstructors.BasisFile, data, options);\n      }\n    case 'transcoder':\n    default:\n      const {BasisFile} = await loadBasisTrascoderModule(options);\n      return parseBasisFile(BasisFile, data, options);\n  }\n}\n\n/**\n * Parse *.basis file data\n * @param BasisFile - initialized transcoder module\n * @param data\n * @param options\n * @returns compressed texture data\n */\nfunction parseBasisFile(BasisFile, data, options): TextureLevel[][] {\n  const basisFile = new BasisFile(new Uint8Array(data));\n\n  try {\n    if (!basisFile.startTranscoding()) {\n      throw new Error('Failed to start basis transcoding');\n    }\n\n    const imageCount = basisFile.getNumImages();\n    const images: TextureLevel[][] = [];\n\n    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {\n      const levelsCount = basisFile.getNumLevels(imageIndex);\n      const levels: TextureLevel[] = [];\n\n      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));\n      }\n\n      images.push(levels);\n    }\n\n    return images;\n  } finally {\n    basisFile.close();\n    basisFile.delete();\n  }\n}\n\n/**\n * Parse the particular level image of a basis file\n * @param basisFile\n * @param imageIndex\n * @param levelIndex\n * @param options\n * @returns compressed texture data\n */\nfunction transcodeImage(basisFile, imageIndex, levelIndex, options): TextureLevel {\n  const width = basisFile.getImageWidth(imageIndex, levelIndex);\n  const height = basisFile.getImageHeight(imageIndex, levelIndex);\n\n  // See https://github.com/BinomialLLC/basis_universal/pull/83\n  const hasAlpha = basisFile.getHasAlpha(/* imageIndex, levelIndex */);\n\n  // Check options for output format etc\n  const {compressed, format, basisFormat} = getBasisOptions(options, hasAlpha);\n\n  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);\n  const decodedData = new Uint8Array(decodedSize);\n\n  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {\n    throw new Error('failed to start Basis transcoding');\n  }\n\n  return {\n    // standard loaders.gl image category payload\n    width,\n    height,\n    data: decodedData,\n    compressed,\n    format,\n\n    // Additional fields\n    // Add levelSize field.\n    hasAlpha\n  };\n}\n\n/**\n * Parse *.ktx2 file data\n * @param KTX2File\n * @param data\n * @param options\n * @returns compressed texture data\n */\nfunction parseKTX2File(KTX2File, data: ArrayBuffer, options): TextureLevel[][] {\n  const ktx2File = new KTX2File(new Uint8Array(data));\n\n  try {\n    if (!ktx2File.startTranscoding()) {\n      throw new Error('failed to start KTX2 transcoding');\n    }\n    const levelsCount = ktx2File.getLevels();\n    const levels: TextureLevel[] = [];\n\n    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));\n      break; // texture app can only show one level for some reason\n    }\n\n    return [levels];\n  } finally {\n    ktx2File.close();\n    ktx2File.delete();\n  }\n}\n\n/**\n * Parse the particular level image of a ktx2 file\n * @param ktx2File\n * @param levelIndex\n * @param options\n * @returns\n */\nfunction transcodeKTX2Image(ktx2File, levelIndex: number, options): TextureLevel {\n  const {alphaFlag, height, width} = ktx2File.getImageLevelInfo(levelIndex, 0, 0);\n\n  // Check options for output format etc\n  const {compressed, format, basisFormat} = getBasisOptions(options, alphaFlag);\n\n  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(\n    levelIndex,\n    0 /* layerIndex */,\n    0 /* faceIndex */,\n    basisFormat\n  );\n  const decodedData = new Uint8Array(decodedSize);\n\n  if (\n    !ktx2File.transcodeImage(\n      decodedData,\n      levelIndex,\n      0 /* layerIndex */,\n      0 /* faceIndex */,\n      basisFormat,\n      0,\n      -1 /* channel0 */,\n      -1 /* channel1 */\n    )\n  ) {\n    throw new Error('Failed to transcode KTX2 image');\n  }\n\n  return {\n    // standard loaders.gl image category payload\n    width,\n    height,\n    data: decodedData,\n    compressed,\n\n    // Additional fields\n    levelSize: decodedSize,\n    hasAlpha: alphaFlag,\n    format\n  };\n}\n\n/**\n * Get BasisFormat by loader format option\n * @param options\n * @param hasAlpha\n * @returns BasisFormat data\n */\nfunction getBasisOptions(options, hasAlpha: boolean): BasisOutputOptions {\n  let format = options && options.basis && options.basis.format;\n  if (format === 'auto') {\n    format = selectSupportedBasisFormat();\n  }\n  if (typeof format === 'object') {\n    format = hasAlpha ? format.alpha : format.noAlpha;\n  }\n  format = format.toLowerCase();\n  return OutputFormat[format];\n}\n\n/**\n * Select transcode format from the list of supported formats\n * @returns key for OutputFormat map\n */\nexport function selectSupportedBasisFormat():\n  | BasisFormat\n  | {\n      alpha: BasisFormat;\n      noAlpha: BasisFormat;\n    } {\n  const supportedFormats = getSupportedGPUTextureFormats();\n  if (supportedFormats.has('astc')) {\n    return 'astc-4x4';\n  } else if (supportedFormats.has('dxt')) {\n    return {\n      alpha: 'bc3',\n      noAlpha: 'bc1'\n    };\n  } else if (supportedFormats.has('pvrtc')) {\n    return {\n      alpha: 'pvrtc1-4-rgba',\n      noAlpha: 'pvrtc1-4-rgb'\n    };\n  } else if (supportedFormats.has('etc1')) {\n    return 'etc1';\n  } else if (supportedFormats.has('etc2')) {\n    return 'etc2';\n  }\n  return 'rgb565';\n}\n", "import type {Loader, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/worker-utils';\nimport {VERSION} from './lib/utils/version';\nimport parseBasis from './lib/parsers/parse-basis';\n\n/**\n * Worker loader for Basis super compressed textures\n */\nexport const BasisWorkerLoader = {\n  name: 'Basis',\n  id: isBrowser ? 'basis' : 'basis-nodejs',\n  module: 'textures',\n  version: VERSION,\n  worker: true,\n  extensions: ['basis', 'ktx2'],\n  mimeTypes: ['application/octet-stream', 'image/ktx2'],\n  tests: ['sB'],\n  binary: true,\n  options: {\n    basis: {\n      format: 'auto', // gl context doesn't exist on a worker thread\n      libraryPath: 'libs/',\n      containerFormat: 'auto', // 'basis' || 'ktx2' || 'auto'\n      module: 'transcoder' // 'transcoder' || 'encoder'\n    }\n  }\n};\n\n/**\n * Loader for Basis super compressed textures\n */\nexport const BasisLoader = {\n  ...BasisWorkerLoader,\n  parse: parseBasis\n};\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckBasisWorkerLoader: Loader = BasisWorkerLoader;\nexport const _TypecheckBasisLoader: LoaderWithParser = BasisLoader;\n", "import type {TextureLevel} from '@loaders.gl/schema';\nimport {assert} from '@loaders.gl/loader-utils';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\n\nconst DDS_CONSTANTS = {\n  MAGIC_NUMBER: 0x20534444,\n  HEADER_LENGTH: 31,\n  MAGIC_NUMBER_INDEX: 0,\n  HEADER_SIZE_INDEX: 1,\n  HEADER_FLAGS_INDEX: 2,\n  HEADER_HEIGHT_INDEX: 3,\n  HEADER_WIDTH_INDEX: 4,\n  MIPMAPCOUNT_INDEX: 7,\n  HEADER_PF_FLAGS_INDEX: 20,\n  HEADER_PF_FOURCC_INDEX: 21,\n  DDSD_MIPMAPCOUNT: 0x20000,\n  DDPF_FOURCC: 0x4\n};\n\nconst DDS_PIXEL_FORMATS: Record<string, number> = {\n  DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n  DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  'ATC ': GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,\n  ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n  ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n};\n\nconst getATCLevelSize = getDxt1LevelSize;\nconst getATCALevelSize = getDxtXLevelSize;\nconst getATCILevelSize = getDxtXLevelSize;\n\nconst DDS_SIZE_FUNCTIONS: Record<string, (width: number, height: number) => number> = {\n  DXT1: getDxt1LevelSize,\n  DXT3: getDxtXLevelSize,\n  DXT5: getDxtXLevelSize,\n  'ATC ': getATCLevelSize,\n  ATCA: getATCALevelSize,\n  ATCI: getATCILevelSize\n};\n\n/**\n * Check if data is in \"DDS\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"DDS\" format, else - false\n */\nexport function isDDS(data: ArrayBuffer): boolean {\n  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];\n  return magic === DDS_CONSTANTS.MAGIC_NUMBER;\n}\n\n/**\n * Parse texture data as \"DDS\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseDDS(data: ArrayBuffer): TextureLevel[] {\n  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];\n  assert(\n    Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC),\n    'DDS: Unsupported format, must contain a FourCC code'\n  );\n  const fourCC = int32ToFourCC(pixelFormatNumber);\n  const internalFormat = DDS_PIXEL_FORMATS[fourCC];\n  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];\n  assert(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);\n\n  let mipMapLevels = 1;\n  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {\n    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);\n  }\n  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];\n  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];\n  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;\n  const image = new Uint8Array(data, dataOffset);\n\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat\n  });\n}\n\n/**\n * DXT1 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxt1LevelSize(width: number, height: number): number {\n  return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\n}\n\n/**\n * DXT3 & DXT5 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxtXLevelSize(width: number, height: number): number {\n  return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\n}\n\n/**\n * Convert every byte of Int32 value to char\n * @param value - Int32 number\n * @returns string of 4 characters\n */\nfunction int32ToFourCC(value: number): string {\n  return String.fromCharCode(\n    value & 0xff,\n    (value >> 8) & 0xff,\n    (value >> 16) & 0xff,\n    (value >> 24) & 0xff\n  );\n}\n", "/* eslint-disable camelcase */\n// Forked from PicoGL: https://github.com/tsherif/picogl.js/blob/master/examples/utils/utils.js\n// Copyright (c) 2017 Tarek Sherif, The MIT License (MIT)\n\nimport type {TextureLevel} from '@loaders.gl/schema';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\n\nconst PVR_CONSTANTS: Record<string, number> = {\n  MAGIC_NUMBER: 0x03525650,\n  MAGIC_NUMBER_EXTRA: 0x50565203,\n  HEADER_LENGTH: 13,\n  HEADER_SIZE: 52,\n  MAGIC_NUMBER_INDEX: 0,\n  PIXEL_FORMAT_INDEX: 2,\n  COLOUR_SPACE_INDEX: 4,\n  HEIGHT_INDEX: 6,\n  WIDTH_INDEX: 7,\n  MIPMAPCOUNT_INDEX: 11,\n  METADATA_SIZE_INDEX: 12\n};\n\nconst PVR_PIXEL_FORMATS: Record<number, number[]> = {\n  0: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG],\n  1: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG],\n  2: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG],\n  3: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG],\n  6: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL],\n  7: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT],\n  9: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT],\n  11: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT],\n  22: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2],\n  23: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC],\n  24: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2],\n  25: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC],\n  26: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC],\n  27: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR\n  ],\n  28: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X4_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR\n  ],\n  29: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR\n  ],\n  30: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR\n  ],\n  31: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X6_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR\n  ],\n  32: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR\n  ],\n  33: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X6_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR\n  ],\n  34: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X8_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR\n  ],\n  35: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR\n  ],\n  36: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X6_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR\n  ],\n  37: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X8_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR\n  ],\n  38: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X10_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR\n  ],\n  39: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X10_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR\n  ],\n  40: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X12_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR\n  ]\n};\n\nconst PVR_SIZE_FUNCTIONS: Record<number, (width: number, height: number) => number> = {\n  0: pvrtc2bppSize,\n  1: pvrtc2bppSize,\n  2: pvrtc4bppSize,\n  3: pvrtc4bppSize,\n  6: dxtEtcSmallSize,\n  7: dxtEtcSmallSize,\n  9: dxtEtcAstcBigSize,\n  11: dxtEtcAstcBigSize,\n  22: dxtEtcSmallSize,\n  23: dxtEtcAstcBigSize,\n  24: dxtEtcSmallSize,\n  25: dxtEtcSmallSize,\n  26: dxtEtcAstcBigSize,\n  27: dxtEtcAstcBigSize,\n  28: atc5x4Size,\n  29: atc5x5Size,\n  30: atc6x5Size,\n  31: atc6x6Size,\n  32: atc8x5Size,\n  33: atc8x6Size,\n  34: atc8x8Size,\n  35: atc10x5Size,\n  36: atc10x6Size,\n  37: atc10x8Size,\n  38: atc10x10Size,\n  39: atc12x10Size,\n  40: atc12x12Size\n};\n\n/**\n * Check if data is in \"PVR\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"PVR\" format, else - false\n */\nexport function isPVR(data: ArrayBuffer): boolean {\n  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);\n  const version = header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX];\n\n  return version === PVR_CONSTANTS.MAGIC_NUMBER || version === PVR_CONSTANTS.MAGIC_NUMBER_EXTRA;\n}\n\n/**\n * Parse texture data as \"PVR\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n * @see http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.pdf\n */\nexport function parsePVR(data: ArrayBuffer): TextureLevel[] {\n  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);\n\n  const pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX];\n  const colourSpace = header[PVR_CONSTANTS.COLOUR_SPACE_INDEX];\n  const pixelFormats = PVR_PIXEL_FORMATS[pvrFormat] || [];\n  const internalFormat = pixelFormats.length > 1 && colourSpace ? pixelFormats[1] : pixelFormats[0];\n\n  const sizeFunction = PVR_SIZE_FUNCTIONS[pvrFormat];\n\n  const mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];\n\n  const width = header[PVR_CONSTANTS.WIDTH_INDEX];\n  const height = header[PVR_CONSTANTS.HEIGHT_INDEX];\n\n  const dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];\n\n  const image = new Uint8Array(data, dataOffset);\n\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat\n  });\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\nfunction pvrtc2bppSize(width: number, height: number): number {\n  width = Math.max(width, 16);\n  height = Math.max(height, 8);\n\n  return (width * height) / 4;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\nfunction pvrtc4bppSize(width: number, height: number): number {\n  width = Math.max(width, 8);\n  height = Math.max(height, 8);\n\n  return (width * height) / 2;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/\n// Size for:\n// COMPRESSED_RGB_S3TC_DXT1_EXT\n// COMPRESSED_R11_EAC\n// COMPRESSED_SIGNED_R11_EAC\n// COMPRESSED_RGB8_ETC2\n// COMPRESSED_SRGB8_ETC2\n// COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\n// COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\nfunction dxtEtcSmallSize(width: number, height: number): number {\n  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\n// Size for:\n// COMPRESSED_RGBA_S3TC_DXT3_EXT\n// COMPRESSED_RGBA_S3TC_DXT5_EXT\n// COMPRESSED_RG11_EAC\n// COMPRESSED_SIGNED_RG11_EAC\n// COMPRESSED_RGBA8_ETC2_EAC\n// COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\n// COMPRESSED_RGBA_ASTC_4x4_KHR\nfunction dxtEtcAstcBigSize(width: number, height: number): number {\n  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc5x4Size(width: number, height: number): number {\n  return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc5x5Size(width: number, height: number): number {\n  return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc6x5Size(width: number, height: number): number {\n  return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc6x6Size(width: number, height: number): number {\n  return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x5Size(width: number, height: number): number {\n  return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x6Size(width: number, height: number): number {\n  return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x8Size(width: number, height: number): number {\n  return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x5Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x6Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x8Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x10Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc12x10Size(width: number, height: number): number {\n  return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc12x12Size(width: number, height: number): number {\n  return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;\n}\n", "import type {TextureLevel} from '@loaders.gl/schema';\nimport {isKTX, parseKTX} from './parse-ktx';\nimport {isDDS, parseDDS} from './parse-dds';\nimport {isPVR, parsePVR} from './parse-pvr';\n\n/**\n * Deduces format and parses compressed texture loaded in ArrayBuffer\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseCompressedTexture(data: ArrayBuffer): TextureLevel[] {\n  if (isKTX(data)) {\n    // TODO: remove @ts-ignore when `parseKTX` output is normalized to loaders.gl texture format\n    // @ts-ignore\n    return parseKTX(data);\n  }\n  if (isDDS(data)) {\n    return parseDDS(data);\n  }\n  if (isPVR(data)) {\n    return parsePVR(data);\n  }\n  throw new Error('Texture container format not recognized');\n}\n", "import type {Loader, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {parseCompressedTexture} from './lib/parsers/parse-compressed-texture';\nimport parseBasis from './lib/parsers/parse-basis';\n\nexport type TextureLoaderOptions = {\n  'compressed-texture'?: {\n    libraryPath?: string;\n    useBasis?: boolean;\n  };\n};\n\nconst DEFAULT_TEXTURE_LOADER_OPTIONS = {\n  'compressed-texture': {\n    libraryPath: 'libs/',\n    useBasis: false\n  }\n};\n\n/**\n * Worker Loader for KTX, DDS, and PVR texture container formats\n */\nexport const CompressedTextureWorkerLoader = {\n  name: 'Texture Containers',\n  id: 'compressed-texture',\n  module: 'textures',\n  version: VERSION,\n  worker: true,\n  extensions: [\n    'ktx',\n    'ktx2',\n    'dds', // WEBGL_compressed_texture_s3tc, WEBGL_compressed_texture_atc\n    'pvr' // WEBGL_compressed_texture_pvrtc\n  ],\n  mimeTypes: [\n    'image/ktx2',\n    'image/ktx',\n    'image/vnd-ms.dds',\n    'image/x-dds',\n    'application/octet-stream'\n  ],\n  binary: true,\n  options: DEFAULT_TEXTURE_LOADER_OPTIONS\n};\n\n/**\n * Loader for KTX, DDS, and PVR texture container formats\n */\nexport const CompressedTextureLoader = {\n  ...CompressedTextureWorkerLoader,\n  parse: async (arrayBuffer, options) => {\n    if (options['compressed-texture'].useBasis) {\n      options.basis = {\n        format: {\n          alpha: 'BC3',\n          noAlpha: 'BC1'\n        },\n        ...options.basis,\n        containerFormat: 'ktx2',\n        module: 'encoder'\n      };\n      return (await parseBasis(arrayBuffer, options))[0];\n    }\n    return parseCompressedTexture(arrayBuffer);\n  }\n};\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckCompressedTextureWorkerLoader: Loader = CompressedTextureWorkerLoader;\nexport const _TypecheckCompressedTextureLoader: LoaderWithParser = CompressedTextureLoader;\n", "// import type {TextureLevel} from '@loaders.gl/schema';\n\ntype NumpyHeader = {descr: string; shape: number[]};\ntype TypedArrayConstructor =\n  | typeof Int8Array\n  | typeof Uint8Array\n  | typeof Int16Array\n  | typeof Uint16Array\n  | typeof Int32Array\n  | typeof Uint32Array\n  | typeof Int32Array\n  | typeof Uint32Array\n  | typeof Float32Array\n  | typeof Float64Array;\n\nfunction systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\n\n// The basic string format consists of 3 characters:\n// 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n// 2. a character code giving the basic type of the array\n// 3. an integer providing the number of bytes the type uses.\n// https://numpy.org/doc/stable/reference/arrays.interface.html\n//\n// Here I only include the second and third characters, and check endianness\n// separately\nconst DTYPES: Record<string, TypedArrayConstructor> = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\n\nexport function parseNPY(arrayBuffer: ArrayBuffer, options?: unknown) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {header, headerEndOffset} = parseHeader(view);\n\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    throw new Error(`Unimplemented type ${numpyType}`);\n  }\n\n  const nArrayElements = header.shape?.reduce((a: number, b: number): number => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n\n  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {\n    throw new Error('Buffer overflow');\n  }\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  // Swap endianness if needed\n  if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n    throw new Error('Incorrect endianness');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view: DataView): {header: NumpyHeader; headerEndOffset: number} {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n\n  let offset = 8;\n  let headerLength: number;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(offset, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(offset, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n\n  const header = JSON.parse(\n    headerText\n      .replace(/'/g, '\"')\n      .replace('False', 'false')\n      .replace('(', '[')\n      .replace(/,*\\),*/g, ']')\n  );\n\n  return {header, headerEndOffset: offset};\n}\n", "import type {Loader, LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {parseNPY} from './lib/parsers/parse-npy';\n\n// \\x93NUMPY\nconst NPY_MAGIC_NUMBER = new Uint8Array([147, 78, 85, 77, 80, 89]);\n\n/**\n * Worker loader for numpy \"tiles\"\n */\nexport const NPYWorkerLoader = {\n  name: 'NPY',\n  id: 'npy',\n  module: 'textures',\n  version: VERSION,\n  worker: true,\n  extensions: ['npy'],\n  mimeTypes: [],\n  tests: [NPY_MAGIC_NUMBER.buffer],\n  options: {\n    npy: {}\n  }\n};\n\n/**\n * Loader for numpy \"tiles\"\n */\nexport const NPYLoader = {\n  ...NPYWorkerLoader,\n  parseSync: parseNPY,\n  parse: async (arrayBuffer: ArrayBuffer, options?: LoaderOptions) => parseNPY(arrayBuffer, options)\n};\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckNPYWorkerLoader: Loader = NPYWorkerLoader;\nexport const _TypecheckNPYLoader: LoaderWithParser = NPYLoader;\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: unknown, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'assert failed: gltf');\n  }\n}\n", "// Resolves a relative url against a baseUrl\n// If url is absolute, return it unchanged\nexport function resolveUrl(url, options) {\n  // TODO: Use better logic to handle all protocols plus not delay on data\n  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');\n  if (absolute) {\n    return url;\n  }\n  const baseUrl = options.baseUri || options.uri;\n  if (!baseUrl) {\n    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);\n  }\n  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;\n}\n", "// TODO - GLTFScenegraph should use these\nimport {assert} from '../utils/assert';\n\n// accepts buffer view index or buffer view object\n// returns a `Uint8Array`\nexport function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {\n  const bufferView = json.bufferViews[bufferViewIndex];\n  assert(bufferView);\n\n  // Get hold of the arrayBuffer\n  const bufferIndex = bufferView.buffer;\n  const binChunk = buffers[bufferIndex];\n  assert(binChunk);\n\n  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n}\n\n// accepts accessor index or accessor object\n// returns a `Uint8Array`\nexport function getTypedArrayForImageData(json, buffers, imageIndex) {\n  const image = json.images[imageIndex];\n  const bufferViewIndex = json.bufferViews[image.bufferView];\n  return getTypedArrayForBufferView(json, buffers, bufferViewIndex);\n}\n\n/*\n// accepts accessor index or accessor object\n// returns a typed array with type that matches the types\nexport function getTypedArrayForAccessor(accessor) {\n  accessor = this.getAccessor(accessor);\n  const bufferView = this.getBufferView(accessor.bufferView);\n  const buffer = this.getBuffer(bufferView.buffer);\n  const arrayBuffer = buffer.data;\n\n  // Create a new typed array as a view into the combined buffer\n  const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n  const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  return new ArrayType(arrayBuffer, byteOffset, length);\n}\n*/\n", "/* eslint-disable camelcase */\nimport type {GLTF, GLTFBufferView, GLTF_EXT_meshopt_compression} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {meshoptDecodeGltfBuffer} from '../../meshopt/meshopt-decoder';\n\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nexport const name = EXT_MESHOPT_COMPRESSION;\n\nexport async function decode(gltfData: {json: GLTF}, options: GLTFLoaderOptions) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const promises: Promise<any>[] = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extension\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(\n  scenegraph: GLTFScenegraph,\n  bufferView: GLTFBufferView\n): Promise<ArrayBuffer | null> {\n  const meshoptExtension = scenegraph.getObjectExtension<GLTF_EXT_meshopt_compression>(\n    bufferView,\n    EXT_MESHOPT_COMPRESSION\n  );\n  if (meshoptExtension) {\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE',\n      buffer: bufferIndex\n    } = meshoptExtension;\n    const buffer = scenegraph.gltf.buffers[bufferIndex];\n\n    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);\n    const result = new Uint8Array(\n      scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer,\n      bufferView.byteOffset,\n      bufferView.byteLength\n    );\n    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}\n", "import {assert} from '../utils/assert';\nimport {GLTF} from '../types/gltf-types';\n\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT: [TypedArrayConstructor, number][] = [\n  [Int8Array, 5120],\n  [Uint8Array, 5121],\n  [Int16Array, 5122],\n  [Uint16Array, 5123],\n  [Uint32Array, 5125],\n  [Float32Array, 5126],\n  [Float64Array, 5130]\n];\nconst ARRAY_TO_COMPONENT_TYPE = new Map<TypedArrayConstructor, number>(\n  ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT\n);\n\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nexport function getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\n\nexport function getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n  return componentType;\n}\n\nexport function getAccessorArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  return {ArrayType, length, byteLength};\n}\n\n/**\n * Calculate the GPU memory used by a GLTF tile, for both buffer and texture memory\n * @param gltf - the gltf content of a GLTF tile\n * @returns - total memory usage in bytes\n */\nexport function getMemoryUsageGLTF(gltf: GLTF): number {\n  let {images, bufferViews} = gltf;\n  images = images || [];\n  bufferViews = bufferViews || [];\n  const imageBufferViews = images.map((i) => i.bufferView);\n  bufferViews = bufferViews.filter((view) => !imageBufferViews.includes(view as any));\n\n  const bufferMemory = bufferViews.reduce((acc, view) => acc + view.byteLength, 0);\n\n  // Assume each pixel of the texture is 4 channel with mimmaps (which add 33%)\n  // TODO correctly handle compressed textures\n  const pixelCount = images.reduce((acc, image) => {\n    // @ts-ignore\n    const {width, height} = (image as any).image;\n    return acc + width * height;\n  }, 0);\n  return bufferMemory + Math.ceil(4 * pixelCount * 1.33);\n}\n", "import type {\n  GLTF,\n  GLTFScene,\n  GLTFNode,\n  GLTFMesh,\n  GLTFSkin,\n  GLTFMaterial,\n  GLTFAccessor,\n  GLTFSampler,\n  GLTFTexture,\n  GLTFImage,\n  GLTFBuffer,\n  GLTFBufferView,\n  GLTFWithBuffers\n} from '../types/gltf-types';\n\nimport {getBinaryImageMetadata} from '@loaders.gl/images';\nimport {padToNBytes, copyToArray} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {\n  getAccessorArrayTypeAndLength,\n  getAccessorTypeFromSize,\n  getComponentTypeFromArray\n} from '../gltf-utils/gltf-utils';\n\nconst DEFAULT_GLTF_JSON: GLTF = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\n\ntype Extension = {[key: string]: any};\n/**\n * Class for structured access to GLTF data\n */\nexport default class GLTFScenegraph {\n  // internal\n  gltf: GLTFWithBuffers;\n  sourceBuffers: any[];\n  byteLength: number;\n\n  constructor(gltf?: {json: GLTF; buffers?: any[]}) {\n    // @ts-ignore\n    this.gltf = gltf || {\n      json: {...DEFAULT_GLTF_JSON},\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  // Accessors\n\n  get json(): GLTF {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key: string): unknown {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key: string): {[key: string]: unknown} {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension<T = Extension>(extensionName: string): T | null {\n    const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension<T = Extension>(extensionName: string): T | null {\n    const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions(): string[] {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions(): string[] {\n    return this.json.extensionsUsed || [];\n  }\n\n  getRemovedExtensions(): string[] {\n    return (this.json.extensionsRemoved || []) as string[];\n  }\n\n  getObjectExtension<T = Extension>(object: {[key: string]: any}, extensionName: string): T | null {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index: number): GLTFScene {\n    return this.getObject('scenes', index) as GLTFScene;\n  }\n\n  getNode(index: number): GLTFNode {\n    return this.getObject('nodes', index) as GLTFNode;\n  }\n\n  getSkin(index: number): GLTFSkin {\n    return this.getObject('skins', index) as GLTFSkin;\n  }\n\n  getMesh(index: number): GLTFMesh {\n    return this.getObject('meshes', index) as GLTFMesh;\n  }\n\n  getMaterial(index: number): GLTFMaterial {\n    return this.getObject('materials', index) as GLTFMaterial;\n  }\n\n  getAccessor(index: number): GLTFAccessor {\n    return this.getObject('accessors', index) as GLTFAccessor;\n  }\n\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n\n  getTexture(index: number): GLTFTexture {\n    return this.getObject('textures', index) as GLTFTexture;\n  }\n\n  getSampler(index: number): GLTFSampler {\n    return this.getObject('samplers', index) as GLTFSampler;\n  }\n\n  getImage(index: number): GLTFImage {\n    return this.getObject('images', index) as GLTFImage;\n  }\n\n  getBufferView(index: number | object): GLTFBufferView {\n    return this.getObject('bufferViews', index) as GLTFBufferView;\n  }\n\n  getBuffer(index: number): GLTFBuffer {\n    return this.getObject('buffers', index) as GLTFBuffer;\n  }\n\n  getObject(array: string, index: number | object): object {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && (this.json[array] as {}[])[index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView: number | object): Uint8Array {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor: number | object): any {\n    // @ts-ignore\n    accessor = this.getAccessor(accessor);\n    // @ts-ignore\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    // Create a new typed array as a view into the combined buffer\n    const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n    // @ts-ignore\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image: number | object): Uint8Array {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  // MODIFERS\n\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key: string, data: object): GLTFScenegraph {\n    this.json[key] = data;\n    return this;\n  }\n\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key: string, data: object): GLTFScenegraph {\n    this.json.extras = this.json.extras || {};\n    (this.json.extras as Record<string, unknown>)[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object: object, extensionName: string, data: object): GLTFScenegraph {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object: object, extensionName: string, data: object): void {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n\n  removeObjectExtension(object: object, extensionName: string): object {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName: string, extensionData: object = {}): object {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    (this.json.extensions as Record<string, unknown>)[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData: object = {}): object {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName: string): void {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName: string): void {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName: string): void {\n    if (!this.getExtension(extensionName)) {\n      return;\n    }\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n    if (!Array.isArray(this.json.extensionsRemoved)) {\n      this.json.extensionsRemoved = [];\n    }\n    const extensionsRemoved = this.json.extensionsRemoved as string[];\n    if (!extensionsRemoved.includes(extensionName)) {\n      extensionsRemoved.push(extensionName);\n    }\n  }\n\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex: number): void {\n    this.json.scene = sceneIndex;\n  }\n\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene: {nodeIndices: number[]}): number {\n    const {nodeIndices} = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({nodes: nodeIndices});\n    return this.json.scenes.length - 1;\n  }\n\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node: {meshIndex: number; matrix?: number[]}): number {\n    const {meshIndex, matrix} = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {mesh: meshIndex};\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  /** Adds a mesh to the json part */\n  addMesh(mesh: {attributes: object; indices?: object; material?: number; mode?: number}): number {\n    const {attributes, indices, material, mode = 4} = mesh;\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessors,\n          mode\n        }\n      ]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes: object): number {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessorIndices,\n          mode: 0 // GL.POINTS\n        }\n      ]\n    };\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData: any, mimeTypeOpt?: string): number {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n\n    const bufferViewIndex = this.addBufferView(imageData);\n\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer: any): number {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n\n    const glTFBufferView = {\n      buffer: 0,\n      // Write offset from the start of the binary body\n      byteOffset: this.byteLength,\n      byteLength\n    };\n\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex: number, accessor: object): number {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer: any, accessor: object = {size: 3}): number {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {min: accessor.min, max: accessor.max};\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture: {imageIndex: number}): number {\n    const {imageIndex} = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo: Object): number {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  /** Pack the binary chunk */\n  createBinaryChunk(): void {\n    // Encoder expects this array undefined or empty\n    this.gltf.buffers = [];\n\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{byteLength: totalByteLength}];\n    }\n\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  // PRIVATE\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {size: 1});\n  }\n\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {min: null, max: null};\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n          // @ts-ignore\n          result.min[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n          // @ts-ignore\n          result.max[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n      }\n    }\n    return result;\n  }\n}\n", "// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2021, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n\n/* eslint-disable camelcase */\nconst isWebAssemblySupported = typeof WebAssembly !== 'object';\n\n// Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n// Built from meshoptimizer 0.16\nconst wasm_base =\n  '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';\nconst wasm_simd =\n  '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';\n\n// Uses bulk-memory and simd extensions\nconst detector = new Uint8Array([\n  0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2,\n  12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11\n]);\n\n// Used to unpack wasm\nconst wasmpack = new Uint8Array([\n  32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113,\n  127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101,\n  130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167\n]);\n\nconst FILTERS = {\n  // legacy index-based enums for glTF\n  0: '',\n  1: 'meshopt_decodeFilterOct',\n  2: 'meshopt_decodeFilterQuat',\n  3: 'meshopt_decodeFilterExp',\n  // string-based enums for glTF\n  NONE: '',\n  OCTAHEDRAL: 'meshopt_decodeFilterOct',\n  QUATERNION: 'meshopt_decodeFilterQuat',\n  EXPONENTIAL: 'meshopt_decodeFilterExp'\n};\n\nconst DECODERS = {\n  // legacy index-based enums for glTF\n  0: 'meshopt_decodeVertexBuffer',\n  1: 'meshopt_decodeIndexBuffer',\n  2: 'meshopt_decodeIndexSequence',\n  // string-based enums for glTF\n  ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n  TRIANGLES: 'meshopt_decodeIndexBuffer',\n  INDICES: 'meshopt_decodeIndexSequence'\n};\n\nexport function isMeshoptSupported(): boolean {\n  return isWebAssemblySupported;\n}\n\nexport async function meshoptDecodeVertexBuffer(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array,\n  filter: string | number = 'NONE'\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(\n    instance,\n    instance.exports.meshopt_decodeVertexBuffer,\n    target,\n    count,\n    size,\n    source,\n    instance.exports[FILTERS[filter]]\n  );\n}\n\nexport async function meshoptDecodeIndexBuffer(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n}\n\nexport async function meshoptDecodeIndexSequence(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n}\n\n// eslint-disable-next-line max-params\nexport async function meshoptDecodeGltfBuffer(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array,\n  mode: string,\n  filter: string | number = 'NONE'\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(\n    instance,\n    instance.exports[DECODERS[mode]],\n    target,\n    count,\n    size,\n    source,\n    instance.exports[FILTERS[filter || 'NONE']]\n  );\n}\n\nlet wasmPromise: Promise<WebAssembly.Instance>;\n\nasync function loadWasmInstance(): Promise<WebAssembly.Instance> {\n  // eslint-disable-next-line\n  if (!wasmPromise) {\n    wasmPromise = loadWasmModule();\n  }\n  return wasmPromise;\n}\n\nasync function loadWasmModule(): Promise<WebAssembly.Instance> {\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n\n    // eslint-disable-next-line no-console\n    console.log('Warning: meshopt_decoder is using experimental SIMD support');\n  }\n\n  const result = await WebAssembly.instantiate(unpack(wasm), {});\n  await (result.instance.exports as any).__wasm_call_ctors();\n  return result.instance;\n}\n\nfunction unpack(data) {\n  const result = new Uint8Array(data.length);\n  for (let i = 0; i < data.length; ++i) {\n    const ch = data.charCodeAt(i);\n    result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n  }\n  let write = 0;\n  for (let i = 0; i < data.length; ++i) {\n    result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n  }\n  return result.buffer.slice(0, write);\n}\n\n// eslint-disable-next-line max-params\nfunction decode(instance, fun, target, count, size, source, filter?) {\n  const sbrk = instance.exports.sbrk;\n  const count4 = (count + 3) & ~3; // pad for SIMD filter\n  const tp = sbrk(count4 * size);\n  const sp = sbrk(source.length);\n  const heap = new Uint8Array(instance.exports.memory.buffer);\n  heap.set(source, sp);\n  const res = fun(tp, count, size, sp, source.length);\n  if (res === 0 && filter) {\n    filter(tp, count4, size);\n  }\n  target.set(heap.subarray(tp, tp + count * size));\n  sbrk(tp - sbrk(0));\n  if (res !== 0) {\n    throw new Error(`Malformed buffer data: ${res}`);\n  }\n}\n", "// GLTF EXTENSION: EXT_TEXTURE_WEBP\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_TEXTURE_WEBP\n/* eslint-disable camelcase */\n\nimport type {GLTF, GLTF_EXT_texture_webp} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport {isImageFormatSupported} from '@loaders.gl/images';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\nconst EXT_TEXTURE_WEBP = 'EXT_texture_webp';\n\n/** Extension name */\nexport const name = EXT_TEXTURE_WEBP;\n\n/**\n * Replaces a texture source reference with the extension texture\n * Done in preprocess() to prevent load of default image\n */\nexport function preprocess(gltfData: {json: GLTF}, options: GLTFLoaderOptions): void {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!isImageFormatSupported('image/webp')) {\n    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {\n      throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);\n    }\n    return;\n  }\n\n  const {json} = scenegraph;\n\n  for (const texture of json.textures || []) {\n    const extension = scenegraph.getObjectExtension<GLTF_EXT_texture_webp>(\n      texture,\n      EXT_TEXTURE_WEBP\n    );\n    if (extension) {\n      // TODO - if multiple texture extensions are present which one wins?\n      texture.source = extension.source;\n    }\n    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);\n  }\n\n  // Remove the top-level extension\n  scenegraph.removeExtension(EXT_TEXTURE_WEBP);\n}\n", "// GLTF EXTENSION: KHR_texture_basisu\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_basisu\n/* eslint-disable camelcase */\n\nimport type {GLTF, GLTF_KHR_texture_basisu} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\nconst KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\n\n/** Extension name */\nexport const name = KHR_TEXTURE_BASISU;\n\n/**\n * Replaces a texture source reference with the extension texture\n * Done in preprocess() to prevent load of default image\n */\nexport function preprocess(gltfData: {json: GLTF}, options: GLTFLoaderOptions): void {\n  const scene = new GLTFScenegraph(gltfData);\n  const {json} = scene;\n\n  for (const texture of json.textures || []) {\n    const extension = scene.getObjectExtension<GLTF_KHR_texture_basisu>(\n      texture,\n      KHR_TEXTURE_BASISU\n    );\n    if (extension) {\n      // TODO - if multiple texture extensions are present which one wins?\n      texture.source = extension.source;\n    }\n    scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);\n  }\n\n  // Remove the top-level extension\n  scene.removeExtension(KHR_TEXTURE_BASISU);\n}\n", "// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n/* eslint-disable camelcase */\n\n/* eslint-disable camelcase */\nimport type {\n  GLTF,\n  GLTFAccessor,\n  GLTFMeshPrimitive,\n  GLTF_KHR_draco_mesh_compression\n} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {DracoLoaderOptions, DracoMesh} from '@loaders.gl/draco';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {default as Scenegraph} from '../api/gltf-scenegraph';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n\n/** Extension name */\nexport const name = KHR_DRACO_MESH_COMPRESSION;\n\nexport function preprocess(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): void {\n  const scenegraph = new Scenegraph(gltfData);\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      // TODO - Remove fallback accessors to make sure we don't load unnecessary buffers\n    }\n  }\n}\n\nexport async function decode(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises: Promise<void>[] = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extension\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options: GLTFLoaderOptions = {}): void {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(\n  scenegraph: Scenegraph,\n  primitive: GLTFMeshPrimitive,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  const dracoExtension = scenegraph.getObjectExtension<GLTF_KHR_draco_mesh_compression>(\n    primitive,\n    KHR_DRACO_MESH_COMPRESSION\n  );\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  const {parse} = context;\n  const dracoOptions: DracoLoaderOptions = {...options};\n\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = (await parse(bufferCopy, DracoLoader, dracoOptions, context)) as DracoMesh;\n\n  const decodedAttributes: {[key: string]: GLTFAccessor} = getGLTFAccessors(decodedData.attributes);\n\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex: number = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode: number = 4, options, context: LoaderContext) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive: GLTFMeshPrimitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "import type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/worker-utils';\nimport type {DracoParseOptions} from './lib/draco-parser';\n// import type {DracoMeshData} from './types';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoLoaderOptions = LoaderOptions & {\n  draco?: DracoParseOptions & {\n    decoderType?: 'wasm' | 'js';\n    libraryPath?: string;\n    extraAttributes?;\n    attributeNameEntry?: string;\n    workerUrl?: string;\n  };\n};\n\nconst DEFAULT_DRACO_OPTIONS: DracoLoaderOptions = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\n\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  name: 'Draco',\n  id: isBrowser ? 'draco' : 'draco-nodejs',\n  module: 'draco',\n  shapes: ['mesh'],\n  version: VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\n\nexport const _TypecheckDracoLoader: Loader = DracoLoader;\n", "import {deduceMeshField, MeshAttribute} from '@loaders.gl/schema';\nimport {Schema, Field} from '@loaders.gl/schema';\nimport type {DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n  return metadataMap;\n}\n", "/* eslint-disable camelcase */\n\nimport type {TypedArray, MeshAttribute, MeshGeometry} from '@loaders.gl/schema';\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  DracoMesh,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {getDracoSchema} from './utils/get-draco-schema';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMesh {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMesh = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshGeometry {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n", "// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_DECODER_VERSION = '1.5.5';\nconst DRACO_ENCODER_VERSION = '1.4.1';\n\nconst STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;\n\nconst DRACO_JS_DECODER_URL = `${STATIC_DECODER_URL}/draco_decoder.js`;\nconst DRACO_WASM_WRAPPER_URL = `${STATIC_DECODER_URL}/draco_wasm_wrapper.js`;\nconst DRACO_WASM_DECODER_URL = `${STATIC_DECODER_URL}/draco_decoder.wasm`;\n\nconst DRACO_ENCODER_URL = `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/draco_encoder.js`;\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise =\n      loadDecoderPromise ||\n      modules.draco3d.createDecoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise =\n      loadEncoderPromise ||\n      modules.draco3d.createEncoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options),\n        await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n", "import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {DracoMesh, DracoLoaderData} from './lib/draco-types';\nimport type {DracoLoaderOptions} from './draco-loader';\nimport {DracoLoader as DracoWorkerLoader} from './draco-loader';\nimport DracoParser from './lib/draco-parser';\nimport {loadDracoDecoderModule} from './lib/draco-module-loader';\nimport {VERSION} from './lib/utils/version';\nimport {isBrowser} from '@loaders.gl/worker-utils';\n\n// Draco data types\n\nexport type {DracoMesh, DracoLoaderData};\n\n// Draco Writer\n\nexport type {DracoWriterOptions} from './draco-writer';\nexport {DracoWriter} from './draco-writer';\n\n/**\n * Browser worker doesn't work because of issue during \"draco_encoder.js\" loading.\n * Refused to execute script from 'https://raw.githubusercontent.com/google/draco/1.4.1/javascript/draco_encoder.js' because its MIME type ('') is not executable.\n */\nexport const DracoWriterWorker = {\n  id: isBrowser ? 'draco-writer' : 'draco-writer-nodejs',\n  name: 'Draco compressed geometry writer',\n  module: 'draco',\n  version: VERSION,\n  worker: true,\n  options: {\n    draco: {},\n    source: null\n  }\n};\n\n// Draco Loader\n\nexport type {DracoLoaderOptions};\nexport {DracoWorkerLoader};\n\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  ...DracoWorkerLoader,\n  parse\n};\n\nasync function parse(arrayBuffer: ArrayBuffer, options?: DracoLoaderOptions): Promise<DracoMesh> {\n  const {draco} = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options?.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckDracoLoader: LoaderWithParser = DracoLoader;\n", "// import type {TypedArray} from '../types/loader-utils';\nimport type {GLTFAccessor} from '../types/gltf-types';\n// TODO - remove\nimport {getAccessorTypeFromSize, getComponentTypeFromArray} from './gltf-utils';\n\n// Returns a fresh attributes object with glTF-standardized attributes names\n// Attributes that cannot be identified will not be included\n// Removes `indices` if present, as it should be stored separately from the attributes\nexport function getGLTFAccessors(attributes): {[key: string]: GLTFAccessor} {\n  const accessors = {};\n  for (const name in attributes) {\n    const attribute = attributes[name];\n    if (name !== 'indices') {\n      const glTFAccessor = getGLTFAccessor(attribute);\n      accessors[name] = glTFAccessor;\n    }\n  }\n  return accessors;\n}\n\n// Fix up a single accessor.\n// Input: typed array or a partial accessor object\n// Return: accessor object\nexport function getGLTFAccessor(attribute) {\n  const {buffer, size, count} = getAccessorData(attribute);\n\n  const glTFAccessor: GLTFAccessor = {\n    // glTF Accessor values\n    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)\n    // bufferView: null,\n    // TODO: Deprecate `value` in favor of bufferView?\n    // @ts-ignore\n    value: buffer,\n    size, // Decoded `type` (e.g. SCALAR)\n\n    byteOffset: 0,\n    count,\n    type: getAccessorTypeFromSize(size),\n    componentType: getComponentTypeFromArray(buffer)\n  };\n\n  return glTFAccessor;\n}\n\n// export function getGLTFAttribute(data, gltfAttributeName): GLTFAccessor {\n//   return data.attributes[data.glTFAttributeMap[gltfAttributeName]];\n// }\n\nfunction getAccessorData(attribute) {\n  let buffer = attribute;\n  let size = 1;\n  let count = 0;\n\n  if (attribute && attribute.value) {\n    buffer = attribute.value;\n    size = attribute.size || 1;\n  }\n\n  if (buffer) {\n    if (!ArrayBuffer.isView(buffer)) {\n      buffer = toTypedArray(buffer, Float32Array);\n    }\n    count = buffer.length / size;\n  }\n\n  return {buffer, size, count};\n}\n\n// Convert non-typed arrays to arrays of specified format\nfunction toTypedArray(array, ArrayType, convertTypedArrays = false) {\n  if (!array) {\n    return null;\n  }\n  if (Array.isArray(array)) {\n    return new ArrayType(array);\n  }\n  if (convertTypedArrays && !(array instanceof ArrayType)) {\n    return new ArrayType(array);\n  }\n  return array;\n}\n", "/**\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md\n */\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport type {GLTFMeshPrimitive, GLTFWithBuffers} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BYTES, COMPONENTS} from '../gltf-utils/gltf-constants';\nimport {\n  Accessor,\n  BufferView,\n  MaterialNormalTextureInfo,\n  MaterialOcclusionTextureInfo,\n  TextureInfo as GLTFTextureInfo\n} from '../types/gltf-json-schema';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\n/** Extension name */\nconst EXT_MESHOPT_TRANSFORM = 'KHR_texture_transform';\n\nexport const name = EXT_MESHOPT_TRANSFORM;\n\nconst scratchVector = new Vector3();\nconst scratchRotationMatrix = new Matrix3();\nconst scratchScaleMatrix = new Matrix3();\n\n/** Extension textureInfo https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\ntype TextureInfo = {\n  /** The offset of the UV coordinate origin as a factor of the texture dimensions. */\n  offset?: [number, number];\n  /** Rotate the UVs by this many radians counter-clockwise around the origin. This is equivalent to a similar rotation of the image clockwise. */\n  rotation?: number;\n  /** The scale factor applied to the components of the UV coordinates. */\n  scale?: [number, number];\n  /** Overrides the textureInfo texCoord value if supplied, and if this extension is supported. */\n  texCoord?: number;\n};\n/** Intersection of all GLTF textures */\ntype CompoundGLTFTextureInfo = GLTFTextureInfo &\n  MaterialNormalTextureInfo &\n  MaterialOcclusionTextureInfo;\n/** Parameters for TEXCOORD transformation */\ntype TransformParameters = {\n  /** Original texCoord value https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#_textureinfo_texcoord */\n  originalTexCoord: number;\n  /** New texCoord value from extension https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\n  texCoord: number;\n  /** Transformation matrix */\n  matrix: Matrix3;\n};\n\n/**\n * The extension entry to process the transformation\n * @param gltfData gltf buffers and json\n * @param options GLTFLoader options\n */\nexport async function decode(gltfData: GLTFWithBuffers, options: GLTFLoaderOptions) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);\n  if (!extension) {\n    return;\n  }\n  const materials = gltfData.json.materials || [];\n  for (let i = 0; i < materials.length; i++) {\n    transformTexCoords(i, gltfData);\n  }\n}\n\n/**\n * Transform TEXCOORD by material\n * @param materialIndex processing material index\n * @param gltfData gltf buffers and json\n */\nfunction transformTexCoords(materialIndex: number, gltfData: GLTFWithBuffers): void {\n  // Save processed texCoords in order no to process the same twice\n  const processedTexCoords: [number, number][] = [];\n  const material = gltfData.json.materials?.[materialIndex];\n  const baseColorTexture = material?.pbrMetallicRoughness?.baseColorTexture;\n  if (baseColorTexture) {\n    transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);\n  }\n  const emisiveTexture = material?.emissiveTexture;\n  if (emisiveTexture) {\n    transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);\n  }\n  const normalTexture = material?.normalTexture;\n  if (normalTexture) {\n    transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);\n  }\n  const occlusionTexture = material?.occlusionTexture;\n  if (occlusionTexture) {\n    transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);\n  }\n  const metallicRoughnessTexture = material?.pbrMetallicRoughness?.metallicRoughnessTexture;\n  if (metallicRoughnessTexture) {\n    transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);\n  }\n}\n\n/**\n * Transform primitives of the particular material\n * @param gltfData gltf data\n * @param materialIndex primitives with this material will be transformed\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n */\nfunction transformPrimitives(\n  gltfData: GLTFWithBuffers,\n  materialIndex: number,\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n) {\n  const transformParameters = getTransformParameters(texture, processedTexCoords);\n  if (!transformParameters) {\n    return;\n  }\n  const meshes = gltfData.json.meshes || [];\n  for (const mesh of meshes) {\n    for (const primitive of mesh.primitives) {\n      const material = primitive.material;\n      if (Number.isFinite(material) && materialIndex === material) {\n        transformPrimitive(gltfData, primitive, transformParameters);\n      }\n    }\n  }\n}\n\n/**\n * Get parameters for TEXCOORD transformation\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n * @returns texCoord couple and transformation matrix\n */\nfunction getTransformParameters(\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n): TransformParameters | null {\n  const textureInfo = texture.extensions?.[EXT_MESHOPT_TRANSFORM];\n  const {texCoord: originalTexCoord = 0} = texture;\n  // If texCoord is not set in the extension, original attribute data will be replaced\n  const {texCoord = originalTexCoord} = textureInfo;\n  // Make sure that couple [originalTexCoord, extensionTexCoord] is not processed twice\n  const isProcessed =\n    processedTexCoords.findIndex(\n      ([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord\n    ) !== -1;\n  if (!isProcessed) {\n    const matrix = makeTransformationMatrix(textureInfo);\n    if (originalTexCoord !== texCoord) {\n      texture.texCoord = texCoord;\n    }\n    processedTexCoords.push([originalTexCoord, texCoord]);\n    return {originalTexCoord, texCoord, matrix};\n  }\n  return null;\n}\n\n/**\n * Transform `TEXCOORD_0` attribute in the primitive\n * @param gltfData gltf data\n * @param primitive primitive object\n * @param transformParameters texCoord couple and transformation matrix\n */\nfunction transformPrimitive(\n  gltfData: GLTFWithBuffers,\n  primitive: GLTFMeshPrimitive,\n  transformParameters: TransformParameters\n) {\n  const {originalTexCoord, texCoord, matrix} = transformParameters;\n  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];\n  if (Number.isFinite(texCoordAccessor)) {\n    // Get accessor of the `TEXCOORD_0` attribute\n    const accessor = gltfData.json.accessors?.[texCoordAccessor];\n    if (accessor && accessor.bufferView) {\n      // Get `bufferView` of the `accessor`\n      const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];\n      if (bufferView) {\n        // Get `arrayBuffer` the `bufferView` look at\n        const {arrayBuffer, byteOffset: bufferByteOffset} = gltfData.buffers[bufferView.buffer];\n        // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n        const byteOffset =\n          (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n        // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n        const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n        // Number of bytes each component occupies\n        const bytes = BYTES[accessor.componentType];\n        // Number of components. For the `TEXCOORD_0` with `VEC2` type, it must return 2\n        const components = COMPONENTS[accessor.type];\n        // Multiplier to calculate the address of the `TEXCOORD_0` element in the arrayBuffer\n        const elementAddressScale = bufferView.byteStride || bytes * components;\n        // Data transform to Float32Array\n        const result = new Float32Array(length);\n        for (let i = 0; i < accessor.count; i++) {\n          // Take [u, v] couple from the arrayBuffer\n          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n          // Set and transform Vector3 per https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#overview\n          scratchVector.set(uv[0], uv[1], 1);\n          scratchVector.transformByMatrix3(matrix);\n          // Save result in Float32Array\n          result.set([scratchVector[0], scratchVector[1]], i * components);\n        }\n        // If texCoord the same, replace gltf structural data\n        if (originalTexCoord === texCoord) {\n          updateGltf(accessor, bufferView, gltfData.buffers, result);\n        } else {\n          // If texCoord change, create new attribute\n          createAttribute(texCoord, accessor, primitive, gltfData, result);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Update GLTF structural objects with new data as we create new `Float32Array` for `TEXCOORD_0`.\n * @param accessor accessor to change\n * @param bufferView bufferView to change\n * @param buffers binary buffers\n * @param newTexcoordArray typed array with data after transformation\n */\nfunction updateGltf(\n  accessor: Accessor,\n  bufferView: BufferView,\n  buffers: {arrayBuffer: ArrayBuffer; byteOffset: number; byteLength: number}[],\n  newTexCoordArray: Float32Array\n): void {\n  accessor.componentType = 5126;\n  buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  bufferView.buffer = buffers.length - 1;\n  bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n  bufferView.byteOffset = 0;\n  delete bufferView.byteStride;\n}\n\n/**\n *\n * @param newTexCoord new `texCoord` value\n * @param originalAccessor original accessor object, that store data before transformation\n * @param primitive primitive object\n * @param gltfData gltf data\n * @param newTexCoordArray typed array with data after transformation\n * @returns\n */\nfunction createAttribute(\n  newTexCoord: number,\n  originalAccessor: Accessor,\n  primitive: GLTFMeshPrimitive,\n  gltfData: GLTFWithBuffers,\n  newTexCoordArray: Float32Array\n) {\n  gltfData.buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  const bufferViews = gltfData.json.bufferViews;\n  if (!bufferViews) {\n    return;\n  }\n  bufferViews.push({\n    buffer: gltfData.buffers.length - 1,\n    byteLength: newTexCoordArray.buffer.byteLength,\n    byteOffset: 0\n  });\n  const accessors = gltfData.json.accessors;\n  if (!accessors) {\n    return;\n  }\n  accessors.push({\n    bufferView: bufferViews?.length - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: originalAccessor.count,\n    type: 'VEC2'\n  });\n  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;\n}\n\n/**\n * Construct transformation matrix from the extension data (transition, rotation, scale)\n * @param extensionData extension data\n * @returns transformation matrix\n */\nfunction makeTransformationMatrix(extensionData: TextureInfo): Matrix3 {\n  const {offset = [0, 0], rotation = 0, scale = [1, 1]} = extensionData;\n  const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n  const rotationMatirx = scratchRotationMatrix.set(\n    Math.cos(rotation),\n    Math.sin(rotation),\n    0,\n    -Math.sin(rotation),\n    Math.cos(rotation),\n    0,\n    0,\n    0,\n    1\n  );\n  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n  return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);\n}\n", "export const COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\n// ENUM LOOKUP\n\nexport function getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nexport function getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nexport function getGLEnumFromSamplerParameter(parameter) {\n  const GL_TEXTURE_MAG_FILTER = 0x2800;\n  const GL_TEXTURE_MIN_FILTER = 0x2801;\n  const GL_TEXTURE_WRAP_S = 0x2802;\n  const GL_TEXTURE_WRAP_T = 0x2803;\n\n  const PARAMETER_MAP = {\n    magFilter: GL_TEXTURE_MAG_FILTER,\n    minFilter: GL_TEXTURE_MIN_FILTER,\n    wrapS: GL_TEXTURE_WRAP_S,\n    wrapT: GL_TEXTURE_WRAP_T\n  };\n\n  return PARAMETER_MAP[parameter];\n}\n", "// GLTF EXTENSION: KHR_lights_punctual\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport {assert} from '../../utils/assert';\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\n\nexport const name = KHR_LIGHTS_PUNCTUAL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Move the light array out of the extension and remove the extension\n  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);\n  if (extension) {\n    // @ts-ignore\n    gltfScenegraph.json.lights = extension.lights;\n    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);\n  }\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const node of json.nodes || []) {\n    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n    if (nodeExtension) {\n      // @ts-ignore\n      node.light = nodeExtension.light;\n    }\n    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n  }\n}\n\n// Move the light ar ray out of the extension and remove the extension\nexport async function encode(gltfData): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // @ts-ignore\n  if (json.lights) {\n    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);\n    // @ts-ignore\n    assert(!extension.lights);\n    // @ts-ignore\n    extension.lights = json.lights;\n    // @ts-ignore\n    delete json.lights;\n  }\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.json.lights) {\n    // @ts-ignore\n    for (const light of gltfScenegraph.json.lights) {\n      const node = light.node;\n      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);\n    }\n    // @ts-ignore\n    delete gltfScenegraph.json.lights;\n  }\n}\n", "// GLTF EXTENSION: KHR_materials_unlit\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\n\nexport const name = KHR_MATERIALS_UNLIT;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n    if (extension) {\n      // @ts-ignore TODO\n      material.unlit = true;\n    }\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n\n  // Remove the top-level extension\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n}\n\nexport function encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      // @ts-ignore\n      if (material.unlit) {\n        // @ts-ignore\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n", "// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\nexport const name = KHR_TECHNIQUES_WEBGL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    // Remove the top-level extension\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n", "/* eslint-disable camelcase */\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\nimport {\n  ClassProperty,\n  EXT_feature_metadata_class_object,\n  EXT_feature_metadata_feature_table,\n  FeatureTableProperty,\n  GLTF_EXT_feature_metadata\n} from '../../types/gltf-json-schema';\n\n/** Extension name */\nconst EXT_FEATURE_METADATA = 'EXT_feature_metadata';\n\nexport const name = EXT_FEATURE_METADATA;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  decodeExtFeatureMetadata(scenegraph);\n}\n\n/**\n * Decodes feature metadata from extension\n * @param scenegraph\n */\nfunction decodeExtFeatureMetadata(scenegraph: GLTFScenegraph): void {\n  const extension: GLTF_EXT_feature_metadata | null = scenegraph.getExtension(EXT_FEATURE_METADATA);\n  const schemaClasses = extension?.schema?.classes;\n  const featureTables = extension?.featureTables;\n  const featureTextures = extension?.featureTextures;\n\n  if (featureTextures) {\n    /*\n     * TODO add support for featureTextures\n     * Spec - https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata#feature-textures\n     */\n    // eslint-disable-next-line no-console\n    console.warn('featureTextures is not yet supported in the \"EXT_feature_metadata\" extension.');\n  }\n\n  if (schemaClasses && featureTables) {\n    for (const schemaName in schemaClasses) {\n      const schemaClass = schemaClasses[schemaName];\n      const featureTable = findFeatureTableByName(featureTables, schemaName);\n\n      if (featureTable) {\n        handleFeatureTableProperties(scenegraph, featureTable, schemaClass);\n      }\n    }\n  }\n}\n\n/**\n * Navigate throw all properies in feature table and gets properties data.\n * @param scenegraph\n * @param featureTable\n * @param schemaClass\n */\nfunction handleFeatureTableProperties(\n  scenegraph: GLTFScenegraph,\n  featureTable: EXT_feature_metadata_feature_table,\n  schemaClass: EXT_feature_metadata_class_object\n): void {\n  for (const propertyName in schemaClass.properties) {\n    const schemaProperty = schemaClass.properties[propertyName];\n    const featureTableProperty = featureTable?.properties?.[propertyName];\n    const numberOfFeatures = featureTable.count;\n\n    if (featureTableProperty) {\n      const data = getPropertyDataFromBinarySource(\n        scenegraph,\n        schemaProperty,\n        numberOfFeatures,\n        featureTableProperty\n      );\n      featureTableProperty.data = data;\n    }\n  }\n}\n\n/**\n * Decode properties from binary sourse based on property type.\n * @param scenegraph\n * @param schemaProperty\n * @param numberOfFeatures\n * @param featureTableProperty\n */\nfunction getPropertyDataFromBinarySource(\n  scenegraph: GLTFScenegraph,\n  schemaProperty: ClassProperty,\n  numberOfFeatures: number,\n  featureTableProperty: FeatureTableProperty\n): Uint8Array | string[] {\n  const bufferView = featureTableProperty.bufferView;\n  // TODO think maybe we shouldn't get data only in Uint8Array format.\n  let data: Uint8Array | string[] = scenegraph.getTypedArrayForBufferView(bufferView);\n\n  switch (schemaProperty.type) {\n    case 'STRING': {\n      // stringOffsetBufferView should be available for string type.\n      const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView!;\n      const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);\n      data = getStringAttributes(data, offsetsData, numberOfFeatures);\n      break;\n    }\n    default:\n  }\n\n  return data;\n}\n\n/**\n * Find the feature table by class name.\n * @param featureTables\n * @param schemaClassName\n */\nfunction findFeatureTableByName(\n  featureTables: {[key: string]: EXT_feature_metadata_feature_table},\n  schemaClassName: string\n): EXT_feature_metadata_feature_table | null {\n  for (const featureTableName in featureTables) {\n    const featureTable = featureTables[featureTableName];\n\n    if (featureTable.class === schemaClassName) {\n      return featureTable;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Getting string attributes from binary data.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#strings\n * @param data\n * @param offsetsData\n * @param stringsCount\n */\nfunction getStringAttributes(\n  data: Uint8Array,\n  offsetsData: Uint8Array,\n  stringsCount: number\n): string[] {\n  const stringsArray: string[] = [];\n  const textDecoder = new TextDecoder('utf8');\n\n  let stringOffset = 0;\n  const bytesPerStringSize = 4;\n\n  for (let index = 0; index < stringsCount; index++) {\n    // TODO check if it is multiplication on bytesPerStringSize is valid operation?\n    const stringByteSize =\n      offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];\n    const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);\n    const stringAttribute = textDecoder.decode(stringData);\n\n    stringsArray.push(stringAttribute);\n    stringOffset += stringByteSize;\n  }\n\n  return stringsArray;\n}\n", "/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (decode only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 Khronos extensions (decode/encode)\nimport * as EXT_meshopt_compression from '../extensions/EXT_meshopt_compression';\nimport * as EXT_texture_webp from '../extensions/EXT_texture_webp';\nimport * as KHR_texture_basisu from '../extensions/KHR_texture_basisu';\nimport * as KHR_draco_mesh_compression from '../extensions/KHR_draco_mesh_compression';\nimport * as KHR_texture_transform from '../extensions/KHR_texture_transform';\n\n// Deprecated. These should be handled by rendering library (e.g. luma.gl), not the loader.\nimport * as KHR_lights_punctual from '../extensions/deprecated/KHR_lights_punctual';\nimport * as KHR_materials_unlit from '../extensions/deprecated/KHR_materials_unlit';\nimport * as KHR_techniques_webgl from '../extensions/deprecated/KHR_techniques_webgl';\nimport * as EXT_feature_metadata from '../extensions/deprecated/EXT_feature_metadata';\n\n// Vendor extensions\n\ntype GLTFExtensionPlugin = {\n  name: string;\n  preprocess?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => void;\n  decode?: (\n    gltfData: {\n      json: GLTF;\n      buffers: {arrayBuffer: ArrayBuffer; byteOffset: number; byteLength: number}[];\n    },\n    options: GLTFLoaderOptions,\n    context\n  ) => Promise<void>;\n  encode?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: GLTFExtensionPlugin[] = [\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  EXT_meshopt_compression,\n  EXT_texture_webp,\n  // Basisu should come after webp, we want basisu to be preferred if both are provided\n  KHR_texture_basisu,\n  KHR_draco_mesh_compression,\n  KHR_lights_punctual,\n  KHR_materials_unlit,\n  KHR_techniques_webgl,\n  KHR_texture_transform,\n  EXT_feature_metadata\n];\n\n/** Call before any resource loading starts */\nexport function preprocessExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    extension.preprocess?.(gltf, options, context);\n  }\n}\n\n/** Call after resource loading */\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    // Note: We decode async extensions sequentially, this might not be necessary\n    // Currently we only have Draco, but when we add Basis we may revisit\n    await extension.decode?.(gltf, options, context);\n  }\n}\n\nfunction useExtension(extensionName: string, options: GLTFLoaderOptions) {\n  const excludes = options?.gltf?.excludeExtensions || {};\n  const exclude = extensionName in excludes && !excludes[extensionName];\n  return !exclude;\n}\n", "// GLTF 1.0 EXTENSION: KHR_binary_glTF\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n/* eslint-disable camelcase */\n\nimport type {GLTF, GLTF_KHR_binary_glTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\nconst KHR_BINARY_GLTF = 'KHR_binary_glTF';\n\n/** Extension name */\nexport const name = KHR_BINARY_GLTF;\n\nexport function preprocess(gltfData: {json: GLTF}): void {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Note: json.buffers.binary_glTF also needs to be replaced\n  // This is currently done during gltf normalization\n\n  // Image and shader nodes can have the extension\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/image.KHR_binary_glTF.schema.json\n  for (const image of json.images || []) {\n    const extension = gltfScenegraph.getObjectExtension<GLTF_KHR_binary_glTF>(\n      image,\n      KHR_BINARY_GLTF\n    );\n    // The data in the extension is valid as glTF 2.0 data inside the object, so just copy it in\n    if (extension) {\n      Object.assign(image, extension);\n    }\n    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);\n  }\n\n  // TODO shaders - At least traverse and throw error if used?\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/shader.KHR_binary_glTF.schema.json\n\n  // glTF v1 one files have a partially formed URI field that is not expected in (and causes problems in) 2.0\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  // Remove the top-level extension as it has now been processed\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n\n// KHR_binary_gltf is a 1.0 extension that is supported natively by 2.0\n// export function encode() {\n//   throw new Error(KHR_BINARY_GLTF);\n// }\n", "/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\n\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\n\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  idToIndexMap = {\n    animations: {},\n    accessors: {},\n    buffers: {},\n    bufferViews: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    samplers: {},\n    scenes: {},\n    skins: {},\n    textures: {}\n  };\n\n  json;\n\n  // constructor() {}\n\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param gltf - object with json and binChunks\n   * @param options\n   * @param options normalize Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    // TODO can this be handled by standard extension processing instead of called explicitly?\n    KHR_binary_glTF.preprocess(gltf);\n\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    // Convert any index references that are not using array names\n\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {attributes, indices, material} = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n\n  /**\n   * Update material (set pbrMetallicRoughness)\n   * @param {*} json\n   */\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n\n      const textureId =\n        material.values?.tex || material.values?.texture2d_0 || material.values?.diffuseTex;\n      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {index: textureIndex};\n      }\n    }\n  }\n}\n\nexport function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n", "import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BufferView} from '../types/gltf-json-schema';\nimport {BufferView as BufferViewPostprocessed} from '../types/gltf-postprocessed-schema';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  baseUri: string = '';\n  json: Record<string, any> = {};\n  buffers: [] = [];\n  images: [] = [];\n\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(\n          buffer,\n          byteOffset,\n          accessor.bufferView.byteStride,\n          accessor.bytesPerElement,\n          accessor.count\n        );\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n\n    return accessor;\n  }\n\n  /**\n   * Take values of particular accessor from interleaved buffer\n   * various parts of the buffer\n   * @param buffer\n   * @param byteOffset\n   * @param byteStride\n   * @param bytesPerElement\n   * @param count\n   * @returns\n   */\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(\n        new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)),\n        i * bytesPerElement\n      );\n    }\n    return result.buffer;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView: BufferView, index: number): BufferViewPostprocessed {\n    // bufferView = {...bufferView};\n    const bufferIndex = bufferView.buffer;\n    const result: BufferViewPostprocessed = {\n      id: `bufferView-${index}`,\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n\n    // @ts-expect-error\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    // @ts-expect-error\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options?) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n", "/* eslint-disable camelcase, max-statements */\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\nimport type {GLB} from '../types/glb-types';\nimport {padToNBytes, assert} from '@loaders.gl/loader-utils';\n\nexport type GLBParseOptions = {\n  magic?: number;\n  strict?: boolean;\n};\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files\n\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n\nconst LE = true; // Binary GLTF is little endian.\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n): boolean {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\nexport default function parseGLBSync(\n  glb: GLB,\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  // Compare format with GLBLoader documentation\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of binary file\n\n  Object.assign(glb, {\n    // Put less important stuff in a header, to avoid clutter\n    header: {\n      byteOffset, // Byte offset into the initial arrayBuffer\n      byteLength,\n      hasBinChunk: false\n    },\n\n    type,\n    version,\n\n    json: {},\n    binChunks: []\n  } as GLB);\n\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      // eslint-disable-next-line\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      // eslint-disable-next-line\n      return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports v1 and v2.`);\n  }\n}\n\nfunction parseGLBV1(glb: GLB, dataView: DataView, byteOffset: number): number {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  // No need to call the function padToBytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n\n  return byteOffset;\n}\n\nfunction parseGLBV2(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n): number {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n) {\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n\n  return byteOffset;\n}\n\n// Parse a GLB JSON chunk\nfunction parseJSONChunk(glb: GLB, dataView: DataView, byteOffset: number, chunkLength: number) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  return padToNBytes(chunkLength, 4);\n}\n\n// Parse a GLB BIN chunk\nfunction parseBINChunk(glb: GLB, dataView, byteOffset, chunkLength) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n\n  return padToNBytes(chunkLength, 4);\n}\n", "/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {BasisLoader, selectSupportedBasisFormat} from '@loaders.gl/textures';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport type {GLB} from '../types/glb-types';\nimport type {GLTFWithBuffers} from '../types/gltf-types';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {preprocessExtensions, decodeExtensions} from '../api/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  normalize?: boolean;\n  loadImages?: boolean;\n  loadBuffers?: boolean;\n  decompressMeshes?: boolean;\n  postProcess?: boolean;\n  excludeExtensions?: string[];\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf: GLTFWithBuffers,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  preprocessExtensions(gltf, options, context);\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  // TODO\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    } else if (gltf.buffers[i] === null) {\n      gltf.buffers[i] = {\n        arrayBuffer: new ArrayBuffer(buffer.byteLength),\n        byteOffset: 0,\n        byteLength: buffer.byteLength\n      };\n    }\n  }\n}\n\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  const imageIndices = getReferencesImageIndices(gltf);\n\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf: GLTFWithBuffers): number[] {\n  const imageIndices = new Set<number>();\n\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(\n  gltf: GLTFWithBuffers,\n  image,\n  index: number,\n  options,\n  context: LoaderContext\n) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri && !image.hasOwnProperty('bufferView')) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n    image.bufferView = {\n      data: arrayBuffer\n    };\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  let parsedImage = await parse(\n    arrayBuffer,\n    [ImageLoader, BasisLoader],\n    {mimeType: image.mimeType, basis: options.basis || {format: selectSupportedBasisFormat()}},\n    context\n  );\n\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage[0]\n    };\n  }\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  // Store the loaded image\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n", "import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoLoaderOptions} from '@loaders.gl/draco';\nimport {VERSION} from './lib/utils/version';\nimport type {ImageLoaderOptions} from '@loaders.gl/images';\nimport type {TextureLoaderOptions} from '@loaders.gl/textures';\nimport type {GLTFParseOptions} from './lib/parsers/parse-gltf';\nimport type {GLTFWithBuffers} from './lib/types/gltf-types';\nimport {parseGLTF} from './lib/parsers/parse-gltf';\nimport {GLBLoaderOptions} from './glb-loader';\n\n/**\n * GLTF loader options\n */\nexport type GLTFLoaderOptions = LoaderOptions &\n  ImageLoaderOptions &\n  TextureLoaderOptions &\n  GLBLoaderOptions &\n  DracoLoaderOptions & {\n    gltf?: GLTFParseOptions;\n  };\n\n/**\n * GLTF loader\n */\nexport const GLTFLoader: LoaderWithParser = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['gltf', 'glb'],\n  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],\n\n  text: true,\n  binary: true,\n  tests: ['glTF'],\n  parse,\n\n  options: {\n    gltf: {\n      normalize: true, // Normalize glTF v1 to glTF v2 format (not yet stable)\n      loadBuffers: true, // Fetch any linked .BIN buffers, decode base64\n      loadImages: true, // Create image objects\n      decompressMeshes: true, // Decompress Draco encoded meshes\n      postProcess: true // Postprocess glTF and return json structure directly\n    },\n\n    // common?\n    log: console // eslint-disable-line\n  },\n  deprecatedOptions: {\n    fetchImages: 'gltf.loadImages',\n    createImages: 'gltf.loadImages',\n    decompress: 'gltf.decompressMeshes',\n    postProcess: 'gltf.postProcess',\n    gltf: {\n      decompress: 'gltf.decompressMeshes'\n    }\n  }\n};\n\nexport async function parse(arrayBuffer, options: GLTFLoaderOptions = {}, context) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...GLTFLoader.options, ...options};\n  // @ts-ignore\n  options.gltf = {...GLTFLoader.options.gltf, ...options.gltf};\n\n  const {byteOffset = 0} = options;\n  const gltf = {};\n  return await parseGLTF(gltf as GLTFWithBuffers, arrayBuffer, byteOffset, options, context);\n}\n", "/* global requestAnimationFrame */\nimport type {GroupNode, ModelNode} from '@luma.gl/experimental';\n\nexport async function waitForGLTFAssets(gltfObjects: {scenes: GroupNode[]}): Promise<void> {\n  const remaining: any[] = [];\n\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse((model: ModelNode) => {\n      Object.values(model.model.getUniforms()).forEach((uniform: any) => {\n        if (uniform.loaded === false) {\n          remaining.push(uniform);\n        }\n      });\n    });\n  });\n\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition: () => boolean): Promise<void> {\n  while (condition()) {\n    await new Promise(resolve => requestAnimationFrame(resolve));\n  }\n}\n", "export default `\\\n#version 300 es\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin mat3 instanceModelMatrix;\nin vec3 instanceTranslation;\n\n// Uniforms\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\n\n// Attributes\nin vec4 POSITION;\n\n#ifdef HAS_UV\n  in vec2 TEXCOORD_0;\n#endif\n\n#ifdef MODULE_PBR\n  #ifdef HAS_NORMALS\n    in vec4 NORMAL;\n  #endif\n#endif\n\n// Varying\nout vec4 vColor;\n\n// MODULE_PBR contains all the varying definitions needed\n#ifndef MODULE_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\n\n// Main\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(MODULE_PBR)\n    vTEXCOORD_0 = TEXCOORD_0;\n    geometry.uv = vTEXCOORD_0;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef MODULE_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(sizeScale);\n  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef MODULE_PBR\n    // set PBR data\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = TEXCOORD_0;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "export default `\\\n#version 300 es\n\n// Uniforms\nuniform float opacity;\n\n// Varying\nin vec4 vColor;\n\nout vec4 fragmentColor;\n\n// MODULE_PBR contains all the varying definitions needed\n#ifndef MODULE_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D u_BaseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef MODULE_PBR\n    fragmentColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragmentColor = vColor;\n    #endif\n  #endif\n\n  fragmentColor.a *= opacity;\n  DECKGL_FILTER_COLOR(fragmentColor, geometry);\n}\n`;\n", "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, picking, log} from '@deck.gl/core';\nimport {isWebGL2} from '@luma.gl/core';\nimport {pbr} from '@luma.gl/shadertools';\nimport {\n  ScenegraphNode,\n  GroupNode,\n  GLTFAnimator,\n  GLTFEnvironment,\n  createGLTFObjects\n} from '@luma.gl/experimental';\nimport GL from '@luma.gl/constants';\nimport {GLTFLoader} from '@loaders.gl/gltf';\nimport {waitForGLTFAssets} from './gltf-utils';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport vs from './scenegraph-layer-vertex.glsl';\nimport fs from './scenegraph-layer-fragment.glsl';\n\nimport type {\n  UpdateParameters,\n  LayerContext,\n  LayerProps,\n  LayerDataSource,\n  Position,\n  Color,\n  Accessor,\n  DefaultProps\n} from '@deck.gl/core';\n\nconst DEFAULT_COLOR: [number, number, number, number] = [255, 255, 255, 255];\n\nexport type ScenegraphLayerProps<DataT = any> = _ScenegraphLayerProps<DataT> & LayerProps;\n\ntype _ScenegraphLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  // TODO - define in luma.gl\n  /**\n   * A url for a glTF model or scenegraph loaded via a [scenegraph loader](https://loaders.gl/docs/specifications/category-scenegraph)\n   */\n  scenegraph: any;\n  /**\n   * Create a luma.gl GroupNode from the resolved scenegraph prop\n   */\n  getScene?: (\n    scenegraph: any,\n    context: {gl: WebGLRenderingContext; layer: ScenegraphLayer<DataT>}\n  ) => GroupNode;\n  /**\n   * Create a luma.gl GLTFAnimator from the resolved scenegraph prop\n   */\n  getAnimator?: (\n    scenegraph: any,\n    context: {gl: WebGLRenderingContext; layer: ScenegraphLayer<DataT>}\n  ) => GLTFAnimator;\n  /**\n   * (Experimental) animation configurations. Requires `_animate` on deck object.\n   */\n  _animations?: {\n    [name: number | string | '*']: {\n      /** If the animation is playing */\n      playing?: boolean;\n      /** Start time of the animation, default `0` */\n      startTime?: number;\n      /** Speed multiplier of the animation, default `1` */\n      speed?: number;\n    };\n  } | null;\n  /**\n   * (Experimental) lighting mode\n   * @default 'flat'\n   */\n  _lighting?: 'flat' | 'pbr';\n  /**\n   * (Experimental) lighting environment. Requires `_lighting` to be `'pbr'`.\n   */\n  _imageBasedLightingEnvironment?:\n    | null\n    | GLTFEnvironment\n    | ((context: {gl: WebGLRenderingContext; layer: ScenegraphLayer<DataT>}) => GLTFEnvironment);\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * @default [255, 255, 255, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The minimum size in pixels for one unit of the scene.\n   * @default 0\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels for one unit of the scene.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  sizeMaxPixels?: number;\n};\n\nconst defaultProps: DefaultProps<ScenegraphLayerProps> = {\n  scenegraph: {type: 'object', value: null, async: true},\n  getScene: gltf => {\n    if (gltf && gltf.scenes) {\n      // gltf post processor replaces `gltf.scene` number with the scene `object`\n      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n    }\n    return gltf;\n  },\n  getAnimator: scenegraph => scenegraph && scenegraph.animator,\n  _animations: null,\n\n  sizeScale: {type: 'number', value: 1, min: 0},\n  sizeMinPixels: {type: 'number', min: 0, value: 0},\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // flat or pbr\n  _lighting: 'flat',\n  // _lighting must be pbr for this to work\n  _imageBasedLightingEnvironment: null,\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  loaders: [GLTFLoader]\n};\n\n/** Render a number of instances of a complete glTF scenegraph. */\nexport default class ScenegraphLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ScenegraphLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'ScenegraphLayer';\n\n  state!: {\n    scenegraph: GroupNode;\n    animator: GLTFAnimator;\n    attributesAvailable?: boolean;\n  };\n\n  getShaders() {\n    const modules = [project32, picking];\n\n    if (this.props._lighting === 'pbr') {\n      modules.push(pbr);\n    }\n\n    return {vs, fs, modules};\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined for primitive layers\n    attributeManager!.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        accessor: 'getPosition',\n        transition: true\n      },\n      instanceColors: {\n        type: GL.UNSIGNED_BYTE,\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        normalized: true,\n        defaultValue: DEFAULT_COLOR,\n        transition: true\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps} = params;\n\n    if (props.scenegraph !== oldProps.scenegraph) {\n      this._updateScenegraph();\n    } else if (props._animations !== oldProps._animations) {\n      this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    this._deleteScenegraph();\n  }\n\n  private _updateScenegraph(): void {\n    const props = this.props;\n    const {gl} = this.context;\n    let scenegraphData: any = null;\n    if (props.scenegraph instanceof ScenegraphNode) {\n      // Signature 1: props.scenegraph is a proper luma.gl Scenegraph\n      scenegraphData = {scenes: [props.scenegraph]};\n    } else if (props.scenegraph && !props.scenegraph.gltf) {\n      // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function\n      const gltf = props.scenegraph;\n      const gltfObjects = createGLTFObjects(gl, gltf, this._getModelOptions());\n      scenegraphData = {gltf, ...gltfObjects};\n\n      waitForGLTFAssets(gltfObjects).then(() => this.setNeedsRedraw()); // eslint-disable-line @typescript-eslint/no-floating-promises\n    } else if (props.scenegraph) {\n      // DEPRECATED PATH: Assumes this data was loaded through GLTFScenegraphLoader\n      log.deprecated(\n        'ScenegraphLayer.props.scenegraph',\n        'Use GLTFLoader instead of GLTFScenegraphLoader'\n      )();\n      scenegraphData = props.scenegraph;\n    }\n\n    const options = {layer: this, gl};\n    const scenegraph = props.getScene(scenegraphData, options);\n    const animator = props.getAnimator(scenegraphData, options);\n\n    if (scenegraph instanceof ScenegraphNode) {\n      this._deleteScenegraph();\n      this._applyAllAttributes(scenegraph);\n      this._applyAnimationsProp(scenegraph, animator, props._animations);\n      this.setState({scenegraph, animator});\n    } else if (scenegraph !== null) {\n      log.warn('invalid scenegraph:', scenegraph)();\n    }\n  }\n\n  private _applyAllAttributes(scenegraph: GroupNode): void {\n    if (this.state.attributesAvailable) {\n      // attributeManager is always defined for primitive layers\n      const allAttributes = this.getAttributeManager()!.getAttributes();\n      scenegraph.traverse(model => {\n        this._setModelAttributes(model.model, allAttributes);\n      });\n    }\n  }\n\n  private _applyAnimationsProp(\n    scenegraph: GroupNode,\n    animator: GLTFAnimator,\n    animationsProp: any\n  ): void {\n    if (!scenegraph || !animator || !animationsProp) {\n      return;\n    }\n\n    const animations = animator.getAnimations();\n\n    // sort() to ensure '*' comes first so that other values can override\n    Object.keys(animationsProp)\n      .sort()\n      .forEach(key => {\n        // Key can be:\n        //  - number for index number\n        //  - name for animation name\n        //  - * to affect all animations\n        const value = animationsProp[key];\n\n        if (key === '*') {\n          animations.forEach(animation => {\n            Object.assign(animation, value);\n          });\n        } else if (Number.isFinite(Number(key))) {\n          const number = Number(key);\n          if (number >= 0 && number < animations.length) {\n            Object.assign(animations[number], value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        } else {\n          const findResult = animations.find(({name}) => name === key);\n          if (findResult) {\n            Object.assign(findResult, value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        }\n      });\n  }\n\n  private _deleteScenegraph(): void {\n    const {scenegraph} = this.state;\n    if (scenegraph instanceof ScenegraphNode) {\n      scenegraph.delete();\n    }\n  }\n\n  private _getModelOptions(): any {\n    const {_imageBasedLightingEnvironment} = this.props;\n\n    let env: GLTFEnvironment | null = null;\n    if (_imageBasedLightingEnvironment) {\n      if (typeof _imageBasedLightingEnvironment === 'function') {\n        env = _imageBasedLightingEnvironment({gl: this.context.gl, layer: this});\n      } else {\n        env = _imageBasedLightingEnvironment;\n      }\n    }\n\n    return {\n      gl: this.context.gl,\n      waitForFullLoad: true,\n      imageBasedLightingEnvironment: env,\n      modelOptions: {\n        isInstanced: true,\n        transpileToGLSL100: !isWebGL2(this.context.gl),\n        ...this.getShaders()\n      },\n      // tangents are not supported\n      useTangents: false\n    };\n  }\n\n  updateAttributes(changedAttributes) {\n    this.setState({attributesAvailable: true});\n    if (!this.state.scenegraph) return;\n\n    this.state.scenegraph.traverse(model => {\n      this._setModelAttributes(model.model, changedAttributes);\n    });\n  }\n\n  draw({moduleParameters = null, parameters = {}, context}) {\n    if (!this.state.scenegraph) return;\n\n    if (this.props._animations && this.state.animator) {\n      this.state.animator.animate(context.timeline.getTime());\n      this.setNeedsRedraw();\n    }\n\n    const {viewport} = this.context;\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, opacity, coordinateSystem} = this.props;\n    const numInstances = this.getNumInstances();\n    this.state.scenegraph.traverse((model, {worldMatrix}) => {\n      model.model.setInstanceCount(numInstances);\n      model.updateModuleSettings(moduleParameters);\n      model.draw({\n        parameters,\n        uniforms: {\n          sizeScale,\n          opacity,\n          sizeMinPixels,\n          sizeMaxPixels,\n          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n          sceneModelMatrix: worldMatrix,\n          // Needed for PBR (TODO: find better way to get it)\n          // eslint-disable-next-line camelcase\n          u_Camera: model.model.getUniforms().project_uCameraPosition\n        }\n      });\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["RADIAN_PER_DEGREE", "Math", "PI", "modelMatrix", "Float32Array", "valueArray", "calculateTransformMatrix", "targetMatrix", "orientation", "scale", "pitch", "yaw", "roll", "sr", "sin", "sp", "sw", "cr", "cos", "cp", "cw", "scx", "scy", "scz", "getExtendedMat3FromMat4", "mat4", "subarray", "MATRIX_ATTRIBUTES", "size", "accessor", "shaderAttributes", "instanceModelMatrix__LOCATION_0", "elementOffset", "instanceModelMatrix__LOCATION_1", "instanceModelMatrix__LOCATION_2", "instanceTranslation", "update", "attribute", "startRow", "endRow", "data", "getOrientation", "getScale", "getTranslation", "getTransformMatrix", "props", "arrayMatrix", "Array", "isArray", "constantMatrix", "length", "constantScale", "constantOrientation", "constantTranslation", "hasMatrix", "Boolean", "constant", "instanceModelMatrixData", "value", "matrix", "set", "i", "iterable", "objectInfo", "createIterable", "object", "index", "shouldComposeModelMatrix", "viewport", "coordinateSystem", "COORDINATE_SYSTEM", "CARTESIAN", "METER_OFFSETS", "DEFAULT", "isGeospatial", "validateGeometryAttributes", "attributes", "useMeshColors", "hasColorAttribute", "COLOR_0", "colors", "useColorAttribute", "constant", "value", "Float32Array", "log", "assert", "positions", "POSITION", "getGeometry", "data", "Geometry", "Error", "DEFAULT_COLOR", "defaultProps", "mesh", "type", "async", "texture", "sizeScale", "min", "_useMeshColors", "_instanced", "wireframe", "material", "getPosition", "x", "position", "getColor", "getOrientation", "getScale", "getTranslation", "getTransformMatrix", "textureParameters", "ignore", "SimpleMeshLayer", "Layer", "getShaders", "transpileToGLSL100", "isWebGL2", "context", "gl", "defines", "hasFeature", "FEATURES", "GLSL_DERIVATIVES", "DERIVATIVES_AVAILABLE", "vs", "fs", "modules", "project32", "phongLighting", "picking", "getBounds", "props", "result", "state", "positionBounds", "header", "boundingBox", "getMeshBoundingBox", "initializeState", "attributeManager", "getAttributeManager", "addInstanced", "instancePositions", "transition", "fp64", "use64bitPositions", "size", "accessor", "instanceColors", "colorFormat", "length", "normalized", "defaultValue", "instanceModelMatrix", "MATRIX_ATTRIBUTES", "setState", "emptyTexture", "Texture2D", "Uint8Array", "width", "height", "updateState", "params", "oldProps", "changeFlags", "extensionsChanged", "model", "delete", "getModel", "hasNormals", "Boolean", "NORMAL", "normals", "invalidateAll", "setTexture", "setDrawMode", "finalizeState", "draw", "uniforms", "viewport", "coordinateSystem", "setUniforms", "composeModelMatrix", "shouldComposeModelMatrix", "flatShading", "Model", "id", "geometry", "isInstanced", "sampler", "hasTexture", "ScenegraphNode", "constructor", "props", "id", "uid", "name", "display", "position", "Vector3", "rotation", "scale", "matrix", "Matrix4", "userData", "_setScenegraphNodeProps", "delete", "setProps", "toString", "getBounds", "setPosition", "assert", "length", "setRotation", "setScale", "setMatrix", "copyMatrix", "copy", "setMatrixComponents", "update", "updateMatrix", "pos", "rot", "identity", "translate", "rotateXYZ", "options", "getCoordinateUniforms", "viewMatrix", "modelMatrix", "worldMatrix", "multiplyRight", "worldInverse", "invert", "worldInverseTranspose", "transpose", "objectMatrix", "worldInverseMatrix", "worldInverseTransposeMatrix", "Object", "assign", "GroupNode", "ScenegraphNode", "constructor", "props", "Array", "isArray", "children", "log", "assert", "every", "child", "add", "push", "remove", "indexOf", "splice", "removeAll", "delete", "forEach", "getBounds", "result", "Infinity", "traverse", "node", "worldMatrix", "bounds", "min", "max", "center", "Vector3", "divide", "transformAsPoint", "halfSize", "subtract", "transformAsVector", "v", "position", "multiply", "i", "Math", "Number", "isFinite", "visitor", "Matrix4", "modelMatrix", "multiplyRight", "matrix", "ATTRIBUTE_TYPE_TO_COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Uint32Array", "Float32Array", "accessorToJsArray", "accessor", "_animation", "ArrayType", "componentType", "components", "type", "length", "count", "buffer", "byteOffset", "bufferView", "data", "array", "Array", "from", "slicedArray", "i", "push", "slice", "helperMatrix", "Matrix4", "applyTranslationRotationScale", "gltfNode", "node", "matrix", "identity", "translation", "translate", "rotation", "rotationMatrix", "fromQuaternion", "multiplyRight", "scale", "quaternion", "Quaternion", "linearInterpolate", "target", "path", "start", "stop", "ratio", "slerp", "cubicsplineInterpolate", "p0", "outTangent0", "inTangent1", "p1", "tDiff", "t", "m0", "m1", "Math", "pow", "stepInterpolate", "value", "interpolate", "time", "input", "interpolation", "output", "maxTime", "animationTime", "nextIndex", "findIndex", "previousIndex", "max", "isArray", "log", "warn", "assert", "previousTime", "nextTime", "GLTFAnimation", "constructor", "props", "startTime", "playing", "speed", "channels", "Object", "assign", "animate", "timeMs", "absTime", "forEach", "sampler", "_node", "GLTFAnimator", "gltf", "animations", "map", "animation", "index", "name", "samplers", "accessors", "nodes", "setTime", "getAnimations", "ModelNode", "ScenegraphNode", "constructor", "gl", "props", "onBeforeRender", "AfterRender", "Model", "model", "_setModelNodeProps", "bounds", "managedResources", "setProps", "getBounds", "delete", "forEach", "resource", "draw", "setUniforms", "setAttributes", "updateModuleSettings", "GLTFMaterialParser", "constructor", "gl", "attributes", "material", "pbrDebug", "imageBasedLightingEnvironment", "lights", "useTangents", "defines", "MANUAL_SRGB", "SRGB_FAST_APPROXIMATION", "hasFeature", "FEATURES", "GLSL_TEXTURE_LOD", "USE_TEX_LOD", "uniforms", "u_Camera", "u_MetallicRoughnessValues", "parameters", "generatedTextures", "u_DiffuseEnvSampler", "getDiffuseEnvSampler", "u_SpecularEnvSampler", "getSpecularEnvSampler", "u_brdfLUT", "getBrdfTexture", "u_ScaleIBLAmbient", "u_ScaleDiffBaseMR", "u_ScaleFGDSpec", "defineIfPresent", "NORMAL", "TANGENT", "TEXCOORD_0", "parseMaterial", "value", "name", "parseTexture", "gltfTexture", "define", "texture", "sampler", "image", "source", "textureOptions", "specialTextureParameters", "compressed", "TEXTURE_MIN_FILTER", "data", "length", "LINEAR_MIPMAP_NEAREST", "LINEAR", "Texture2D", "id", "pixelStore", "UNPACK_FLIP_Y_WEBGL", "push", "parsePbrMetallicRoughness", "pbrMetallicRoughness", "baseColorTexture", "u_BaseColorFactor", "baseColorFactor", "metallicRoughnessTexture", "metallicFactor", "roughnessFactor", "pbr_uUnlit", "Boolean", "unlit", "normalTexture", "scale", "u_NormalScale", "occlusionTexture", "strength", "u_OcclusionStrength", "emissiveTexture", "u_EmissiveFactor", "emissiveFactor", "alphaMode", "alphaCutoff", "ALPHA_CUTOFF", "u_AlphaCutoff", "log", "warn", "Object", "assign", "blend", "blendEquation", "FUNC_ADD", "blendFunc", "SRC_ALPHA", "ONE_MINUS_SRC_ALPHA", "ONE", "delete", "forEach", "vs", "fs", "addVersionToShader", "gl", "source", "isWebGL2", "options", "id", "drawMode", "vertexCount", "attributes", "modelOptions", "materialParser", "GLTFMaterialParser", "log", "info", "defines", "managedResources", "push", "generatedTextures", "Object", "values", "map", "attribute", "buffer", "model", "ModelNode", "assign", "modules", "pbr", "parameters", "setProps", "setUniforms", "uniforms", "ATTRIBUTE_TYPE_TO_COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "DEFAULT_OPTIONS", "modelOptions", "pbrDebug", "imageBasedLightingEnvironment", "lights", "useTangents", "GLTFInstantiator", "constructor", "gl", "options", "Object", "assign", "instantiate", "gltf", "scenes", "map", "scene", "createScene", "createAnimator", "Array", "isArray", "animations", "GLTFAnimator", "gltfScene", "gltfNodes", "nodes", "node", "createNode", "GroupNode", "id", "name", "children", "gltfNode", "_node", "gltfChildren", "child", "mesh", "push", "createMesh", "matrix", "setMatrix", "identity", "translation", "translate", "rotation", "rotationMatrix", "Matrix4", "fromQuaternion", "multiplyRight", "scale", "gltfMesh", "_mesh", "gltfPrimitives", "primitives", "gltfPrimitive", "i", "createPrimitive", "getVertexCount", "attributes", "log", "warn", "model", "createGLTFModel", "drawMode", "mode", "vertexCount", "indices", "count", "createAttributes", "material", "bounds", "POSITION", "min", "max", "loadedAttributes", "keys", "forEach", "attrName", "createAccessor", "createBuffer", "ARRAY_BUFFER", "ELEMENT_ARRAY_BUFFER", "info", "generated", "attribute", "target", "bufferView", "lumaBuffers", "Buffer", "data", "value", "accessor", "buffer", "Accessor", "offset", "byteOffset", "stride", "byteStride", "type", "componentType", "size", "createSampler", "gltfSampler", "needsPOT", "gl", "gltf", "options", "instantiator", "GLTFInstantiator", "scenes", "instantiate", "animator", "createAnimator", "PI_4", "Math", "PI", "DEGREES_TO_RADIANS_HALF", "VERSION", "VERSION", "VERSION", "BASIS_CDN_ENCODER_WASM", "concat", "BASIS_CDN_ENCODER_JS", "loadBasisTranscoderPromise", "loadBasisTrascoderModule", "options", "modules", "basis", "loadBasisTrascoder", "BASIS", "wasmBinary", "Promise", "all", "loadLibrary", "globalThis", "initializeBasisTrascoderModule", "BasisModule", "resolve", "then", "module", "BasisFile", "initializeBasis", "loadBasisEncoderPromise", "loadBasisEncoderModule", "basisEncoder", "loadBasisEncoder", "BASIS_ENCODER", "initializeBasisEncoderModule", "BasisEncoderModule", "KTX2File", "BasisEncoder", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_R11_EAC", "COMPRESSED_SIGNED_R11_EAC", "COMPRESSED_RG11_EAC", "COMPRESSED_SIGNED_RG11_EAC", "COMPRESSED_RGB8_ETC2", "COMPRESSED_RGBA8_ETC2_EAC", "COMPRESSED_SRGB8_ETC2", "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "COMPRESSED_RGB_ETC1_WEBGL", "COMPRESSED_RGB_ATC_WEBGL", "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", "COMPRESSED_RGBA_ASTC_4X4_KHR", "COMPRESSED_RGBA_ASTC_5X4_KHR", "COMPRESSED_RGBA_ASTC_5X5_KHR", "COMPRESSED_RGBA_ASTC_6X5_KHR", "COMPRESSED_RGBA_ASTC_6X6_KHR", "COMPRESSED_RGBA_ASTC_8X5_KHR", "COMPRESSED_RGBA_ASTC_8X6_KHR", "COMPRESSED_RGBA_ASTC_8X8_KHR", "COMPRESSED_RGBA_ASTC_10X5_KHR", "COMPRESSED_RGBA_ASTC_10X6_KHR", "COMPRESSED_RGBA_ASTC_10X8_KHR", "COMPRESSED_RGBA_ASTC_10X10_KHR", "COMPRESSED_RGBA_ASTC_12X10_KHR", "COMPRESSED_RGBA_ASTC_12X12_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR", "COMPRESSED_RED_RGTC1_EXT", "COMPRESSED_SIGNED_RED_RGTC1_EXT", "COMPRESSED_RED_GREEN_RGTC2_EXT", "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", "COMPRESSED_SRGB_S3TC_DXT1_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", "BROWSER_PREFIXES", "WEBGL_EXTENSIONS", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_pvrtc", "WEBGL_compressed_texture_atc", "WEBGL_compressed_texture_astc", "EXT_texture_compression_rgtc", "formats", "getSupportedGPUTextureFormats", "gl", "getWebGLContext", "undefined", "Set", "prefix", "extension", "getExtension", "concat", "gpuTextureFormat", "add", "canvas", "document", "createElement", "getContext", "error", "NUL", "Uint8Array", "KTX2_ID", "KTX2SupercompressionScheme", "KTX2DataFormatType", "KTX2DataFormatModel", "KTX2DataFormatPrimaries", "KTX2DataFormatTransfer", "KTX2DataFormatFlags", "KTX2DataFormatChannelETC1S", "KTX2DataFormatChannelUASTC", "KTX2Container", "constructor", "this", "NONE", "vendorId", "descriptorType", "BASICFORMAT", "versionNumber", "descriptorBlockSize", "colorModel", "UNSPECIFIED", "colorPrimaries", "SRGB", "transferFunction", "flags", "ALPHA_STRAIGHT", "texelBlockDimension", "x", "y", "z", "w", "bytesPlane", "samples", "BufferReader", "data", "byteOffset", "byteLength", "littleEndian", "_dataView", "DataView", "buffer", "_littleEndian", "_offset", "_nextUint8", "value", "getUint8", "_nextUint16", "getUint16", "_nextUint32", "getUint32", "_nextUint64", "_skip", "bytes", "_scan", "maxByteLength", "term", "text", "decodeText", "buffer", "TextDecoder", "decode", "Buffer", "from", "toString", "result", "read", "data", "id", "Uint8Array", "buffer", "byteOffset", "KTX2_ID", "length", "Error", "container", "KTX2Container", "headerByteLength", "Uint32Array", "BYTES_PER_ELEMENT", "headerReader", "BufferReader", "vkFormat", "_nextUint32", "typeSize", "pixelWidth", "pixelHeight", "pixelDepth", "layerCount", "faceCount", "levelCount", "supercompressionScheme", "dfdByteOffset", "dfdByteLength", "kvdByteOffset", "kvdByteLength", "sgdByteOffset", "_nextUint64", "sgdByteLength", "levelReader", "i", "levels", "push", "levelData", "uncompressedByteLength", "dfdReader", "dfd", "vendorId", "_skip", "_nextUint16", "descriptorType", "versionNumber", "descriptorBlockSize", "colorModel", "_nextUint8", "colorPrimaries", "transferFunction", "flags", "texelBlockDimension", "x", "y", "z", "w", "bytesPlane", "samples", "numSamples", "bitOffset", "bitLength", "channelID", "samplePosition", "sampleLower", "sampleUpper", "dataFormatDescriptor", "kvdReader", "_offset", "keyValueByteLength", "keyData", "_scan", "key", "decodeText", "valueData", "byteLength", "keyValue", "match", "sgdReader", "endpointCount", "selectorCount", "endpointsByteLength", "selectorsByteLength", "tablesByteLength", "extendedByteLength", "imageDescs", "imageFlags", "rgbSliceByteOffset", "rgbSliceByteLength", "alphaSliceByteOffset", "alphaSliceByteLength", "endpointsByteOffset", "selectorsByteOffset", "tablesByteOffset", "extendedByteOffset", "endpointsData", "selectorsData", "tablesData", "extendedData", "globalData", "extractMipmapImages", "data", "options", "images", "Array", "mipMapLevels", "levelWidth", "width", "levelHeight", "height", "offset", "i", "levelSize", "getLevelSize", "levelData", "getLevelData", "compressed", "format", "internalFormat", "Math", "max", "index", "isArray", "Uint8Array", "buffer", "byteOffset", "sizeFunction", "VULKAN_TO_WEBGL_FORMAT_MAP", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_SRGB_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT1_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", "COMPRESSED_RED_RGTC1_EXT", "COMPRESSED_SIGNED_RED_RGTC1_EXT", "COMPRESSED_RED_GREEN_RGTC2_EXT", "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", "COMPRESSED_RGB8_ETC2", "COMPRESSED_SRGB8_ETC2", "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_RGBA8_ETC2_EAC", "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", "COMPRESSED_R11_EAC", "COMPRESSED_SIGNED_R11_EAC", "COMPRESSED_RG11_EAC", "COMPRESSED_SIGNED_RG11_EAC", "COMPRESSED_RGBA_ASTC_4x4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", "COMPRESSED_RGBA_ASTC_5x4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR", "COMPRESSED_RGBA_ASTC_5x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", "COMPRESSED_RGBA_ASTC_6x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", "COMPRESSED_RGBA_ASTC_6x6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", "COMPRESSED_RGBA_ASTC_8x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", "COMPRESSED_RGBA_ASTC_8x6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", "COMPRESSED_RGBA_ASTC_8x8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", "COMPRESSED_RGBA_ASTC_10x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", "COMPRESSED_RGBA_ASTC_10x6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", "COMPRESSED_RGBA_ASTC_10x8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", "COMPRESSED_RGBA_ASTC_10x10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", "COMPRESSED_RGBA_ASTC_12x10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", "COMPRESSED_RGBA_ASTC_12x12_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "mapVkFormatToWebGL", "vkFormat", "KTX2_ID", "isKTX", "data", "id", "Uint8Array", "notKTX", "byteLength", "length", "parseKTX", "arrayBuffer", "uint8Array", "ktx", "read", "mipMapLevels", "Math", "max", "levels", "width", "pixelWidth", "height", "pixelHeight", "internalFormat", "mapVkFormatToWebGL", "vkFormat", "extractMipmapImages", "sizeFunction", "level", "uncompressedByteLength", "OutputFormat", "etc1", "basisFormat", "compressed", "format", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_ETC1_WEBGL", "etc2", "bc1", "COMPRESSED_RGB_S3TC_DXT1_EXT", "bc3", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "bc4", "bc5", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_ASTC_4X4_KHR", "rgba32", "rgb565", "bgr565", "rgba4444", "data", "options", "basis", "containerFormat", "isKTX", "fileConstructors", "loadBasisEncoderModule", "parseKTX2File", "KTX2File", "BasisFile", "loadBasisTrascoderModule", "parseBasisFile", "module", "basisFile", "Uint8Array", "startTranscoding", "Error", "imageCount", "getNumImages", "images", "imageIndex", "levelsCount", "getNumLevels", "levels", "levelIndex", "push", "transcodeImage", "close", "delete", "width", "getImageWidth", "height", "getImageHeight", "hasAlpha", "getHasAlpha", "getBasisOptions", "decodedSize", "getImageTranscodedSizeInBytes", "decodedData", "ktx2File", "getLevels", "transcodeKTX2Image", "alphaFlag", "getImageLevelInfo", "levelSize", "selectSupportedBasisFormat", "alpha", "noAlpha", "toLowerCase", "supportedFormats", "getSupportedGPUTextureFormats", "has", "BasisWorkerLoader", "name", "id", "isBrowser", "module", "version", "VERSION", "worker", "extensions", "mimeTypes", "tests", "binary", "options", "basis", "format", "libraryPath", "containerFormat", "BasisLoader", "parse", "parseBasis", "DDS_CONSTANTS", "MAGIC_NUMBER", "HEADER_LENGTH", "MAGIC_NUMBER_INDEX", "HEADER_SIZE_INDEX", "HEADER_FLAGS_INDEX", "HEADER_HEIGHT_INDEX", "HEADER_WIDTH_INDEX", "MIPMAPCOUNT_INDEX", "HEADER_PF_FLAGS_INDEX", "HEADER_PF_FOURCC_INDEX", "DDSD_MIPMAPCOUNT", "DDPF_FOURCC", "DDS_PIXEL_FORMATS", "DXT1", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_S3TC_DXT1_EXT", "DXT3", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "DXT5", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_RGB_ATC_WEBGL", "ATCA", "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", "ATCI", "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", "getATCLevelSize", "getDxt1LevelSize", "getATCALevelSize", "getDxtXLevelSize", "getATCILevelSize", "DDS_SIZE_FUNCTIONS", "isDDS", "data", "header", "Uint32Array", "magic", "parseDDS", "Int32Array", "pixelFormatNumber", "assert", "Boolean", "fourCC", "int32ToFourCC", "internalFormat", "sizeFunction", "concat", "mipMapLevels", "Math", "max", "width", "height", "dataOffset", "image", "Uint8Array", "extractMipmapImages", "value", "String", "fromCharCode", "PVR_CONSTANTS", "MAGIC_NUMBER", "MAGIC_NUMBER_EXTRA", "HEADER_LENGTH", "HEADER_SIZE", "MAGIC_NUMBER_INDEX", "PIXEL_FORMAT_INDEX", "COLOUR_SPACE_INDEX", "HEIGHT_INDEX", "WIDTH_INDEX", "MIPMAPCOUNT_INDEX", "METADATA_SIZE_INDEX", "PVR_PIXEL_FORMATS", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "COMPRESSED_RGB_ETC1_WEBGL", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_RGB8_ETC2", "COMPRESSED_RGBA8_ETC2_EAC", "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_R11_EAC", "COMPRESSED_RG11_EAC", "COMPRESSED_RGBA_ASTC_4X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR", "COMPRESSED_RGBA_ASTC_5X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR", "COMPRESSED_RGBA_ASTC_5X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR", "COMPRESSED_RGBA_ASTC_6X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR", "COMPRESSED_RGBA_ASTC_6X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR", "COMPRESSED_RGBA_ASTC_8X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR", "COMPRESSED_RGBA_ASTC_8X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR", "COMPRESSED_RGBA_ASTC_8X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR", "COMPRESSED_RGBA_ASTC_10X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR", "COMPRESSED_RGBA_ASTC_10X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR", "COMPRESSED_RGBA_ASTC_10X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR", "COMPRESSED_RGBA_ASTC_10X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR", "COMPRESSED_RGBA_ASTC_12X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR", "COMPRESSED_RGBA_ASTC_12X12_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR", "PVR_SIZE_FUNCTIONS", "pvrtc2bppSize", "pvrtc4bppSize", "dxtEtcSmallSize", "dxtEtcAstcBigSize", "atc5x4Size", "atc5x5Size", "atc6x5Size", "atc6x6Size", "atc8x5Size", "atc8x6Size", "atc8x8Size", "atc10x5Size", "atc10x6Size", "atc10x8Size", "atc10x10Size", "atc12x10Size", "atc12x12Size", "isPVR", "data", "header", "Uint32Array", "version", "parsePVR", "pvrFormat", "colourSpace", "pixelFormats", "internalFormat", "length", "sizeFunction", "mipMapLevels", "width", "height", "dataOffset", "image", "Uint8Array", "extractMipmapImages", "Math", "max", "floor", "parseCompressedTexture", "data", "isKTX", "parseKTX", "isDDS", "parseDDS", "isPVR", "parsePVR", "Error", "DEFAULT_TEXTURE_LOADER_OPTIONS", "libraryPath", "useBasis", "CompressedTextureWorkerLoader", "name", "id", "module", "version", "VERSION", "worker", "extensions", "mimeTypes", "binary", "options", "CompressedTextureLoader", "parse", "arrayBuffer", "basis", "format", "alpha", "noAlpha", "containerFormat", "parseBasis", "parseCompressedTexture", "systemIsLittleEndian", "a", "Uint32Array", "b", "Uint8Array", "buffer", "byteOffset", "byteLength", "LITTLE_ENDIAN_OS", "DTYPES", "u1", "i1", "Int8Array", "u2", "Uint16Array", "i2", "Int16Array", "u4", "i4", "Int32Array", "f4", "Float32Array", "f8", "Float64Array", "parseNPY", "arrayBuffer", "options", "_header$shape", "view", "DataView", "header", "headerEndOffset", "parseHeader", "numpyType", "descr", "ArrayType", "slice", "Error", "concat", "nArrayElements", "shape", "reduce", "arrayByteLength", "BYTES_PER_ELEMENT", "data", "majorVersion", "getUint8", "offset", "headerLength", "getUint32", "getUint16", "encoding", "decoder", "TextDecoder", "headerArray", "headerText", "decode", "JSON", "parse", "replace", "NPY_MAGIC_NUMBER", "Uint8Array", "NPYWorkerLoader", "name", "id", "module", "version", "VERSION", "worker", "extensions", "mimeTypes", "tests", "buffer", "options", "npy", "NPYLoader", "parseSync", "parseNPY", "parse", "arrayBuffer", "assert", "condition", "message", "Error", "resolveUrl", "url", "options", "absolute", "startsWith", "baseUrl", "baseUri", "uri", "Error", "concat", "substr", "lastIndexOf", "getTypedArrayForBufferView", "json", "buffers", "bufferViewIndex", "bufferView", "bufferViews", "assert", "bufferIndex", "buffer", "binChunk", "byteOffset", "Uint8Array", "arrayBuffer", "byteLength", "decode", "TYPES", "ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Uint32Array", "Float32Array", "Float64Array", "ARRAY_TO_COMPONENT_TYPE", "Map", "ATTRIBUTE_TYPE_TO_COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE", "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", "getAccessorTypeFromSize", "size", "type", "getComponentTypeFromArray", "typedArray", "componentType", "get", "constructor", "Error", "getAccessorArrayTypeAndLength", "accessor", "bufferView", "ArrayType", "components", "bytesPerComponent", "length", "count", "byteLength", "assert", "DEFAULT_GLTF_JSON", "asset", "version", "generator", "buffers", "GLTFScenegraph", "constructor", "gltf", "_defineProperty", "json", "sourceBuffers", "byteLength", "getApplicationData", "key", "data", "getExtraData", "extras", "getExtension", "extensionName", "isExtension", "getUsedExtensions", "find", "name", "extensions", "getRequiredExtension", "isRequired", "getRequiredExtensions", "extensionsRequired", "extensionsUsed", "getRemovedExtensions", "extensionsRemoved", "getObjectExtension", "object", "getScene", "index", "getObject", "getNode", "getSkin", "getMesh", "getMaterial", "getAccessor", "getTexture", "getSampler", "getImage", "getBufferView", "getBuffer", "array", "Error", "concat", "getTypedArrayForBufferView", "bufferView", "bufferIndex", "buffer", "binChunk", "assert", "byteOffset", "Uint8Array", "arrayBuffer", "getTypedArrayForAccessor", "accessor", "ArrayType", "length", "getAccessorArrayTypeAndLength", "getTypedArrayForImageData", "image", "addApplicationData", "addExtraData", "addObjectExtension", "registerUsedExtension", "setObjectExtension", "removeObjectExtension", "extension", "addExtension", "extensionData", "arguments", "undefined", "addRequiredExtension", "registerRequiredExtension", "ext", "push", "removeExtension", "_removeStringFromArray", "Array", "isArray", "includes", "setDefaultScene", "sceneIndex", "scene", "addScene", "nodeIndices", "scenes", "nodes", "addNode", "node", "meshIndex", "matrix", "nodeData", "mesh", "addMesh", "attributes", "indices", "material", "mode", "accessors", "_addAttributes", "glTFMesh", "primitives", "indicesAccessor", "_addIndices", "Number", "isFinite", "meshes", "addPointCloud", "accessorIndices", "addImage", "imageData", "mimeTypeOpt", "metadata", "getBinaryImageMetadata", "mimeType", "bufferViewIndex", "addBufferView", "glTFImage", "images", "glTFBufferView", "padToNBytes", "bufferViews", "addAccessor", "glTFAccessor", "type", "getAccessorTypeFromSize", "size", "componentType", "count", "max", "min", "addBinaryBuffer", "sourceBuffer", "minMax", "_getAccessorMinMax", "accessorDefaults", "getComponentTypeFromArray", "Math", "round", "Object", "assign", "addTexture", "texture", "imageIndex", "glTFTexture", "source", "textures", "addMaterial", "pbrMaterialInfo", "materials", "createBinaryChunk", "_this$json", "_this$json$buffers", "totalByteLength", "ArrayBuffer", "targetArray", "dstByteOffset", "copyToArray", "binary", "string", "found", "indexOf", "splice", "result", "attributeKey", "attributeData", "attrName", "_getGltfAttributeName", "value", "attributeName", "toLowerCase", "initValues", "subarray", "componentIndex", "wasm_base", "wasm_simd", "detector", "Uint8Array", "wasmpack", "FILTERS", "NONE", "OCTAHEDRAL", "QUATERNION", "EXPONENTIAL", "DECODERS", "ATTRIBUTES", "TRIANGLES", "INDICES", "meshoptDecodeGltfBuffer", "target", "count", "size", "source", "mode", "filter", "arguments", "length", "undefined", "instance", "loadWasmInstance", "decode", "exports", "DECODERS", "FILTERS", "wasmPromise", "loadWasmModule", "wasm", "wasm_base", "WebAssembly", "validate", "detector", "wasm_simd", "console", "log", "result", "instantiate", "unpack", "__wasm_call_ctors", "data", "Uint8Array", "i", "ch", "charCodeAt", "write", "wasmpack", "buffer", "slice", "fun", "sbrk", "count4", "tp", "sp", "heap", "memory", "set", "res", "subarray", "Error", "concat", "EXT_MESHOPT_COMPRESSION", "name", "decode", "gltfData", "options", "_options$gltf", "scenegraph", "GLTFScenegraph", "gltf", "decompressMeshes", "promises", "bufferViewIndex", "json", "bufferViews", "push", "decodeMeshoptBufferView", "Promise", "all", "removeExtension", "bufferView", "meshoptExtension", "getObjectExtension", "byteOffset", "byteLength", "byteStride", "count", "mode", "filter", "buffer", "bufferIndex", "buffers", "source", "Uint8Array", "arrayBuffer", "result", "meshoptDecodeGltfBuffer", "name", "EXT_TEXTURE_WEBP", "name", "preprocess", "gltfData", "options", "scenegraph", "GLTFScenegraph", "isImageFormatSupported", "getRequiredExtensions", "includes", "Error", "concat", "json", "texture", "textures", "extension", "getObjectExtension", "source", "removeObjectExtension", "removeExtension", "name", "preprocess", "KHR_TEXTURE_BASISU", "name", "preprocess", "gltfData", "options", "scene", "GLTFScenegraph", "json", "texture", "textures", "extension", "getObjectExtension", "source", "removeObjectExtension", "removeExtension", "decode", "name", "preprocess", "VERSION", "DEFAULT_DRACO_OPTIONS", "draco", "decoderType", "WebAssembly", "libraryPath", "extraAttributes", "attributeNameEntry", "undefined", "DracoLoader", "name", "id", "isBrowser", "module", "shapes", "version", "VERSION", "worker", "extensions", "mimeTypes", "binary", "tests", "options", "getDracoSchema", "attributes", "loaderData", "indices", "metadataMap", "makeMetadata", "metadata", "fields", "namedLoaderDataAttributes", "transformAttributesLoaderData", "attributeName", "attribute", "field", "getArrowFieldFromAttribute", "push", "indicesField", "Schema", "result", "key", "dracoAttribute", "name", "undefined", "deduceMeshField", "Map", "set", "concat", "JSON", "stringify", "DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP", "POSITION", "NORMAL", "COLOR", "TEX_COORD", "DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "INDEX_ITEM_SIZE", "DracoParser", "constructor", "draco", "_defineProperty", "decoder", "Decoder", "metadataQuerier", "MetadataQuerier", "destroy", "parseSync", "arrayBuffer", "options", "arguments", "length", "undefined", "buffer", "DecoderBuffer", "Init", "byteLength", "_disableAttributeTransforms", "geometry_type", "GetEncodedGeometryType", "dracoGeometry", "TRIANGULAR_MESH", "Mesh", "PointCloud", "dracoStatus", "DecodeBufferToMesh", "POINT_CLOUD", "DecodeBufferToPointCloud", "Error", "ok", "ptr", "message", "concat", "error_msg", "loaderData", "_getDracoLoaderData", "geometry", "_getMeshData", "boundingBox", "getMeshBoundingBox", "attributes", "schema", "getDracoSchema", "indices", "data", "loader", "header", "vertexCount", "num_points", "metadata", "_getTopLevelMetadata", "_getDracoAttributes", "num_attributes", "num_faces", "dracoAttributes", "attributeId", "dracoAttribute", "GetAttribute", "_getAttributeMetadata", "unique_id", "attribute_type", "data_type", "num_components", "byte_offset", "byte_stride", "normalized", "attribute_index", "quantization", "_getQuantizationTransform", "quantization_transform", "octahedron", "_getOctahedronTransform", "octahedron_transform", "_getMeshAttributes", "positionAttribute", "topology", "mode", "value", "_getTriangleStripIndices", "size", "_getTriangleListIndices", "loaderAttribute", "Object", "values", "attributeName", "_deduceAttributeName", "name", "_getAttributeValues", "byteOffset", "byteStride", "numFaces", "numIndices", "_malloc", "GetTrianglesUInt32Array", "HEAPF32", "slice", "_free", "dracoArray", "DracoInt32Array", "GetTriangleStripsFromMesh", "getUint32Array", "attribute", "TypedArrayCtor", "numComponents", "numPoints", "numValues", "BYTES_PER_ELEMENT", "dataType", "getDracoDataType", "GetAttributeDataArrayForAllPoints", "uniqueId", "attributeUniqueId", "entries", "extraAttributes", "thisAttributeType", "dracoAttributeConstant", "attributeType", "entryName", "attributeNameEntry", "string", "dracoMetadata", "GetMetadata", "_getDracoMetadata", "GetAttributeMetadata", "result", "numEntries", "NumEntries", "entryIndex", "GetEntryName", "_getDracoMetadataField", "GetIntEntryArray", "intArray", "getInt32Array", "int", "GetIntEntry", "GetStringEntry", "double", "GetDoubleEntry", "quantizedAttributes", "octahedronAttributes", "skipAttributes", "dracoAttributeName", "SkipAttributeTransform", "skip", "map", "type", "includes", "transform", "AttributeQuantizationTransform", "InitFromAttribute", "quantization_bits", "range", "min_values", "i", "min_value", "DT_FLOAT32", "DT_INT8", "DT_INT16", "DT_INT32", "DT_UINT8", "DT_UINT16", "DT_UINT32", "DT_INVALID", "GetValue", "DRACO_DECODER_VERSION", "DRACO_ENCODER_VERSION", "STATIC_DECODER_URL", "concat", "DRACO_JS_DECODER_URL", "DRACO_WASM_WRAPPER_URL", "DRACO_WASM_DECODER_URL", "DRACO_ENCODER_URL", "loadDecoderPromise", "loadDracoDecoderModule", "options", "modules", "draco3d", "loadDecoderPromise", "createDecoderModule", "then", "draco", "loadDracoDecoder", "loadDracoDecoder", "options", "DracoDecoderModule", "wasmBinary", "draco", "decoderType", "loadLibrary", "DRACO_JS_DECODER_URL", "Promise", "all", "DRACO_WASM_WRAPPER_URL", "DRACO_WASM_DECODER_URL", "globalThis", "initializeDracoDecoder", "resolve", "onModuleLoaded", "DracoLoader", "DracoWorkerLoader", "parse", "arrayBuffer", "options", "draco", "loadDracoDecoderModule", "dracoParser", "DracoParser", "parseSync", "destroy", "getGLTFAccessors", "attributes", "accessors", "name", "attribute", "glTFAccessor", "getGLTFAccessor", "buffer", "size", "count", "getAccessorData", "value", "byteOffset", "type", "getAccessorTypeFromSize", "componentType", "getComponentTypeFromArray", "ArrayBuffer", "isView", "toTypedArray", "Float32Array", "length", "array", "ArrayType", "convertTypedArrays", "arguments", "undefined", "Array", "isArray", "KHR_DRACO_MESH_COMPRESSION", "name", "preprocess", "gltfData", "options", "context", "scenegraph", "Scenegraph", "primitive", "makeMeshPrimitiveIterator", "getObjectExtension", "decode", "_options$gltf", "gltf", "decompressMeshes", "promises", "push", "decompressPrimitive", "Promise", "all", "removeExtension", "encode", "arguments", "length", "undefined", "mesh", "json", "meshes", "compressMesh", "addRequiredExtension", "dracoExtension", "buffer", "getTypedArrayForBufferView", "bufferView", "bufferCopy", "sliceArrayBuffer", "byteOffset", "parse", "dracoOptions", "decodedData", "DracoLoader", "decodedAttributes", "getGLTFAccessors", "attributes", "attributeName", "decodedAttribute", "Object", "entries", "accessorIndex", "accessor", "getAccessor", "min", "max", "indices", "getGLTFAccessor", "checkPrimitive", "_context$parseSync", "mode", "DracoWriter", "Error", "compressedData", "encodeSync", "parseSync", "call", "fauxAccessors", "_addFauxAttributes", "bufferViewIndex", "addBufferView", "glTFMesh", "primitives", "extensions", "keys", "decode", "name", "COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "BYTES", "EXT_MESHOPT_TRANSFORM", "name", "scratchVector", "Vector3", "scratchRotationMatrix", "Matrix3", "scratchScaleMatrix", "decode", "gltfData", "options", "gltfScenegraph", "GLTFScenegraph", "extension", "getExtension", "materials", "json", "i", "length", "transformTexCoords", "materialIndex", "_gltfData$json$materi", "_material$pbrMetallic", "_material$pbrMetallic2", "processedTexCoords", "material", "baseColorTexture", "pbrMetallicRoughness", "transformPrimitives", "emisiveTexture", "emissiveTexture", "normalTexture", "occlusionTexture", "metallicRoughnessTexture", "texture", "transformParameters", "getTransformParameters", "meshes", "mesh", "primitive", "primitives", "Number", "isFinite", "transformPrimitive", "_texture$extensions", "textureInfo", "extensions", "texCoord", "originalTexCoord", "isProcessed", "findIndex", "_ref", "original", "newTexCoord", "matrix", "makeTransformationMatrix", "push", "texCoordAccessor", "attributes", "concat", "_gltfData$json$access", "accessor", "accessors", "bufferView", "_gltfData$json$buffer", "bufferViews", "arrayBuffer", "byteOffset", "bufferByteOffset", "buffers", "buffer", "ArrayType", "getAccessorArrayTypeAndLength", "bytes", "BYTES", "componentType", "components", "COMPONENTS", "type", "elementAddressScale", "byteStride", "result", "Float32Array", "count", "uv", "set", "transformByMatrix3", "updateGltf", "createAttribute", "newTexCoordArray", "byteLength", "originalAccessor", "extensionData", "offset", "rotation", "scale", "translationMatirx", "rotationMatirx", "Math", "cos", "sin", "scaleMatrix", "multiplyRight", "decode", "encode", "name", "KHR_LIGHTS_PUNCTUAL", "name", "decode", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "extension", "getExtension", "lights", "removeExtension", "node", "nodes", "nodeExtension", "getObjectExtension", "light", "removeObjectExtension", "encode", "addExtension", "assert", "addObjectExtension", "decode", "encode", "name", "KHR_MATERIALS_UNLIT", "name", "decode", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "material", "materials", "extension", "extensions", "KHR_materials_unlit", "unlit", "removeObjectExtension", "removeExtension", "encode", "addObjectExtension", "addExtension", "decode", "encode", "name", "KHR_TECHNIQUES_WEBGL", "name", "decode", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "extension", "getExtension", "techniques", "resolveTechniques", "material", "materials", "materialExtension", "getObjectExtension", "technique", "Object", "assign", "values", "resolveValues", "removeObjectExtension", "removeExtension", "encode", "options", "techniquesExtension", "programs", "shaders", "textDecoder", "TextDecoder", "forEach", "shader", "Number", "isFinite", "bufferView", "code", "getTypedArrayForBufferView", "Error", "program", "fragmentShader", "vertexShader", "keys", "uniforms", "uniform", "value", "index", "undefined", "texture", "getTexture", "decode", "name", "EXT_FEATURE_METADATA", "name", "decode", "gltfData", "scenegraph", "GLTFScenegraph", "decodeExtFeatureMetadata", "_extension$schema", "extension", "getExtension", "schemaClasses", "schema", "classes", "featureTables", "featureTextures", "console", "warn", "schemaName", "schemaClass", "featureTable", "findFeatureTableByName", "handleFeatureTableProperties", "propertyName", "properties", "_featureTable$propert", "schemaProperty", "featureTableProperty", "numberOfFeatures", "count", "data", "getPropertyDataFromBinarySource", "bufferView", "getTypedArrayForBufferView", "type", "stringOffsetBufferView", "offsetsData", "getStringAttributes", "schemaClassName", "featureTableName", "class", "stringsCount", "stringsArray", "textDecoder", "TextDecoder", "stringOffset", "bytesPerStringSize", "index", "stringByteSize", "stringData", "subarray", "stringAttribute", "push", "EXTENSIONS", "EXT_meshopt_compression", "EXT_texture_webp", "KHR_texture_basisu", "KHR_draco_mesh_compression", "KHR_lights_punctual", "KHR_materials_unlit", "KHR_techniques_webgl", "KHR_texture_transform", "EXT_feature_metadata", "preprocessExtensions", "gltf", "options", "arguments", "length", "undefined", "context", "extensions", "filter", "extension", "useExtension", "name", "_extension$preprocess", "preprocess", "call", "decodeExtensions", "_extension$decode", "decode", "extensionName", "_options$gltf", "excludes", "excludeExtensions", "exclude", "KHR_BINARY_GLTF", "preprocess", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "image", "images", "extension", "getObjectExtension", "KHR_BINARY_GLTF", "Object", "assign", "removeObjectExtension", "buffers", "uri", "removeExtension", "GLTF_ARRAYS", "accessors", "animations", "buffers", "bufferViews", "images", "materials", "meshes", "nodes", "samplers", "scenes", "skins", "textures", "GLTF_KEYS", "accessor", "buffer", "bufferView", "image", "material", "mesh", "node", "sampler", "scene", "skin", "texture", "GLTFV1Normalizer", "constructor", "_defineProperty", "normalize", "gltf", "options", "json", "asset", "version", "undefined", "console", "warn", "concat", "Error", "_addAsset", "_convertTopLevelObjectsToArrays", "KHR_binary_glTF", "preprocess", "_convertObjectIdsToArrayIndices", "_updateObjects", "_updateMaterial", "generator", "arrayName", "_convertTopLevelObjectToArray", "mapName", "objectMap", "Array", "isArray", "id", "object", "index", "length", "push", "idToIndexMap", "_convertIdsToIndices", "_convertIdToIndex", "_convertTextureIds", "_convertMeshIds", "_convertNodeIds", "_convertSceneIds", "source", "primitive", "primitives", "attributes", "indices", "attributeName", "children", "map", "child", "topLevelArrayName", "key", "Number", "isFinite", "type", "_material$values", "_material$values2", "_material$values3", "pbrMetallicRoughness", "baseColorFactor", "metallicFactor", "roughnessFactor", "textureId", "values", "tex", "texture2d_0", "diffuseTex", "textureIndex", "findIndex", "baseColorTexture", "normalizeGLTFV1", "arguments", "COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "BYTES", "GL_SAMPLER", "TEXTURE_MAG_FILTER", "TEXTURE_MIN_FILTER", "TEXTURE_WRAP_S", "TEXTURE_WRAP_T", "REPEAT", "LINEAR", "NEAREST_MIPMAP_LINEAR", "SAMPLER_PARAMETER_GLTF_TO_GL", "magFilter", "minFilter", "wrapS", "wrapT", "DEFAULT_SAMPLER", "getBytesFromComponentType", "componentType", "getSizeFromAccessorType", "type", "GLTFPostProcessor", "constructor", "_defineProperty", "postProcess", "gltf", "options", "arguments", "length", "undefined", "json", "buffers", "images", "baseUri", "assert", "_resolveTree", "bufferViews", "map", "bufView", "i", "_resolveBufferView", "image", "_resolveImage", "samplers", "sampler", "_resolveSampler", "textures", "texture", "_resolveTexture", "accessors", "accessor", "_resolveAccessor", "materials", "material", "_resolveMaterial", "meshes", "mesh", "_resolveMesh", "nodes", "node", "_resolveNode", "skins", "skin", "_resolveSkin", "scenes", "scene", "_resolveScene", "getScene", "index", "_get", "getNode", "getSkin", "getMesh", "getMaterial", "getAccessor", "getCamera", "getTexture", "getSampler", "getImage", "getBufferView", "getBuffer", "array", "object", "console", "warn", "concat", "id", "children", "child", "reduce", "accum", "meshIndex", "primitives", "camera", "inverseBindMatrices", "primitive", "attributes", "attribute", "indices", "normalTexture", "occlusionTexture", "occlustionTexture", "emissiveTexture", "emmisiveTexture", "emissiveFactor", "pbrMetallicRoughness", "mr", "baseColorTexture", "metallicRoughnessTexture", "bufferView", "bytesPerComponent", "components", "bytesPerElement", "buffer", "ArrayType", "byteLength", "getAccessorArrayTypeAndLength", "byteOffset", "cutBuffer", "arrayBuffer", "slice", "byteStride", "_getValueFromInterleavedBuffer", "count", "value", "result", "Uint8Array", "elementOffset", "set", "source", "parameters", "key", "glEnum", "_enumSamplerParameter", "preloadedImage", "bufferIndex", "data", "_resolveCamera", "perspective", "orthographic", "postProcessGLTF", "MAGIC_glTF", "GLB_FILE_HEADER_SIZE", "GLB_CHUNK_HEADER_SIZE", "GLB_CHUNK_TYPE_JSON", "GLB_CHUNK_TYPE_BIN", "GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED", "GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED", "GLB_V1_CONTENT_FORMAT_JSON", "LE", "getMagicString", "dataView", "byteOffset", "arguments", "length", "undefined", "concat", "String", "fromCharCode", "getUint8", "isGLB", "arrayBuffer", "options", "DataView", "magic", "magic1", "getUint32", "glb", "type", "version", "byteLength", "Object", "assign", "header", "hasBinChunk", "json", "binChunks", "parseGLBV1", "parseGLBV2", "Error", "assert", "contentLength", "contentFormat", "parseJSONChunk", "parseBINChunk", "parseGLBChunksSync", "chunkLength", "chunkFormat", "strict", "padToNBytes", "jsonChunk", "Uint8Array", "buffer", "textDecoder", "TextDecoder", "jsonText", "decode", "JSON", "parse", "push", "parseGLTF", "gltf", "arrayBufferOrString", "_options$gltf", "_options$gltf2", "_options$gltf3", "_options$gltf4", "byteOffset", "arguments", "length", "undefined", "options", "context", "parseGLTFContainerSync", "normalizeGLTFV1", "normalize", "preprocessExtensions", "promises", "loadBuffers", "json", "buffers", "loadImages", "promise", "push", "decodeExtensions", "Promise", "all", "postProcess", "postProcessGLTF", "data", "uri", "baseUri", "ArrayBuffer", "isGLB", "textDecoder", "TextDecoder", "decode", "parseJSON", "glb", "parseGLBSync", "assert", "type", "concat", "_glb", "Array", "fill", "header", "hasBinChunk", "binChunks", "arrayBuffer", "byteLength", "images", "i", "buffer", "_context$fetch", "_response$arrayBuffer", "fetch", "resolveUrl", "response", "call", "imageIndices", "getReferencesImageIndices", "imageIndex", "loadImage", "Set", "textures", "texture", "source", "add", "from", "sort", "image", "index", "parse", "hasOwnProperty", "bufferView", "Number", "isFinite", "array", "getTypedArrayForBufferView", "sliceArrayBuffer", "parsedImage", "ImageLoader", "BasisLoader", "mimeType", "basis", "format", "selectSupportedBasisFormat", "compressed", "mipmaps", "width", "height", "GLTFLoader", "name", "id", "module", "version", "VERSION", "extensions", "mimeTypes", "text", "binary", "tests", "parse", "options", "gltf", "normalize", "loadBuffers", "loadImages", "decompressMeshes", "postProcess", "log", "console", "deprecatedOptions", "fetchImages", "createImages", "decompress", "arrayBuffer", "arguments", "length", "undefined", "context", "byteOffset", "parseGLTF", "waitForGLTFAssets", "gltfObjects", "remaining", "scenes", "forEach", "scene", "traverse", "model", "Object", "values", "getUniforms", "uniform", "loaded", "push", "waitWhileCondition", "some", "condition", "Promise", "resolve", "requestAnimationFrame", "DEFAULT_COLOR", "defaultProps", "scenegraph", "type", "value", "async", "getScene", "gltf", "scenes", "scene", "getAnimator", "animator", "_animations", "sizeScale", "min", "sizeMinPixels", "sizeMaxPixels", "Number", "MAX_SAFE_INTEGER", "getPosition", "x", "position", "getColor", "_lighting", "_imageBasedLightingEnvironment", "getOrientation", "getScale", "getTranslation", "getTransformMatrix", "loaders", "GLTFLoader", "ScenegraphLayer", "Layer", "getShaders", "modules", "project32", "picking", "props", "push", "pbr", "vs", "fs", "initializeState", "attributeManager", "getAttributeManager", "addInstanced", "instancePositions", "size", "fp64", "use64bitPositions", "accessor", "transition", "instanceColors", "colorFormat", "length", "normalized", "defaultValue", "instanceModelMatrix", "MATRIX_ATTRIBUTES", "updateState", "params", "oldProps", "_updateScenegraph", "_applyAnimationsProp", "state", "finalizeState", "context", "_deleteScenegraph", "gl", "scenegraphData", "ScenegraphNode", "gltfObjects", "createGLTFObjects", "_getModelOptions", "waitForGLTFAssets", "then", "setNeedsRedraw", "log", "deprecated", "options", "layer", "_applyAllAttributes", "setState", "warn", "attributesAvailable", "allAttributes", "getAttributes", "traverse", "model", "_setModelAttributes", "animationsProp", "animations", "getAnimations", "Object", "keys", "sort", "forEach", "key", "animation", "assign", "isFinite", "number", "findResult", "find", "name", "delete", "env", "waitForFullLoad", "imageBasedLightingEnvironment", "modelOptions", "isInstanced", "transpileToGLSL100", "isWebGL2", "useTangents", "updateAttributes", "changedAttributes", "draw", "moduleParameters", "parameters", "animate", "timeline", "getTime", "viewport", "opacity", "coordinateSystem", "numInstances", "getNumInstances", "worldMatrix", "setInstanceCount", "updateModuleSettings", "uniforms", "composeModelMatrix", "shouldComposeModelMatrix", "sceneModelMatrix", "u_Camera", "getUniforms", "project_uCameraPosition"]
}
