{
  "version": 3,
  "sources": ["../../@loaders.gl/schema/src/category/mesh/mesh-utils.ts", "../../@loaders.gl/schema/src/lib/batches/base-table-batch-aggregator.ts", "../../@loaders.gl/schema/src/lib/utils/row-utils.ts", "../../@loaders.gl/schema/src/lib/batches/row-table-batch-aggregator.ts", "../../@loaders.gl/schema/src/lib/batches/columnar-table-batch-aggregator.ts", "../../@loaders.gl/schema/src/lib/batches/table-batch-builder.ts", "../../@loaders.gl/schema/src/lib/utils/assert.ts", "../../@loaders.gl/schema/src/lib/schema/impl/schema.ts", "../../@loaders.gl/schema/src/lib/schema/impl/field.ts", "../../@loaders.gl/schema/src/lib/schema/impl/enum.ts", "../../@loaders.gl/schema/src/lib/schema/impl/type.ts", "../../@loaders.gl/schema/src/lib/arrow/arrow-like-type-utils.ts", "../../@loaders.gl/schema/src/category/mesh/deduce-mesh-schema.ts", "../../@loaders.gl/schema/src/lib/utils/async-queue.ts"],
  "sourcesContent": ["// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\nimport {MeshAttributes} from './mesh-types';\n\ntype TypedArrays = {[key: string]: TypedArray};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: MeshAttributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n", "import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  rows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.rows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.rows = null;\n\n    const batch: TableBatch = {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n\n    return batch;\n  }\n}\n", "/** Convert an object row to an array row */\nexport function convertToObjectRow(\n  arrayRow: any[],\n  headers: string[]\n): {[columnName: string]: any} {\n  if (!arrayRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const objectRow = {};\n  for (let i = 0; i < headers.length; i++) {\n    objectRow[headers[i]] = arrayRow[i];\n  }\n  return objectRow;\n}\n\n/** Convert an object row to an array row */\nexport function convertToArrayRow(\n  objectRow: {[columnName: string]: any},\n  headers: string[]\n): any[] {\n  if (!objectRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const arrayRow = new Array(headers.length);\n  for (let i = 0; i < headers.length; i++) {\n    arrayRow[i] = objectRow[headers[i]];\n  }\n  return arrayRow;\n}\n", "import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\n// import type {ArrayRowTableBatch, ObjectRowTableBatch} from '../../category/table';\nimport {convertToArrayRow, convertToObjectRow} from '../utils/row-utils';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  objectRows: {[columnName: string]: any} | null = null;\n  arrayRows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'object-row-table':\n        const rowObject = convertToObjectRow(row, this._headers);\n        this.addObjectRow(rowObject, cursor);\n        break;\n      case 'array-row-table':\n        this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);\n        this.arrayRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'array-row-table':\n        const rowArray = convertToArrayRow(row, this._headers);\n        this.addArrayRow(rowArray, cursor);\n        break;\n      case 'object-row-table':\n        this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);\n        this.objectRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.arrayRows || this.objectRows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.arrayRows = null;\n    this.objectRows = null;\n\n    return {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n  }\n}\n", "import type {Schema} from '../schema/schema';\nimport type {ColumnarTableBatch, ArrowTableBatch} from '../../category/table/table-types';\nimport {TableBatchAggregator} from './table-batch-aggregator';\n\ntype ColumnarTableBatchOptions = {};\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class ColumnarTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  length: number = 0;\n  allocated: number = 0;\n  columns: {[columnName: string]: any[]} = {};\n\n  constructor(schema: Schema, options: ColumnarTableBatchOptions) {\n    this.schema = schema;\n    this._reallocateColumns();\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[]) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    let i = 0;\n    // TODO what if no csv header, columns not populated?\n    for (const fieldName in this.columns) {\n      this.columns[fieldName][this.length] = row[i++];\n    }\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}): void {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n\n  getBatch(): ColumnarTableBatch | ArrowTableBatch | null {\n    this._pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n\n    this.columns = {};\n\n    const batch: ColumnarTableBatch = {\n      shape: 'columnar-table',\n      batchType: 'data',\n      data: columns,\n      schema: this.schema,\n      length: this.length\n    };\n\n    return batch;\n  }\n\n  // HELPERS\n\n  _reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n\n    // @ts-ignore TODO\n    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n    this.columns = {};\n\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n\n  _pruneColumns() {\n    for (const [columnName, column] of Object.entries(this.columns)) {\n      this.columns[columnName] = column.slice(0, this.length);\n    }\n  }\n}\n", "import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\nimport type {TableBatchAggregator, TableBatchConstructor} from './table-batch-aggregator';\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\n\n// TODO define interface instead\ntype TableBatchBuilderOptions = {\n  shape: 'row-table' | 'array-row-table' | 'object-row-table' | 'columnar-table' | 'arrow-table';\n  batchSize?: number | 'auto';\n  batchDebounceMs?: number;\n  limit: number;\n  _limitMB: number;\n};\n\ntype GetBatchOptions = {\n  bytesUsed?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_OPTIONS: Required<TableBatchBuilderOptions> = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\n\nconst ERR_MESSAGE = 'TableBatchBuilder';\n\n/** Incrementally builds batches from a stream of rows */\nexport default class TableBatchBuilder {\n  schema: Schema;\n  options: Required<TableBatchBuilderOptions>;\n\n  private aggregator: TableBatchAggregator | null = null;\n  private batchCount: number = 0;\n  private bytesUsed: number = 0;\n  private isChunkComplete: boolean = false;\n  private lastBatchEmittedMs: number = Date.now();\n  private totalLength: number = 0;\n  private totalBytes: number = 0;\n  private rowBytes: number = 0;\n\n  static ArrowBatch?: TableBatchConstructor;\n\n  constructor(schema: Schema, options?: TableBatchBuilderOptions) {\n    this.schema = schema;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  limitReached(): boolean {\n    if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated Use addArrayRow or addObjectRow */\n  addRow(row: any[] | {[columnName: string]: any}): void {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n\n  /** Add one row to the batch */\n  protected addArrayRow(row: any[]) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n\n  /** Add one row to the batch */\n  protected addObjectRow(row: {[columnName: string]: any}): void {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n\n  /** Mark an incoming raw memory chunk has completed */\n  chunkComplete(chunk: ArrayBuffer | string): void {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n\n  getFullBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n\n  getFinalBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._getBatch(options);\n  }\n\n  // INTERNAL\n\n  _estimateRowMB(row: any[] | object): number {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n\n  private _isFull(): boolean {\n    // No batch, not ready\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n\n    // if batchSize === 'auto' we wait for chunk to complete\n    // if batchSize === number, ensure we have enough rows\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n\n    // Debounce batches\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n\n    // Emit batch\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n\n  /**\n   * bytesUsed can be set via chunkComplete or via getBatch*\n   */\n  private _getBatch(options?: GetBatchOptions): TableBatch | null {\n    if (!this.aggregator) {\n      return null;\n    }\n\n    // TODO - this can overly increment bytes used?\n    if (options?.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch() as TableBatch;\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n\n  private _getTableBatchType(): TableBatchConstructor {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n}\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: boolean, message?: string) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n", "import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields: Field[]): void {\n  const usedNames: Record<string, boolean> = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n", "import {DataType} from './type';\n\n/**\n * ArrowJS `Field` API-compatible class for row-based tables\n * https://loaders.gl/arrowjs/docs/api-reference/field\n * A field holds name, nullable, and metadata information about a table \"column\"\n * A Schema is essentially a list of fields\n */\nexport default class Field {\n  name: string;\n  type: DataType;\n  nullable: boolean;\n  metadata: Map<string, string>;\n\n  constructor(\n    name: string,\n    type: DataType,\n    nullable = false,\n    metadata: Map<string, string> = new Map()\n  ) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n\n  get typeId(): number {\n    return this.type && this.type.typeId;\n  }\n\n  clone(): Field {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n\n  compareTo(other: this): boolean {\n    return (\n      this.name === other.name &&\n      this.type === other.type &&\n      this.nullable === other.nullable &&\n      this.metadata === other.metadata\n    );\n  }\n\n  toString(): string {\n    return `${this.type}${this.nullable ? ', nullable' : ''}${\n      this.metadata ? `, metadata: ${this.metadata}` : ''\n    }`;\n  }\n}\n", "// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport enum Type {\n  /** The default placeholder type */\n  NONE = 0,\n  /** A NULL type having no physical storage */\n  Null = 1,\n  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n  Int = 2,\n  /** 2, 4, or 8-byte floating point value */\n  Float = 3,\n  /** Variable-length bytes (no guarantee of UTF8-ness) */\n  Binary = 4,\n  /** UTF8 variable-length string as List<Char> */\n  Utf8 = 5,\n  /** Boolean as 1 bit, LSB bit-packed ordering */\n  Bool = 6,\n  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n  Decimal = 7,\n  /** int32_t days or int64_t milliseconds since the UNIX epoch */\n  Date = 8,\n  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n  Time = 9,\n  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n  Timestamp = 10,\n  /** YEAR_MONTH or DAY_TIME interval in SQL style */\n  Interval = 11,\n  /** A list of some logical data type */\n  List = 12,\n  /** Struct of logical types */\n  Struct = 13,\n  /** Union of logical types */\n  Union = 14,\n  /** Fixed-size binary. Each value occupies the same number of bytes */\n  FixedSizeBinary = 15,\n  /** Fixed-size list. Each value occupies the same number of bytes */\n  FixedSizeList = 16,\n  /** Map of named logical types */\n  Map = 17,\n\n  /** Dictionary aka Category type */\n  Dictionary = -1,\n  Int8 = -2,\n  Int16 = -3,\n  Int32 = -4,\n  Int64 = -5,\n  Uint8 = -6,\n  Uint16 = -7,\n  Uint32 = -8,\n  Uint64 = -9,\n  Float16 = -10,\n  Float32 = -11,\n  Float64 = -12,\n  DateDay = -13,\n  DateMillisecond = -14,\n  TimestampSecond = -15,\n  TimestampMillisecond = -16,\n  TimestampMicrosecond = -17,\n  TimestampNanosecond = -18,\n  TimeSecond = -19,\n  TimeMillisecond = -20,\n  TimeMicrosecond = -21,\n  TimeNanosecond = -22,\n  DenseUnion = -23,\n  SparseUnion = -24,\n  IntervalDayTime = -25,\n  IntervalYearMonth = -26\n}\n", "// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\nimport {Type} from './enum';\n\nimport Field from './field';\n\nexport {Type} from './enum';\n\nexport type TypedIntArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\nexport type TypedFloatArray = Float32Array | Float64Array;\n\nexport type TypedArray = TypedIntArray | TypedFloatArray;\n\nexport type AnyArrayType = Array<any> | TypedIntArray | TypedFloatArray;\n\nexport class DataType {\n  static isNull(x: any): boolean {\n    return x && x.typeId === Type.Null;\n  }\n  static isInt(x: any): boolean {\n    return x && x.typeId === Type.Int;\n  }\n  static isFloat(x: any): boolean {\n    return x && x.typeId === Type.Float;\n  }\n  static isBinary(x: any): boolean {\n    return x && x.typeId === Type.Binary;\n  }\n  static isUtf8(x: any): boolean {\n    return x && x.typeId === Type.Utf8;\n  }\n  static isBool(x: any): boolean {\n    return x && x.typeId === Type.Bool;\n  }\n  static isDecimal(x: any): boolean {\n    return x && x.typeId === Type.Decimal;\n  }\n  static isDate(x: any): boolean {\n    return x && x.typeId === Type.Date;\n  }\n  static isTime(x: any): boolean {\n    return x && x.typeId === Type.Time;\n  }\n  static isTimestamp(x: any): boolean {\n    return x && x.typeId === Type.Timestamp;\n  }\n  static isInterval(x: any): boolean {\n    return x && x.typeId === Type.Interval;\n  }\n  static isList(x: any): boolean {\n    return x && x.typeId === Type.List;\n  }\n  static isStruct(x: any): boolean {\n    return x && x.typeId === Type.Struct;\n  }\n  static isUnion(x: any): boolean {\n    return x && x.typeId === Type.Union;\n  }\n  static isFixedSizeBinary(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n  static isMap(x: any): boolean {\n    return x && x.typeId === Type.Map;\n  }\n  static isDictionary(x: any): boolean {\n    return x && x.typeId === Type.Dictionary;\n  }\n\n  get typeId(): Type {\n    return Type.NONE;\n  }\n\n  // get ArrayType(): AnyArrayType {\n  //   return Int8Array;\n  // }\n\n  // get ArrayType() { return Array; }\n  compareTo(other: DataType): boolean {\n    // TODO\n    return this === other; // comparer.visit(this, other);\n  }\n}\n\n// NULL\n\nexport class Null extends DataType {\n  get typeId(): Type {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Null';\n  }\n  toString(): string {\n    return 'Null';\n  }\n}\n\n// BOOLEANS\n\nexport class Bool extends DataType {\n  get typeId(): Type {\n    return Type.Bool;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Bool';\n  }\n  toString(): string {\n    return 'Bool';\n  }\n}\n\n// INTS\n\nexport class Int extends DataType {\n  readonly isSigned: boolean;\n  readonly bitWidth: number;\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Int;\n  }\n  // get ArrayType() {\n  //   switch (this.bitWidth) {\n  //     case 8:\n  //       return this.isSigned ? Int8Array : Uint8Array;\n  //     case 16:\n  //       return this.isSigned ? Int16Array : Uint16Array;\n  //     case 32:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     case 64:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Int';\n  }\n  toString(): string {\n    return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;\n  }\n}\n\nexport class Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nexport class Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nexport class Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nexport class Int64 extends Int {\n  constructor() {\n    super(true, 64);\n  }\n}\nexport class Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nexport class Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nexport class Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nexport class Uint64 extends Int {\n  constructor() {\n    super(false, 64);\n  }\n}\n\n// FLOATS\n\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n\nexport class Float extends DataType {\n  readonly precision: number;\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId(): Type {\n    return Type.Float;\n  }\n  // get ArrayType() {\n  //   switch (this.precision) {\n  //     case Precision.HALF:\n  //       return Uint16Array;\n  //     case Precision.SINGLE:\n  //       return Float32Array;\n  //     case Precision.DOUBLE:\n  //       return Float64Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Float';\n  }\n  toString(): string {\n    return `Float${this.precision}`;\n  }\n}\n\nexport class Float16 extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nexport class Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nexport class Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\n\nexport class Binary extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\n\n// STRINGS\n\nexport class Utf8 extends DataType {\n  get typeId(): Type {\n    return Type.Utf8;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Utf8';\n  }\n  toString(): string {\n    return 'Utf8';\n  }\n}\n\n// DATES, TIMES AND INTERVALS\n\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n\nexport class Date extends DataType {\n  readonly unit: number;\n  constructor(unit) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Date;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Date';\n  }\n  toString(): string {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n}\n\nexport class DateDay extends Date {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nexport class DateMillisecond extends Date {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\n\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n\nexport class Time extends DataType {\n  readonly unit: any;\n  readonly bitWidth: number;\n\n  constructor(unit: any, bitWidth: number) {\n    super();\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Time;\n  }\n  toString(): string {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Time';\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n}\n\nexport class TimeSecond extends Time {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nexport class TimeMillisecond extends Time {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }\n// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }\n\nexport class Timestamp extends DataType {\n  readonly unit: any;\n  readonly timezone: any;\n\n  constructor(unit: any, timezone = null) {\n    super();\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId(): Type {\n    return Type.Timestamp;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Timestamp';\n  }\n  toString(): string {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;\n  }\n}\n\nexport class TimestampSecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nexport class TimestampMillisecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nexport class TimestampMicrosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nexport class TimestampNanosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\n\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n\nexport class Interval extends DataType {\n  readonly unit: number;\n  constructor(unit: number) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Interval;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Interval';\n  }\n  toString(): string {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n}\n\nexport class IntervalDayTime extends Interval {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nexport class IntervalYearMonth extends Interval {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n\nexport class FixedSizeList extends DataType {\n  readonly listSize: number;\n  readonly children: Field[];\n\n  constructor(listSize: number, child: Field) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId(): Type {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  // get ArrayType() {\n  //   return this.valueType.ArrayType;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'FixedSizeList';\n  }\n  toString(): string {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n}\n\nexport class Struct extends DataType {\n  public readonly children: Field[];\n\n  constructor(children: Field[]) {\n    super();\n    this.children = children;\n  }\n\n  public get typeId() {\n    return Type.Struct;\n  }\n  public toString() {\n    return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(', ')}}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Struct';\n  }\n}\n", "import type {TypedArray} from '../../types';\nimport {\n  DataType,\n  Float32,\n  Float64,\n  Int16,\n  Int32,\n  Int8,\n  Uint16,\n  Uint32,\n  Uint8\n} from '../schema/schema';\n\nexport function getArrowTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n    case Uint8Array:\n      return new Uint8();\n    case Int16Array:\n      return new Int16();\n    case Uint16Array:\n      return new Uint16();\n    case Int32Array:\n      return new Int32();\n    case Uint32Array:\n      return new Uint32();\n    case Float32Array:\n      return new Float32();\n    case Float64Array:\n      return new Float64();\n    default:\n      throw new Error('array type not supported');\n  }\n}\n", "import {MeshAttribute, MeshAttributes} from './mesh-types';\nimport {Schema, Field, FixedSizeList} from '../../lib/schema/schema';\nimport {getArrowTypeFromTypedArray} from '../../lib/arrow/arrow-like-type-utils';\n\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(\n  attributes: MeshAttributes,\n  metadata?: Map<string, string>\n): Schema {\n  const fields = deduceMeshFields(attributes);\n  return new Schema(fields, metadata);\n}\n\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(\n  attributeName: string,\n  attribute: MeshAttribute,\n  optionalMetadata?: Map<string, string>\n): Field {\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  const field = new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadata\n  );\n  return field;\n}\n\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes: MeshAttributes): Field[] {\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute: MeshAttribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute: MeshAttribute): Map<string, string> {\n  const result = new Map();\n  if ('byteOffset' in attribute) {\n    result.set('byteOffset', attribute.byteOffset!.toString(10));\n  }\n  if ('byteStride' in attribute) {\n    result.set('byteStride', attribute.byteStride!.toString(10));\n  }\n  if ('normalized' in attribute) {\n    result.set('normalized', attribute.normalized!.toString());\n  }\n  return result;\n}\n", "// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\nclass ArrayQueue<T> extends Array<T> {\n  enqueue(value: T) {\n    // Add at the end\n    return this.push(value);\n  }\n  dequeue(): T {\n    // Remove first element\n    return this.shift() as T;\n  }\n}\n\nexport default class AsyncQueue<T> {\n  private _values: ArrayQueue<T | Error>;\n  private _settlers: ArrayQueue<{resolve: (value: any) => void; reject: (reason?: any) => void}>;\n  private _closed: boolean;\n\n  constructor() {\n    // enqueues > dequeues\n    this._values = new ArrayQueue<T>();\n    // dequeues > enqueues\n    this._settlers = new ArrayQueue<{\n      resolve: (value: any) => void;\n      reject: (reason?: any) => void;\n    }>();\n    this._closed = false;\n  }\n\n  close(): void {\n    while (this._settlers.length > 0) {\n      this._settlers.dequeue().resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.dequeue();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.enqueue(value);\n    }\n  }\n\n  /**\n   * @returns a Promise for an IteratorResult\n   */\n  next(): Promise<any> {\n    if (this._values.length > 0) {\n      const value = this._values.dequeue();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({value});\n    }\n\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true});\n    }\n    // Wait for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.enqueue({resolve, reject});\n    });\n  }\n}\n\n/**\n * @returns a Promise for an Array with the elements in `asyncIterable`\n */\nexport async function takeAsync(\n  asyncIterable: AsyncIterable<any>,\n  count = Infinity\n): Promise<any[]> {\n  const result: Array<any> = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value, done} = await iterator.next();\n    if (done) {\n      break;\n    }\n    result.push(value);\n  }\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["getMeshBoundingBox", "attributes", "minX", "Infinity", "minY", "minZ", "maxX", "maxY", "maxZ", "positions", "POSITION", "value", "len", "length", "i", "x", "y", "z", "DEFAULT_ROW_COUNT", "RowTableBatchAggregator", "constructor", "schema", "options", "_defineProperty", "Array", "isArray", "_headers", "key", "index", "name", "rowCount", "length", "addArrayRow", "row", "cursor", "Number", "isFinite", "rows", "addObjectRow", "getBatch", "slice", "batch", "shape", "batchType", "data", "convertToObjectRow", "arrayRow", "headers", "Error", "objectRow", "i", "length", "convertToArrayRow", "Array", "DEFAULT_ROW_COUNT", "RowTableBatchAggregator", "constructor", "schema", "options", "_defineProperty", "Array", "isArray", "_headers", "key", "index", "name", "rowCount", "length", "addArrayRow", "row", "cursor", "Number", "isFinite", "shape", "rowObject", "convertToObjectRow", "addObjectRow", "arrayRows", "rowArray", "convertToArrayRow", "objectRows", "getBatch", "rows", "slice", "batchType", "data", "DEFAULT_ROW_COUNT", "ColumnarTableBatchAggregator", "constructor", "schema", "options", "_defineProperty", "_reallocateColumns", "rowCount", "length", "addArrayRow", "row", "i", "fieldName", "columns", "addObjectRow", "getBatch", "_pruneColumns", "Array", "isArray", "field", "name", "index", "batch", "shape", "batchType", "data", "allocated", "ArrayType", "type", "Float32Array", "oldColumn", "ArrayBuffer", "isView", "typedArray", "set", "columnName", "column", "Object", "entries", "slice", "DEFAULT_OPTIONS", "shape", "batchSize", "batchDebounceMs", "limit", "_limitMB", "ERR_MESSAGE", "TableBatchBuilder", "constructor", "schema", "options", "_defineProperty", "Date", "now", "limitReached", "_this$options", "_this$options2", "Boolean", "totalLength", "totalBytes", "addRow", "row", "rowBytes", "_estimateRowMB", "Array", "isArray", "addArrayRow", "addObjectRow", "aggregator", "TableBatchType", "_getTableBatchType", "chunkComplete", "chunk", "ArrayBuffer", "bytesUsed", "byteLength", "length", "isChunkComplete", "getFullBatch", "_isFull", "_getBatch", "getFinalBatch", "Object", "keys", "rowCount", "lastBatchEmittedMs", "normalizedBatch", "getBatch", "count", "batchCount", "assign", "BaseTableBatchAggregator", "RowTableBatchAggregator", "ColumnarTableBatchAggregator", "ArrowBatch", "Error", "assert", "condition", "message", "Error", "Schema", "constructor", "fields", "metadata", "_defineProperty", "assert", "Array", "isArray", "checkNames", "Map", "compareTo", "other", "length", "i", "select", "nameMap", "Object", "create", "_len", "arguments", "columnNames", "_key", "name", "selectedFields", "filter", "field", "selectAt", "_len2", "columnIndices", "_key2", "map", "index", "Boolean", "assign", "schemaOrFields", "otherSchema", "mergeMaps", "fieldMap", "mergedFields", "values", "usedNames", "console", "warn", "m1", "m2", "Field", "constructor", "name", "type", "nullable", "arguments", "length", "undefined", "metadata", "Map", "_defineProperty", "typeId", "clone", "compareTo", "other", "toString", "concat", "Type", "DataType", "isNull", "x", "typeId", "Type", "Null", "isInt", "Int", "isFloat", "Float", "isBinary", "Binary", "isUtf8", "Utf8", "isBool", "Bool", "isDecimal", "Decimal", "isDate", "Date", "isTime", "Time", "isTimestamp", "Timestamp", "isInterval", "Interval", "isList", "List", "isStruct", "Struct", "isUnion", "Union", "isFixedSizeBinary", "FixedSizeBinary", "isFixedSizeList", "FixedSizeList", "isMap", "Map", "isDictionary", "Dictionary", "NONE", "compareTo", "other", "Symbol", "toStringTag", "toString", "_Symbol$toStringTag", "constructor", "isSigned", "bitWidth", "_defineProperty", "concat", "Int8", "Int16", "Int32", "Uint8", "Int", "constructor", "Uint16", "Uint32", "Precision", "HALF", "SINGLE", "DOUBLE", "_Symbol$toStringTag2", "Symbol", "toStringTag", "Float", "DataType", "constructor", "precision", "_defineProperty", "typeId", "Type", "toString", "concat", "Float32", "Float", "constructor", "Precision", "SINGLE", "Float64", "DOUBLE", "Binary", "DataType", "typeId", "Type", "toString", "Symbol", "toStringTag", "Utf8", "DateUnit", "DAY", "MILLISECOND", "_Symbol$toStringTag3", "Date", "unit", "_defineProperty", "concat", "TimeUnit", "SECOND", "MILLISECOND", "MICROSECOND", "NANOSECOND", "_Symbol$toStringTag4", "Symbol", "toStringTag", "Time", "DataType", "constructor", "unit", "bitWidth", "_defineProperty", "typeId", "Type", "toString", "concat", "_Symbol$toStringTag5", "Symbol", "toStringTag", "Timestamp", "DataType", "constructor", "unit", "timezone", "arguments", "length", "undefined", "_defineProperty", "typeId", "Type", "toString", "concat", "TimeUnit", "IntervalUnit", "DAY_TIME", "YEAR_MONTH", "_Symbol$toStringTag6", "Symbol", "toStringTag", "Interval", "DataType", "constructor", "unit", "_defineProperty", "typeId", "Type", "toString", "concat", "_Symbol$toStringTag7", "Symbol", "toStringTag", "FixedSizeList", "DataType", "constructor", "listSize", "child", "_defineProperty", "children", "typeId", "Type", "valueType", "type", "valueField", "toString", "concat", "_Symbol$toStringTag8", "Struct", "map", "f", "name", "join", "getArrowTypeFromTypedArray", "array", "constructor", "Int8Array", "Int8", "Uint8Array", "Uint8", "Int16Array", "Int16", "Uint16Array", "Uint16", "Int32Array", "Int32", "Uint32Array", "Uint32", "Float32Array", "Float32", "Float64Array", "Float64", "Error", "deduceMeshField", "attributeName", "attribute", "optionalMetadata", "type", "getArrowTypeFromTypedArray", "value", "metadata", "makeMeshAttributeMetadata", "field", "Field", "FixedSizeList", "size", "makeMeshAttributeMetadata", "attribute", "result", "Map", "set", "byteOffset", "toString", "byteStride", "normalized", "ArrayQueue", "Array", "enqueue", "value", "push", "dequeue", "shift", "_Symbol$asyncIterator", "Symbol", "asyncIterator", "AsyncQueue", "constructor", "_defineProperty", "_values", "_settlers", "_closed", "close", "length", "resolve", "done", "Error", "settler", "reject", "next", "Promise"]
}
