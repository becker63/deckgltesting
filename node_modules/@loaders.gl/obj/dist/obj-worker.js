(() => {
  // ../worker-utils/src/lib/worker-utils/get-transfer-list.ts
  function getTransferList(object, recursive = true, transfers) {
    const transfersSet = transfers || new Set();
    if (!object) {
    } else if (isTransferable(object)) {
      transfersSet.add(object);
    } else if (isTransferable(object.buffer)) {
      transfersSet.add(object.buffer);
    } else if (ArrayBuffer.isView(object)) {
    } else if (recursive && typeof object === "object") {
      for (const key in object) {
        getTransferList(object[key], recursive, transfersSet);
      }
    }
    return transfers === void 0 ? Array.from(transfersSet) : [];
  }
  function isTransferable(object) {
    if (!object) {
      return false;
    }
    if (object instanceof ArrayBuffer) {
      return true;
    }
    if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
      return true;
    }
    if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
      return true;
    }
    if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
      return true;
    }
    return false;
  }

  // ../worker-utils/src/lib/worker-farm/worker-body.ts
  function getParentPort() {
    let parentPort;
    try {
      eval("globalThis.parentPort = require('worker_threads').parentPort");
      parentPort = globalThis.parentPort;
    } catch {
    }
    return parentPort;
  }
  var onMessageWrapperMap = new Map();
  var WorkerBody = class {
    static inWorkerThread() {
      return typeof self !== "undefined" || Boolean(getParentPort());
    }
    static set onmessage(onMessage) {
      function handleMessage(message) {
        const parentPort3 = getParentPort();
        const { type, payload } = parentPort3 ? message : message.data;
        onMessage(type, payload);
      }
      const parentPort2 = getParentPort();
      if (parentPort2) {
        parentPort2.on("message", handleMessage);
        parentPort2.on("exit", () => console.debug("Node worker closing"));
      } else {
        globalThis.onmessage = handleMessage;
      }
    }
    static addEventListener(onMessage) {
      let onMessageWrapper = onMessageWrapperMap.get(onMessage);
      if (!onMessageWrapper) {
        onMessageWrapper = (message) => {
          if (!isKnownMessage(message)) {
            return;
          }
          const parentPort3 = getParentPort();
          const { type, payload } = parentPort3 ? message : message.data;
          onMessage(type, payload);
        };
      }
      const parentPort2 = getParentPort();
      if (parentPort2) {
        console.error("not implemented");
      } else {
        globalThis.addEventListener("message", onMessageWrapper);
      }
    }
    static removeEventListener(onMessage) {
      const onMessageWrapper = onMessageWrapperMap.get(onMessage);
      onMessageWrapperMap.delete(onMessage);
      const parentPort2 = getParentPort();
      if (parentPort2) {
        console.error("not implemented");
      } else {
        globalThis.removeEventListener("message", onMessageWrapper);
      }
    }
    static postMessage(type, payload) {
      const data = { source: "loaders.gl", type, payload };
      const transferList = getTransferList(payload);
      const parentPort2 = getParentPort();
      if (parentPort2) {
        parentPort2.postMessage(data, transferList);
      } else {
        globalThis.postMessage(data, transferList);
      }
    }
  };
  function isKnownMessage(message) {
    const { type, data } = message;
    return type === "message" && data && typeof data.source === "string" && data.source.startsWith("loaders.gl");
  }

  // ../loader-utils/src/lib/worker-loader-utils/create-loader-worker.ts
  var requestId = 0;
  function createLoaderWorker(loader) {
    if (!WorkerBody.inWorkerThread()) {
      return;
    }
    WorkerBody.onmessage = async (type, payload) => {
      switch (type) {
        case "process":
          try {
            const { input, options = {}, context = {} } = payload;
            const result = await parseData({
              loader,
              arrayBuffer: input,
              options,
              context: {
                ...context,
                parse: parseOnMainThread
              }
            });
            WorkerBody.postMessage("done", { result });
          } catch (error) {
            const message = error instanceof Error ? error.message : "";
            WorkerBody.postMessage("error", { error: message });
          }
          break;
        default:
      }
    };
  }
  function parseOnMainThread(arrayBuffer, options) {
    return new Promise((resolve, reject) => {
      const id = requestId++;
      const onMessage = (type, payload2) => {
        if (payload2.id !== id) {
          return;
        }
        switch (type) {
          case "done":
            WorkerBody.removeEventListener(onMessage);
            resolve(payload2.result);
            break;
          case "error":
            WorkerBody.removeEventListener(onMessage);
            reject(payload2.error);
            break;
          default:
        }
      };
      WorkerBody.addEventListener(onMessage);
      const payload = { id, input: arrayBuffer, options };
      WorkerBody.postMessage("process", payload);
    });
  }
  async function parseData({ loader, arrayBuffer, options, context }) {
    let data;
    let parser;
    if (loader.parseSync || loader.parse) {
      data = arrayBuffer;
      parser = loader.parseSync || loader.parse;
    } else if (loader.parseTextSync) {
      const textDecoder = new TextDecoder();
      data = textDecoder.decode(arrayBuffer);
      parser = loader.parseTextSync;
    } else {
      throw new Error(`Could not load data with ${loader.name} loader`);
    }
    options = {
      ...options,
      modules: loader && loader.options && loader.options.modules || {},
      worker: false
    };
    return await parser(data, { ...options }, context, loader);
  }

  // ../schema/src/category/mesh/mesh-utils.ts
  function getMeshBoundingBox(attributes) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    const positions = attributes.POSITION ? attributes.POSITION.value : [];
    const len = positions && positions.length;
    for (let i = 0; i < len; i += 3) {
      const x = positions[i];
      const y = positions[i + 1];
      const z = positions[i + 2];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      minZ = z < minZ ? z : minZ;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      maxZ = z > maxZ ? z : maxZ;
    }
    return [
      [minX, minY, minZ],
      [maxX, maxY, maxZ]
    ];
  }

  // ../schema/src/lib/utils/assert.ts
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // ../schema/src/lib/schema/impl/schema.ts
  var Schema = class {
    constructor(fields, metadata) {
      assert(Array.isArray(fields));
      checkNames(fields);
      this.fields = fields;
      this.metadata = metadata || new Map();
    }
    compareTo(other) {
      if (this.metadata !== other.metadata) {
        return false;
      }
      if (this.fields.length !== other.fields.length) {
        return false;
      }
      for (let i = 0; i < this.fields.length; ++i) {
        if (!this.fields[i].compareTo(other.fields[i])) {
          return false;
        }
      }
      return true;
    }
    select(...columnNames) {
      const nameMap = Object.create(null);
      for (const name of columnNames) {
        nameMap[name] = true;
      }
      const selectedFields = this.fields.filter((field) => nameMap[field.name]);
      return new Schema(selectedFields, this.metadata);
    }
    selectAt(...columnIndices) {
      const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);
      return new Schema(selectedFields, this.metadata);
    }
    assign(schemaOrFields) {
      let fields;
      let metadata = this.metadata;
      if (schemaOrFields instanceof Schema) {
        const otherSchema = schemaOrFields;
        fields = otherSchema.fields;
        metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);
      } else {
        fields = schemaOrFields;
      }
      const fieldMap = Object.create(null);
      for (const field of this.fields) {
        fieldMap[field.name] = field;
      }
      for (const field of fields) {
        fieldMap[field.name] = field;
      }
      const mergedFields = Object.values(fieldMap);
      return new Schema(mergedFields, metadata);
    }
  };
  function checkNames(fields) {
    const usedNames = {};
    for (const field of fields) {
      if (usedNames[field.name]) {
        console.warn("Schema: duplicated field name", field.name, field);
      }
      usedNames[field.name] = true;
    }
  }
  function mergeMaps(m1, m2) {
    return new Map([...m1 || new Map(), ...m2 || new Map()]);
  }

  // ../schema/src/lib/schema/impl/field.ts
  var Field = class {
    constructor(name, type, nullable = false, metadata = new Map()) {
      this.name = name;
      this.type = type;
      this.nullable = nullable;
      this.metadata = metadata;
    }
    get typeId() {
      return this.type && this.type.typeId;
    }
    clone() {
      return new Field(this.name, this.type, this.nullable, this.metadata);
    }
    compareTo(other) {
      return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
    }
    toString() {
      return `${this.type}${this.nullable ? ", nullable" : ""}${this.metadata ? `, metadata: ${this.metadata}` : ""}`;
    }
  };

  // ../schema/src/lib/schema/impl/enum.ts
  var Type;
  (function(Type2) {
    Type2[Type2["NONE"] = 0] = "NONE";
    Type2[Type2["Null"] = 1] = "Null";
    Type2[Type2["Int"] = 2] = "Int";
    Type2[Type2["Float"] = 3] = "Float";
    Type2[Type2["Binary"] = 4] = "Binary";
    Type2[Type2["Utf8"] = 5] = "Utf8";
    Type2[Type2["Bool"] = 6] = "Bool";
    Type2[Type2["Decimal"] = 7] = "Decimal";
    Type2[Type2["Date"] = 8] = "Date";
    Type2[Type2["Time"] = 9] = "Time";
    Type2[Type2["Timestamp"] = 10] = "Timestamp";
    Type2[Type2["Interval"] = 11] = "Interval";
    Type2[Type2["List"] = 12] = "List";
    Type2[Type2["Struct"] = 13] = "Struct";
    Type2[Type2["Union"] = 14] = "Union";
    Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
    Type2[Type2["Map"] = 17] = "Map";
    Type2[Type2["Dictionary"] = -1] = "Dictionary";
    Type2[Type2["Int8"] = -2] = "Int8";
    Type2[Type2["Int16"] = -3] = "Int16";
    Type2[Type2["Int32"] = -4] = "Int32";
    Type2[Type2["Int64"] = -5] = "Int64";
    Type2[Type2["Uint8"] = -6] = "Uint8";
    Type2[Type2["Uint16"] = -7] = "Uint16";
    Type2[Type2["Uint32"] = -8] = "Uint32";
    Type2[Type2["Uint64"] = -9] = "Uint64";
    Type2[Type2["Float16"] = -10] = "Float16";
    Type2[Type2["Float32"] = -11] = "Float32";
    Type2[Type2["Float64"] = -12] = "Float64";
    Type2[Type2["DateDay"] = -13] = "DateDay";
    Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
    Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
    Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
    Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
    Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
    Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  })(Type || (Type = {}));

  // ../schema/src/lib/schema/impl/type.ts
  var DataType = class {
    static isNull(x) {
      return x && x.typeId === Type.Null;
    }
    static isInt(x) {
      return x && x.typeId === Type.Int;
    }
    static isFloat(x) {
      return x && x.typeId === Type.Float;
    }
    static isBinary(x) {
      return x && x.typeId === Type.Binary;
    }
    static isUtf8(x) {
      return x && x.typeId === Type.Utf8;
    }
    static isBool(x) {
      return x && x.typeId === Type.Bool;
    }
    static isDecimal(x) {
      return x && x.typeId === Type.Decimal;
    }
    static isDate(x) {
      return x && x.typeId === Type.Date;
    }
    static isTime(x) {
      return x && x.typeId === Type.Time;
    }
    static isTimestamp(x) {
      return x && x.typeId === Type.Timestamp;
    }
    static isInterval(x) {
      return x && x.typeId === Type.Interval;
    }
    static isList(x) {
      return x && x.typeId === Type.List;
    }
    static isStruct(x) {
      return x && x.typeId === Type.Struct;
    }
    static isUnion(x) {
      return x && x.typeId === Type.Union;
    }
    static isFixedSizeBinary(x) {
      return x && x.typeId === Type.FixedSizeBinary;
    }
    static isFixedSizeList(x) {
      return x && x.typeId === Type.FixedSizeList;
    }
    static isMap(x) {
      return x && x.typeId === Type.Map;
    }
    static isDictionary(x) {
      return x && x.typeId === Type.Dictionary;
    }
    get typeId() {
      return Type.NONE;
    }
    compareTo(other) {
      return this === other;
    }
  };
  var Null = class extends DataType {
    get typeId() {
      return Type.Null;
    }
    get [Symbol.toStringTag]() {
      return "Null";
    }
    toString() {
      return "Null";
    }
  };
  var Bool = class extends DataType {
    get typeId() {
      return Type.Bool;
    }
    get [Symbol.toStringTag]() {
      return "Bool";
    }
    toString() {
      return "Bool";
    }
  };
  var Int = class extends DataType {
    constructor(isSigned, bitWidth) {
      super();
      this.isSigned = isSigned;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Int;
    }
    get [Symbol.toStringTag]() {
      return "Int";
    }
    toString() {
      return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`;
    }
  };
  var Int8 = class extends Int {
    constructor() {
      super(true, 8);
    }
  };
  var Int16 = class extends Int {
    constructor() {
      super(true, 16);
    }
  };
  var Int32 = class extends Int {
    constructor() {
      super(true, 32);
    }
  };
  var Uint8 = class extends Int {
    constructor() {
      super(false, 8);
    }
  };
  var Uint16 = class extends Int {
    constructor() {
      super(false, 16);
    }
  };
  var Uint32 = class extends Int {
    constructor() {
      super(false, 32);
    }
  };
  var Precision = {
    HALF: 16,
    SINGLE: 32,
    DOUBLE: 64
  };
  var Float = class extends DataType {
    constructor(precision) {
      super();
      this.precision = precision;
    }
    get typeId() {
      return Type.Float;
    }
    get [Symbol.toStringTag]() {
      return "Float";
    }
    toString() {
      return `Float${this.precision}`;
    }
  };
  var Float32 = class extends Float {
    constructor() {
      super(Precision.SINGLE);
    }
  };
  var Float64 = class extends Float {
    constructor() {
      super(Precision.DOUBLE);
    }
  };
  var Binary = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Binary;
    }
    toString() {
      return "Binary";
    }
    get [Symbol.toStringTag]() {
      return "Binary";
    }
  };
  var Utf8 = class extends DataType {
    get typeId() {
      return Type.Utf8;
    }
    get [Symbol.toStringTag]() {
      return "Utf8";
    }
    toString() {
      return "Utf8";
    }
  };
  var DateUnit = {
    DAY: 0,
    MILLISECOND: 1
  };
  var Date = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Date;
    }
    get [Symbol.toStringTag]() {
      return "Date";
    }
    toString() {
      return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
    }
  };
  var TimeUnit = {
    SECOND: 1,
    MILLISECOND: 1e3,
    MICROSECOND: 1e6,
    NANOSECOND: 1e9
  };
  var Time = class extends DataType {
    constructor(unit, bitWidth) {
      super();
      this.unit = unit;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Time;
    }
    toString() {
      return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
    }
    get [Symbol.toStringTag]() {
      return "Time";
    }
  };
  var Timestamp = class extends DataType {
    constructor(unit, timezone = null) {
      super();
      this.unit = unit;
      this.timezone = timezone;
    }
    get typeId() {
      return Type.Timestamp;
    }
    get [Symbol.toStringTag]() {
      return "Timestamp";
    }
    toString() {
      return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
    }
  };
  var IntervalUnit = {
    DAY_TIME: 0,
    YEAR_MONTH: 1
  };
  var Interval = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Interval;
    }
    get [Symbol.toStringTag]() {
      return "Interval";
    }
    toString() {
      return `Interval<${IntervalUnit[this.unit]}>`;
    }
  };
  var FixedSizeList = class extends DataType {
    constructor(listSize, child) {
      super();
      this.listSize = listSize;
      this.children = [child];
    }
    get typeId() {
      return Type.FixedSizeList;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get [Symbol.toStringTag]() {
      return "FixedSizeList";
    }
    toString() {
      return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
    }
  };
  var Struct = class extends DataType {
    constructor(children) {
      super();
      this.children = children;
    }
    get typeId() {
      return Type.Struct;
    }
    toString() {
      return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(", ")}}>`;
    }
    get [Symbol.toStringTag]() {
      return "Struct";
    }
  };

  // ../schema/src/lib/arrow/arrow-like-type-utils.ts
  function getArrowTypeFromTypedArray(array) {
    switch (array.constructor) {
      case Int8Array:
        return new Int8();
      case Uint8Array:
        return new Uint8();
      case Int16Array:
        return new Int16();
      case Uint16Array:
        return new Uint16();
      case Int32Array:
        return new Int32();
      case Uint32Array:
        return new Uint32();
      case Float32Array:
        return new Float32();
      case Float64Array:
        return new Float64();
      default:
        throw new Error("array type not supported");
    }
  }

  // src/lib/parse-obj-meshes.ts
  var OBJECT_RE = /^[og]\s*(.+)?/;
  var MATERIAL_RE = /^mtllib /;
  var MATERIAL_USE_RE = /^usemtl /;
  var MeshMaterial = class {
    constructor({ index, name = "", mtllib, smooth, groupStart }) {
      this.index = index;
      this.name = name;
      this.mtllib = mtllib;
      this.smooth = smooth;
      this.groupStart = groupStart;
      this.groupEnd = -1;
      this.groupCount = -1;
      this.inherited = false;
    }
    clone(index = this.index) {
      return new MeshMaterial({
        index,
        name: this.name,
        mtllib: this.mtllib,
        smooth: this.smooth,
        groupStart: 0
      });
    }
  };
  var MeshObject = class {
    constructor(name = "") {
      this.name = name;
      this.geometry = {
        vertices: [],
        normals: [],
        colors: [],
        uvs: []
      };
      this.materials = [];
      this.smooth = true;
      this.fromDeclaration = null;
    }
    startMaterial(name, libraries) {
      const previous = this._finalize(false);
      if (previous && (previous.inherited || previous.groupCount <= 0)) {
        this.materials.splice(previous.index, 1);
      }
      const material = new MeshMaterial({
        index: this.materials.length,
        name,
        mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
        smooth: previous !== void 0 ? previous.smooth : this.smooth,
        groupStart: previous !== void 0 ? previous.groupEnd : 0
      });
      this.materials.push(material);
      return material;
    }
    currentMaterial() {
      if (this.materials.length > 0) {
        return this.materials[this.materials.length - 1];
      }
      return void 0;
    }
    _finalize(end) {
      const lastMultiMaterial = this.currentMaterial();
      if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
        lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
        lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
        lastMultiMaterial.inherited = false;
      }
      if (end && this.materials.length > 1) {
        for (let mi = this.materials.length - 1; mi >= 0; mi--) {
          if (this.materials[mi].groupCount <= 0) {
            this.materials.splice(mi, 1);
          }
        }
      }
      if (end && this.materials.length === 0) {
        this.materials.push({
          name: "",
          smooth: this.smooth
        });
      }
      return lastMultiMaterial;
    }
  };
  var ParserState = class {
    constructor() {
      this.objects = [];
      this.object = null;
      this.vertices = [];
      this.normals = [];
      this.colors = [];
      this.uvs = [];
      this.materialLibraries = [];
      this.startObject("", false);
    }
    startObject(name, fromDeclaration = true) {
      if (this.object && !this.object.fromDeclaration) {
        this.object.name = name;
        this.object.fromDeclaration = fromDeclaration;
        return;
      }
      const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
      this.object = new MeshObject(name);
      this.object.fromDeclaration = fromDeclaration;
      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
        const declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }
      this.objects.push(this.object);
    }
    finalize() {
      if (this.object && typeof this.object._finalize === "function") {
        this.object._finalize(true);
      }
    }
    parseVertexIndex(value, len) {
      const index = parseInt(value);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    }
    parseNormalIndex(value, len) {
      const index = parseInt(value);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    }
    parseUVIndex(value, len) {
      const index = parseInt(value);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    }
    addVertex(a, b, c) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    }
    addVertexPoint(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    }
    addVertexLine(a) {
      const src = this.vertices;
      const dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    }
    addNormal(a, b, c) {
      const src = this.normals;
      const dst = this.object.geometry.normals;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    }
    addColor(a, b, c) {
      const src = this.colors;
      const dst = this.object.geometry.colors;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    }
    addUV(a, b, c) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
      dst.push(src[b + 0], src[b + 1]);
      dst.push(src[c + 0], src[c + 1]);
    }
    addUVLine(a) {
      const src = this.uvs;
      const dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
    }
    addFace(a, b, c, ua, ub, uc, na, nb, nc) {
      const vLen = this.vertices.length;
      let ia = this.parseVertexIndex(a, vLen);
      let ib = this.parseVertexIndex(b, vLen);
      let ic = this.parseVertexIndex(c, vLen);
      this.addVertex(ia, ib, ic);
      if (ua !== void 0 && ua !== "") {
        const uvLen = this.uvs.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);
        this.addUV(ia, ib, ic);
      }
      if (na !== void 0 && na !== "") {
        const nLen = this.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
        ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
        this.addNormal(ia, ib, ic);
      }
      if (this.colors.length > 0) {
        this.addColor(ia, ib, ic);
      }
    }
    addPointGeometry(vertices) {
      this.object.geometry.type = "Points";
      const vLen = this.vertices.length;
      for (const vertex of vertices) {
        this.addVertexPoint(this.parseVertexIndex(vertex, vLen));
      }
    }
    addLineGeometry(vertices, uvs) {
      this.object.geometry.type = "Line";
      const vLen = this.vertices.length;
      const uvLen = this.uvs.length;
      for (const vertex of vertices) {
        this.addVertexLine(this.parseVertexIndex(vertex, vLen));
      }
      for (const uv of uvs) {
        this.addUVLine(this.parseUVIndex(uv, uvLen));
      }
    }
  };
  function parseOBJMeshes(text) {
    const state = new ParserState();
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    if (text.indexOf("\\\n") !== -1) {
      text = text.replace(/\\\n/g, "");
    }
    const lines = text.split("\n");
    let line = "";
    let lineFirstChar = "";
    let lineLength = 0;
    let result = [];
    const trimLeft = typeof "".trimLeft === "function";
    for (let i = 0, l = lines.length; i < l; i++) {
      line = lines[i];
      line = trimLeft ? line.trimLeft() : line.trim();
      lineLength = line.length;
      if (lineLength === 0)
        continue;
      lineFirstChar = line.charAt(0);
      if (lineFirstChar === "#")
        continue;
      if (lineFirstChar === "v") {
        const data = line.split(/\s+/);
        switch (data[0]) {
          case "v":
            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            if (data.length === 8) {
              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
            }
            break;
          case "vn":
            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            break;
          case "vt":
            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
            break;
          default:
        }
      } else if (lineFirstChar === "f") {
        const lineData = line.substr(1).trim();
        const vertexData = lineData.split(/\s+/);
        const faceVertices = [];
        for (let j = 0, jl = vertexData.length; j < jl; j++) {
          const vertex = vertexData[j];
          if (vertex.length > 0) {
            const vertexParts = vertex.split("/");
            faceVertices.push(vertexParts);
          }
        }
        const v1 = faceVertices[0];
        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
          const v2 = faceVertices[j];
          const v3 = faceVertices[j + 1];
          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
        }
      } else if (lineFirstChar === "l") {
        const lineParts = line.substring(1).trim().split(" ");
        let lineVertices;
        const lineUVs = [];
        if (line.indexOf("/") === -1) {
          lineVertices = lineParts;
        } else {
          lineVertices = [];
          for (let li = 0, llen = lineParts.length; li < llen; li++) {
            const parts = lineParts[li].split("/");
            if (parts[0] !== "")
              lineVertices.push(parts[0]);
            if (parts[1] !== "")
              lineUVs.push(parts[1]);
          }
        }
        state.addLineGeometry(lineVertices, lineUVs);
      } else if (lineFirstChar === "p") {
        const lineData = line.substr(1).trim();
        const pointData = lineData.split(" ");
        state.addPointGeometry(pointData);
      } else if ((result = OBJECT_RE.exec(line)) !== null) {
        const name = (" " + result[0].substr(1).trim()).substr(1);
        state.startObject(name);
      } else if (MATERIAL_USE_RE.test(line)) {
        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
      } else if (MATERIAL_RE.test(line)) {
        state.materialLibraries.push(line.substring(7).trim());
      } else if (lineFirstChar === "s") {
        result = line.split(" ");
        if (result.length > 1) {
          const value = result[1].trim().toLowerCase();
          state.object.smooth = value !== "0" && value !== "off";
        } else {
          state.object.smooth = true;
        }
        const material = state.object.currentMaterial();
        if (material)
          material.smooth = state.object.smooth;
      } else {
        if (line === "\0")
          continue;
        throw new Error(`Unexpected line: "${line}"`);
      }
    }
    state.finalize();
    const meshes = [];
    const materials = [];
    for (const object of state.objects) {
      const { geometry } = object;
      if (geometry.vertices.length === 0)
        continue;
      const mesh = {
        header: {
          vertexCount: geometry.vertices.length / 3
        },
        attributes: {}
      };
      switch (geometry.type) {
        case "Points":
          mesh.mode = 0;
          break;
        case "Line":
          mesh.mode = 1;
          break;
        default:
          mesh.mode = 4;
          break;
      }
      mesh.attributes.POSITION = { value: new Float32Array(geometry.vertices), size: 3 };
      if (geometry.normals.length > 0) {
        mesh.attributes.NORMAL = { value: new Float32Array(geometry.normals), size: 3 };
      }
      if (geometry.colors.length > 0) {
        mesh.attributes.COLOR_0 = { value: new Float32Array(geometry.colors), size: 3 };
      }
      if (geometry.uvs.length > 0) {
        mesh.attributes.TEXCOORD_0 = { value: new Float32Array(geometry.uvs), size: 2 };
      }
      mesh.materials = [];
      for (const sourceMaterial of object.materials) {
        const _material = {
          name: sourceMaterial.name,
          flatShading: !sourceMaterial.smooth
        };
        mesh.materials.push(_material);
        materials.push(_material);
      }
      mesh.name = object.name;
      meshes.push(mesh);
    }
    return { meshes, materials };
  }

  // src/lib/get-obj-schema.ts
  function getOBJSchema(attributes, metadata = {}) {
    let metadataMap;
    for (const key in metadata) {
      metadataMap = metadataMap || new Map();
      if (key !== "value") {
        metadataMap.set(key, JSON.stringify(metadata[key]));
      }
    }
    const fields = [];
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const field = getArrowFieldFromAttribute(attributeName, attribute);
      fields.push(field);
    }
    return new Schema(fields, metadataMap);
  }
  function getArrowFieldFromAttribute(attributeName, attribute) {
    const metadataMap = new Map();
    for (const key in attribute) {
      if (key !== "value") {
        metadataMap.set(key, JSON.stringify(attribute[key]));
      }
    }
    const type = getArrowTypeFromTypedArray(attribute.value);
    const isSingleValue = !("size" in attribute) || attribute.size === 1;
    return isSingleValue ? new Field(attributeName, type, false, metadataMap) : new Field(attributeName, new FixedSizeList(attribute.size, new Field("value", type)), false, metadataMap);
  }

  // src/lib/parse-obj.ts
  function parseOBJ(text, options) {
    const { meshes } = parseOBJMeshes(text);
    const vertexCount = meshes.reduce((s, mesh) => s + mesh.header.vertexCount, 0);
    const attributes = mergeAttributes(meshes, vertexCount);
    const header = {
      vertexCount,
      boundingBox: getMeshBoundingBox(attributes)
    };
    const schema = getOBJSchema(attributes, {
      mode: 4,
      boundingBox: header.boundingBox
    });
    return {
      loaderData: {
        header: {}
      },
      schema,
      header,
      mode: 4,
      attributes
    };
  }
  function mergeAttributes(meshes, vertexCount) {
    const positions = new Float32Array(vertexCount * 3);
    let normals;
    let colors;
    let uvs;
    let i = 0;
    for (const mesh of meshes) {
      const { POSITION, NORMAL, COLOR_0, TEXCOORD_0 } = mesh.attributes;
      positions.set(POSITION.value, i * 3);
      if (NORMAL) {
        normals = normals || new Float32Array(vertexCount * 3);
        normals.set(NORMAL.value, i * 3);
      }
      if (COLOR_0) {
        colors = colors || new Float32Array(vertexCount * 3);
        colors.set(COLOR_0.value, i * 3);
      }
      if (TEXCOORD_0) {
        uvs = uvs || new Float32Array(vertexCount * 2);
        uvs.set(TEXCOORD_0.value, i * 2);
      }
      i += POSITION.value.length / 3;
    }
    const attributes = {};
    attributes.POSITION = { value: positions, size: 3 };
    if (normals) {
      attributes.NORMAL = { value: normals, size: 3 };
    }
    if (colors) {
      attributes.COLOR_0 = { value: colors, size: 3 };
    }
    if (uvs) {
      attributes.TEXCOORD_0 = { value: uvs, size: 2 };
    }
    return attributes;
  }

  // src/lib/parse-mtl.ts
  var DELIMITER_PATTERN = /\s+/;
  function parseMTL(text, options) {
    const materials = [];
    let currentMaterial = { name: "placeholder" };
    const lines = text.split("\n");
    for (let line of lines) {
      line = line.trim();
      if (line.length === 0 || line.charAt(0) === "#") {
        continue;
      }
      const pos = line.indexOf(" ");
      let key = pos >= 0 ? line.substring(0, pos) : line;
      key = key.toLowerCase();
      let value = pos >= 0 ? line.substring(pos + 1) : "";
      value = value.trim();
      switch (key) {
        case "newmtl":
          currentMaterial = { name: value };
          materials.push(currentMaterial);
          break;
        case "ka":
          currentMaterial.ambientColor = parseColor(value);
          break;
        case "kd":
          currentMaterial.diffuseColor = parseColor(value);
          break;
        case "map_kd":
          currentMaterial.diffuseTextureUrl = value;
          break;
        case "ks":
          currentMaterial.specularColor = parseColor(value);
          break;
        case "map_ks":
          currentMaterial.specularTextureUrl = value;
          break;
        case "ke":
          currentMaterial.emissiveColor = parseColor(value);
          break;
        case "map_ke":
          currentMaterial.emissiveTextureUrl = value;
          break;
        case "ns":
          currentMaterial.shininess = parseFloat(value);
          break;
        case "map_ns":
          break;
        case "ni":
          currentMaterial.refraction = parseFloat(value);
          break;
        case "illum":
          currentMaterial.illumination = parseFloat(value);
          break;
        default:
          break;
      }
    }
    return materials;
  }
  function parseColor(value, options) {
    const rgb = value.split(DELIMITER_PATTERN, 3);
    const color = [
      parseFloat(rgb[0]),
      parseFloat(rgb[1]),
      parseFloat(rgb[2])
    ];
    return color;
  }

  // src/obj-loader.ts
  var VERSION = true ? "3.4.4" : "latest";
  var OBJLoader = {
    name: "OBJ",
    id: "obj",
    module: "obj",
    version: VERSION,
    worker: true,
    extensions: ["obj"],
    mimeTypes: ["text/plain"],
    testText: testOBJFile,
    options: {
      obj: {}
    }
  };
  function testOBJFile(text) {
    return text[0] === "v";
  }

  // src/mtl-loader.ts
  var VERSION2 = true ? "3.4.4" : "latest";
  var MTLLoader = {
    name: "MTL",
    id: "mtl",
    module: "mtl",
    version: VERSION2,
    worker: true,
    extensions: ["mtl"],
    mimeTypes: ["text/plain"],
    testText: (text) => text.includes("newmtl"),
    options: {
      mtl: {}
    }
  };

  // src/index.ts
  var OBJLoader2 = {
    ...OBJLoader,
    parse: async (arrayBuffer, options) => parseOBJ(new TextDecoder().decode(arrayBuffer), options),
    parseTextSync: (text, options) => parseOBJ(text, options)
  };
  var MTLLoader2 = {
    ...MTLLoader,
    parse: async (arrayBuffer, options) => parseMTL(new TextDecoder().decode(arrayBuffer), options?.mtl),
    parseTextSync: (text, options) => parseMTL(text, options?.mtl)
  };

  // src/workers/obj-worker.ts
  createLoaderWorker(OBJLoader2);
})();
