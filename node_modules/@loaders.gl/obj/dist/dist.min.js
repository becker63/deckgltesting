(() => {
  var __defProp = Object.defineProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // ../schema/src/category/mesh/mesh-utils.ts
  function getMeshBoundingBox(attributes) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    const positions = attributes.POSITION ? attributes.POSITION.value : [];
    const len = positions && positions.length;
    for (let i = 0; i < len; i += 3) {
      const x = positions[i];
      const y = positions[i + 1];
      const z = positions[i + 2];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      minZ = z < minZ ? z : minZ;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      maxZ = z > maxZ ? z : maxZ;
    }
    return [
      [minX, minY, minZ],
      [maxX, maxY, maxZ]
    ];
  }
  var init_mesh_utils = __esm({
    "../schema/src/category/mesh/mesh-utils.ts"() {
    }
  });

  // ../schema/src/lib/utils/assert.ts
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }
  var init_assert = __esm({
    "../schema/src/lib/utils/assert.ts"() {
    }
  });

  // ../schema/src/lib/schema/impl/schema.ts
  function checkNames(fields) {
    const usedNames = {};
    for (const field of fields) {
      if (usedNames[field.name]) {
        console.warn("Schema: duplicated field name", field.name, field);
      }
      usedNames[field.name] = true;
    }
  }
  function mergeMaps(m1, m2) {
    return new Map([...m1 || new Map(), ...m2 || new Map()]);
  }
  var Schema;
  var init_schema = __esm({
    "../schema/src/lib/schema/impl/schema.ts"() {
      init_assert();
      Schema = class {
        constructor(fields, metadata) {
          assert(Array.isArray(fields));
          checkNames(fields);
          this.fields = fields;
          this.metadata = metadata || new Map();
        }
        compareTo(other) {
          if (this.metadata !== other.metadata) {
            return false;
          }
          if (this.fields.length !== other.fields.length) {
            return false;
          }
          for (let i = 0; i < this.fields.length; ++i) {
            if (!this.fields[i].compareTo(other.fields[i])) {
              return false;
            }
          }
          return true;
        }
        select(...columnNames) {
          const nameMap = Object.create(null);
          for (const name of columnNames) {
            nameMap[name] = true;
          }
          const selectedFields = this.fields.filter((field) => nameMap[field.name]);
          return new Schema(selectedFields, this.metadata);
        }
        selectAt(...columnIndices) {
          const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);
          return new Schema(selectedFields, this.metadata);
        }
        assign(schemaOrFields) {
          let fields;
          let metadata = this.metadata;
          if (schemaOrFields instanceof Schema) {
            const otherSchema = schemaOrFields;
            fields = otherSchema.fields;
            metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);
          } else {
            fields = schemaOrFields;
          }
          const fieldMap = Object.create(null);
          for (const field of this.fields) {
            fieldMap[field.name] = field;
          }
          for (const field of fields) {
            fieldMap[field.name] = field;
          }
          const mergedFields = Object.values(fieldMap);
          return new Schema(mergedFields, metadata);
        }
      };
    }
  });

  // ../schema/src/lib/schema/impl/field.ts
  var Field;
  var init_field = __esm({
    "../schema/src/lib/schema/impl/field.ts"() {
      Field = class {
        constructor(name, type, nullable = false, metadata = new Map()) {
          this.name = name;
          this.type = type;
          this.nullable = nullable;
          this.metadata = metadata;
        }
        get typeId() {
          return this.type && this.type.typeId;
        }
        clone() {
          return new Field(this.name, this.type, this.nullable, this.metadata);
        }
        compareTo(other) {
          return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
        }
        toString() {
          return `${this.type}${this.nullable ? ", nullable" : ""}${this.metadata ? `, metadata: ${this.metadata}` : ""}`;
        }
      };
    }
  });

  // ../schema/src/lib/schema/impl/enum.ts
  var Type;
  var init_enum = __esm({
    "../schema/src/lib/schema/impl/enum.ts"() {
      (function(Type2) {
        Type2[Type2["NONE"] = 0] = "NONE";
        Type2[Type2["Null"] = 1] = "Null";
        Type2[Type2["Int"] = 2] = "Int";
        Type2[Type2["Float"] = 3] = "Float";
        Type2[Type2["Binary"] = 4] = "Binary";
        Type2[Type2["Utf8"] = 5] = "Utf8";
        Type2[Type2["Bool"] = 6] = "Bool";
        Type2[Type2["Decimal"] = 7] = "Decimal";
        Type2[Type2["Date"] = 8] = "Date";
        Type2[Type2["Time"] = 9] = "Time";
        Type2[Type2["Timestamp"] = 10] = "Timestamp";
        Type2[Type2["Interval"] = 11] = "Interval";
        Type2[Type2["List"] = 12] = "List";
        Type2[Type2["Struct"] = 13] = "Struct";
        Type2[Type2["Union"] = 14] = "Union";
        Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
        Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
        Type2[Type2["Map"] = 17] = "Map";
        Type2[Type2["Dictionary"] = -1] = "Dictionary";
        Type2[Type2["Int8"] = -2] = "Int8";
        Type2[Type2["Int16"] = -3] = "Int16";
        Type2[Type2["Int32"] = -4] = "Int32";
        Type2[Type2["Int64"] = -5] = "Int64";
        Type2[Type2["Uint8"] = -6] = "Uint8";
        Type2[Type2["Uint16"] = -7] = "Uint16";
        Type2[Type2["Uint32"] = -8] = "Uint32";
        Type2[Type2["Uint64"] = -9] = "Uint64";
        Type2[Type2["Float16"] = -10] = "Float16";
        Type2[Type2["Float32"] = -11] = "Float32";
        Type2[Type2["Float64"] = -12] = "Float64";
        Type2[Type2["DateDay"] = -13] = "DateDay";
        Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
        Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
        Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
        Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
        Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
        Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
        Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
        Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
        Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
        Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
        Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
        Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
        Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
      })(Type || (Type = {}));
    }
  });

  // ../schema/src/lib/schema/impl/type.ts
  var DataType, Null, Bool, Int, Int8, Int16, Int32, Uint8, Uint16, Uint32, Precision, Float, Float32, Float64, Binary, Utf8, DateUnit, Date, TimeUnit, Time, Timestamp, IntervalUnit, Interval, FixedSizeList, Struct;
  var init_type = __esm({
    "../schema/src/lib/schema/impl/type.ts"() {
      init_enum();
      DataType = class {
        static isNull(x) {
          return x && x.typeId === Type.Null;
        }
        static isInt(x) {
          return x && x.typeId === Type.Int;
        }
        static isFloat(x) {
          return x && x.typeId === Type.Float;
        }
        static isBinary(x) {
          return x && x.typeId === Type.Binary;
        }
        static isUtf8(x) {
          return x && x.typeId === Type.Utf8;
        }
        static isBool(x) {
          return x && x.typeId === Type.Bool;
        }
        static isDecimal(x) {
          return x && x.typeId === Type.Decimal;
        }
        static isDate(x) {
          return x && x.typeId === Type.Date;
        }
        static isTime(x) {
          return x && x.typeId === Type.Time;
        }
        static isTimestamp(x) {
          return x && x.typeId === Type.Timestamp;
        }
        static isInterval(x) {
          return x && x.typeId === Type.Interval;
        }
        static isList(x) {
          return x && x.typeId === Type.List;
        }
        static isStruct(x) {
          return x && x.typeId === Type.Struct;
        }
        static isUnion(x) {
          return x && x.typeId === Type.Union;
        }
        static isFixedSizeBinary(x) {
          return x && x.typeId === Type.FixedSizeBinary;
        }
        static isFixedSizeList(x) {
          return x && x.typeId === Type.FixedSizeList;
        }
        static isMap(x) {
          return x && x.typeId === Type.Map;
        }
        static isDictionary(x) {
          return x && x.typeId === Type.Dictionary;
        }
        get typeId() {
          return Type.NONE;
        }
        compareTo(other) {
          return this === other;
        }
      };
      Null = class extends DataType {
        get typeId() {
          return Type.Null;
        }
        get [Symbol.toStringTag]() {
          return "Null";
        }
        toString() {
          return "Null";
        }
      };
      Bool = class extends DataType {
        get typeId() {
          return Type.Bool;
        }
        get [Symbol.toStringTag]() {
          return "Bool";
        }
        toString() {
          return "Bool";
        }
      };
      Int = class extends DataType {
        constructor(isSigned, bitWidth) {
          super();
          this.isSigned = isSigned;
          this.bitWidth = bitWidth;
        }
        get typeId() {
          return Type.Int;
        }
        get [Symbol.toStringTag]() {
          return "Int";
        }
        toString() {
          return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`;
        }
      };
      Int8 = class extends Int {
        constructor() {
          super(true, 8);
        }
      };
      Int16 = class extends Int {
        constructor() {
          super(true, 16);
        }
      };
      Int32 = class extends Int {
        constructor() {
          super(true, 32);
        }
      };
      Uint8 = class extends Int {
        constructor() {
          super(false, 8);
        }
      };
      Uint16 = class extends Int {
        constructor() {
          super(false, 16);
        }
      };
      Uint32 = class extends Int {
        constructor() {
          super(false, 32);
        }
      };
      Precision = {
        HALF: 16,
        SINGLE: 32,
        DOUBLE: 64
      };
      Float = class extends DataType {
        constructor(precision) {
          super();
          this.precision = precision;
        }
        get typeId() {
          return Type.Float;
        }
        get [Symbol.toStringTag]() {
          return "Float";
        }
        toString() {
          return `Float${this.precision}`;
        }
      };
      Float32 = class extends Float {
        constructor() {
          super(Precision.SINGLE);
        }
      };
      Float64 = class extends Float {
        constructor() {
          super(Precision.DOUBLE);
        }
      };
      Binary = class extends DataType {
        constructor() {
          super();
        }
        get typeId() {
          return Type.Binary;
        }
        toString() {
          return "Binary";
        }
        get [Symbol.toStringTag]() {
          return "Binary";
        }
      };
      Utf8 = class extends DataType {
        get typeId() {
          return Type.Utf8;
        }
        get [Symbol.toStringTag]() {
          return "Utf8";
        }
        toString() {
          return "Utf8";
        }
      };
      DateUnit = {
        DAY: 0,
        MILLISECOND: 1
      };
      Date = class extends DataType {
        constructor(unit) {
          super();
          this.unit = unit;
        }
        get typeId() {
          return Type.Date;
        }
        get [Symbol.toStringTag]() {
          return "Date";
        }
        toString() {
          return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
        }
      };
      TimeUnit = {
        SECOND: 1,
        MILLISECOND: 1e3,
        MICROSECOND: 1e6,
        NANOSECOND: 1e9
      };
      Time = class extends DataType {
        constructor(unit, bitWidth) {
          super();
          this.unit = unit;
          this.bitWidth = bitWidth;
        }
        get typeId() {
          return Type.Time;
        }
        toString() {
          return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
        }
        get [Symbol.toStringTag]() {
          return "Time";
        }
      };
      Timestamp = class extends DataType {
        constructor(unit, timezone = null) {
          super();
          this.unit = unit;
          this.timezone = timezone;
        }
        get typeId() {
          return Type.Timestamp;
        }
        get [Symbol.toStringTag]() {
          return "Timestamp";
        }
        toString() {
          return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
        }
      };
      IntervalUnit = {
        DAY_TIME: 0,
        YEAR_MONTH: 1
      };
      Interval = class extends DataType {
        constructor(unit) {
          super();
          this.unit = unit;
        }
        get typeId() {
          return Type.Interval;
        }
        get [Symbol.toStringTag]() {
          return "Interval";
        }
        toString() {
          return `Interval<${IntervalUnit[this.unit]}>`;
        }
      };
      FixedSizeList = class extends DataType {
        constructor(listSize, child) {
          super();
          this.listSize = listSize;
          this.children = [child];
        }
        get typeId() {
          return Type.FixedSizeList;
        }
        get valueType() {
          return this.children[0].type;
        }
        get valueField() {
          return this.children[0];
        }
        get [Symbol.toStringTag]() {
          return "FixedSizeList";
        }
        toString() {
          return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
        }
      };
      Struct = class extends DataType {
        constructor(children) {
          super();
          this.children = children;
        }
        get typeId() {
          return Type.Struct;
        }
        toString() {
          return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(", ")}}>`;
        }
        get [Symbol.toStringTag]() {
          return "Struct";
        }
      };
    }
  });

  // ../schema/src/lib/schema/schema.ts
  var init_schema2 = __esm({
    "../schema/src/lib/schema/schema.ts"() {
      init_schema();
      init_field();
      init_type();
    }
  });

  // ../schema/src/lib/arrow/arrow-like-type-utils.ts
  function getArrowTypeFromTypedArray(array) {
    switch (array.constructor) {
      case Int8Array:
        return new Int8();
      case Uint8Array:
        return new Uint8();
      case Int16Array:
        return new Int16();
      case Uint16Array:
        return new Uint16();
      case Int32Array:
        return new Int32();
      case Uint32Array:
        return new Uint32();
      case Float32Array:
        return new Float32();
      case Float64Array:
        return new Float64();
      default:
        throw new Error("array type not supported");
    }
  }
  var init_arrow_like_type_utils = __esm({
    "../schema/src/lib/arrow/arrow-like-type-utils.ts"() {
      init_schema2();
    }
  });

  // ../schema/src/index.ts
  var init_src = __esm({
    "../schema/src/index.ts"() {
      init_mesh_utils();
      init_schema2();
      init_arrow_like_type_utils();
    }
  });

  // src/lib/parse-obj-meshes.ts
  function parseOBJMeshes(text) {
    const state = new ParserState();
    if (text.indexOf("\r\n") !== -1) {
      text = text.replace(/\r\n/g, "\n");
    }
    if (text.indexOf("\\\n") !== -1) {
      text = text.replace(/\\\n/g, "");
    }
    const lines = text.split("\n");
    let line = "";
    let lineFirstChar = "";
    let lineLength = 0;
    let result = [];
    const trimLeft = typeof "".trimLeft === "function";
    for (let i = 0, l = lines.length; i < l; i++) {
      line = lines[i];
      line = trimLeft ? line.trimLeft() : line.trim();
      lineLength = line.length;
      if (lineLength === 0)
        continue;
      lineFirstChar = line.charAt(0);
      if (lineFirstChar === "#")
        continue;
      if (lineFirstChar === "v") {
        const data = line.split(/\s+/);
        switch (data[0]) {
          case "v":
            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            if (data.length === 8) {
              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
            }
            break;
          case "vn":
            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
            break;
          case "vt":
            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
            break;
          default:
        }
      } else if (lineFirstChar === "f") {
        const lineData = line.substr(1).trim();
        const vertexData = lineData.split(/\s+/);
        const faceVertices = [];
        for (let j = 0, jl = vertexData.length; j < jl; j++) {
          const vertex = vertexData[j];
          if (vertex.length > 0) {
            const vertexParts = vertex.split("/");
            faceVertices.push(vertexParts);
          }
        }
        const v1 = faceVertices[0];
        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
          const v2 = faceVertices[j];
          const v3 = faceVertices[j + 1];
          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
        }
      } else if (lineFirstChar === "l") {
        const lineParts = line.substring(1).trim().split(" ");
        let lineVertices;
        const lineUVs = [];
        if (line.indexOf("/") === -1) {
          lineVertices = lineParts;
        } else {
          lineVertices = [];
          for (let li = 0, llen = lineParts.length; li < llen; li++) {
            const parts = lineParts[li].split("/");
            if (parts[0] !== "")
              lineVertices.push(parts[0]);
            if (parts[1] !== "")
              lineUVs.push(parts[1]);
          }
        }
        state.addLineGeometry(lineVertices, lineUVs);
      } else if (lineFirstChar === "p") {
        const lineData = line.substr(1).trim();
        const pointData = lineData.split(" ");
        state.addPointGeometry(pointData);
      } else if ((result = OBJECT_RE.exec(line)) !== null) {
        const name = (" " + result[0].substr(1).trim()).substr(1);
        state.startObject(name);
      } else if (MATERIAL_USE_RE.test(line)) {
        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
      } else if (MATERIAL_RE.test(line)) {
        state.materialLibraries.push(line.substring(7).trim());
      } else if (lineFirstChar === "s") {
        result = line.split(" ");
        if (result.length > 1) {
          const value = result[1].trim().toLowerCase();
          state.object.smooth = value !== "0" && value !== "off";
        } else {
          state.object.smooth = true;
        }
        const material = state.object.currentMaterial();
        if (material)
          material.smooth = state.object.smooth;
      } else {
        if (line === "\0")
          continue;
        throw new Error(`Unexpected line: "${line}"`);
      }
    }
    state.finalize();
    const meshes = [];
    const materials = [];
    for (const object of state.objects) {
      const { geometry } = object;
      if (geometry.vertices.length === 0)
        continue;
      const mesh = {
        header: {
          vertexCount: geometry.vertices.length / 3
        },
        attributes: {}
      };
      switch (geometry.type) {
        case "Points":
          mesh.mode = 0;
          break;
        case "Line":
          mesh.mode = 1;
          break;
        default:
          mesh.mode = 4;
          break;
      }
      mesh.attributes.POSITION = { value: new Float32Array(geometry.vertices), size: 3 };
      if (geometry.normals.length > 0) {
        mesh.attributes.NORMAL = { value: new Float32Array(geometry.normals), size: 3 };
      }
      if (geometry.colors.length > 0) {
        mesh.attributes.COLOR_0 = { value: new Float32Array(geometry.colors), size: 3 };
      }
      if (geometry.uvs.length > 0) {
        mesh.attributes.TEXCOORD_0 = { value: new Float32Array(geometry.uvs), size: 2 };
      }
      mesh.materials = [];
      for (const sourceMaterial of object.materials) {
        const _material = {
          name: sourceMaterial.name,
          flatShading: !sourceMaterial.smooth
        };
        mesh.materials.push(_material);
        materials.push(_material);
      }
      mesh.name = object.name;
      meshes.push(mesh);
    }
    return { meshes, materials };
  }
  var OBJECT_RE, MATERIAL_RE, MATERIAL_USE_RE, MeshMaterial, MeshObject, ParserState;
  var init_parse_obj_meshes = __esm({
    "src/lib/parse-obj-meshes.ts"() {
      OBJECT_RE = /^[og]\s*(.+)?/;
      MATERIAL_RE = /^mtllib /;
      MATERIAL_USE_RE = /^usemtl /;
      MeshMaterial = class {
        constructor({ index, name = "", mtllib, smooth, groupStart }) {
          this.index = index;
          this.name = name;
          this.mtllib = mtllib;
          this.smooth = smooth;
          this.groupStart = groupStart;
          this.groupEnd = -1;
          this.groupCount = -1;
          this.inherited = false;
        }
        clone(index = this.index) {
          return new MeshMaterial({
            index,
            name: this.name,
            mtllib: this.mtllib,
            smooth: this.smooth,
            groupStart: 0
          });
        }
      };
      MeshObject = class {
        constructor(name = "") {
          this.name = name;
          this.geometry = {
            vertices: [],
            normals: [],
            colors: [],
            uvs: []
          };
          this.materials = [];
          this.smooth = true;
          this.fromDeclaration = null;
        }
        startMaterial(name, libraries) {
          const previous = this._finalize(false);
          if (previous && (previous.inherited || previous.groupCount <= 0)) {
            this.materials.splice(previous.index, 1);
          }
          const material = new MeshMaterial({
            index: this.materials.length,
            name,
            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
            smooth: previous !== void 0 ? previous.smooth : this.smooth,
            groupStart: previous !== void 0 ? previous.groupEnd : 0
          });
          this.materials.push(material);
          return material;
        }
        currentMaterial() {
          if (this.materials.length > 0) {
            return this.materials[this.materials.length - 1];
          }
          return void 0;
        }
        _finalize(end) {
          const lastMultiMaterial = this.currentMaterial();
          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
            lastMultiMaterial.inherited = false;
          }
          if (end && this.materials.length > 1) {
            for (let mi = this.materials.length - 1; mi >= 0; mi--) {
              if (this.materials[mi].groupCount <= 0) {
                this.materials.splice(mi, 1);
              }
            }
          }
          if (end && this.materials.length === 0) {
            this.materials.push({
              name: "",
              smooth: this.smooth
            });
          }
          return lastMultiMaterial;
        }
      };
      ParserState = class {
        constructor() {
          this.objects = [];
          this.object = null;
          this.vertices = [];
          this.normals = [];
          this.colors = [];
          this.uvs = [];
          this.materialLibraries = [];
          this.startObject("", false);
        }
        startObject(name, fromDeclaration = true) {
          if (this.object && !this.object.fromDeclaration) {
            this.object.name = name;
            this.object.fromDeclaration = fromDeclaration;
            return;
          }
          const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
          if (this.object && typeof this.object._finalize === "function") {
            this.object._finalize(true);
          }
          this.object = new MeshObject(name);
          this.object.fromDeclaration = fromDeclaration;
          if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
            const declared = previousMaterial.clone(0);
            declared.inherited = true;
            this.object.materials.push(declared);
          }
          this.objects.push(this.object);
        }
        finalize() {
          if (this.object && typeof this.object._finalize === "function") {
            this.object._finalize(true);
          }
        }
        parseVertexIndex(value, len) {
          const index = parseInt(value);
          return (index >= 0 ? index - 1 : index + len / 3) * 3;
        }
        parseNormalIndex(value, len) {
          const index = parseInt(value);
          return (index >= 0 ? index - 1 : index + len / 3) * 3;
        }
        parseUVIndex(value, len) {
          const index = parseInt(value);
          return (index >= 0 ? index - 1 : index + len / 2) * 2;
        }
        addVertex(a, b, c) {
          const src = this.vertices;
          const dst = this.object.geometry.vertices;
          dst.push(src[a + 0], src[a + 1], src[a + 2]);
          dst.push(src[b + 0], src[b + 1], src[b + 2]);
          dst.push(src[c + 0], src[c + 1], src[c + 2]);
        }
        addVertexPoint(a) {
          const src = this.vertices;
          const dst = this.object.geometry.vertices;
          dst.push(src[a + 0], src[a + 1], src[a + 2]);
        }
        addVertexLine(a) {
          const src = this.vertices;
          const dst = this.object.geometry.vertices;
          dst.push(src[a + 0], src[a + 1], src[a + 2]);
        }
        addNormal(a, b, c) {
          const src = this.normals;
          const dst = this.object.geometry.normals;
          dst.push(src[a + 0], src[a + 1], src[a + 2]);
          dst.push(src[b + 0], src[b + 1], src[b + 2]);
          dst.push(src[c + 0], src[c + 1], src[c + 2]);
        }
        addColor(a, b, c) {
          const src = this.colors;
          const dst = this.object.geometry.colors;
          dst.push(src[a + 0], src[a + 1], src[a + 2]);
          dst.push(src[b + 0], src[b + 1], src[b + 2]);
          dst.push(src[c + 0], src[c + 1], src[c + 2]);
        }
        addUV(a, b, c) {
          const src = this.uvs;
          const dst = this.object.geometry.uvs;
          dst.push(src[a + 0], src[a + 1]);
          dst.push(src[b + 0], src[b + 1]);
          dst.push(src[c + 0], src[c + 1]);
        }
        addUVLine(a) {
          const src = this.uvs;
          const dst = this.object.geometry.uvs;
          dst.push(src[a + 0], src[a + 1]);
        }
        addFace(a, b, c, ua, ub, uc, na, nb, nc) {
          const vLen = this.vertices.length;
          let ia = this.parseVertexIndex(a, vLen);
          let ib = this.parseVertexIndex(b, vLen);
          let ic = this.parseVertexIndex(c, vLen);
          this.addVertex(ia, ib, ic);
          if (ua !== void 0 && ua !== "") {
            const uvLen = this.uvs.length;
            ia = this.parseUVIndex(ua, uvLen);
            ib = this.parseUVIndex(ub, uvLen);
            ic = this.parseUVIndex(uc, uvLen);
            this.addUV(ia, ib, ic);
          }
          if (na !== void 0 && na !== "") {
            const nLen = this.normals.length;
            ia = this.parseNormalIndex(na, nLen);
            ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
            ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
            this.addNormal(ia, ib, ic);
          }
          if (this.colors.length > 0) {
            this.addColor(ia, ib, ic);
          }
        }
        addPointGeometry(vertices) {
          this.object.geometry.type = "Points";
          const vLen = this.vertices.length;
          for (const vertex of vertices) {
            this.addVertexPoint(this.parseVertexIndex(vertex, vLen));
          }
        }
        addLineGeometry(vertices, uvs) {
          this.object.geometry.type = "Line";
          const vLen = this.vertices.length;
          const uvLen = this.uvs.length;
          for (const vertex of vertices) {
            this.addVertexLine(this.parseVertexIndex(vertex, vLen));
          }
          for (const uv of uvs) {
            this.addUVLine(this.parseUVIndex(uv, uvLen));
          }
        }
      };
    }
  });

  // src/lib/get-obj-schema.ts
  function getOBJSchema(attributes, metadata = {}) {
    let metadataMap;
    for (const key in metadata) {
      metadataMap = metadataMap || new Map();
      if (key !== "value") {
        metadataMap.set(key, JSON.stringify(metadata[key]));
      }
    }
    const fields = [];
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const field = getArrowFieldFromAttribute(attributeName, attribute);
      fields.push(field);
    }
    return new Schema(fields, metadataMap);
  }
  function getArrowFieldFromAttribute(attributeName, attribute) {
    const metadataMap = new Map();
    for (const key in attribute) {
      if (key !== "value") {
        metadataMap.set(key, JSON.stringify(attribute[key]));
      }
    }
    const type = getArrowTypeFromTypedArray(attribute.value);
    const isSingleValue = !("size" in attribute) || attribute.size === 1;
    return isSingleValue ? new Field(attributeName, type, false, metadataMap) : new Field(attributeName, new FixedSizeList(attribute.size, new Field("value", type)), false, metadataMap);
  }
  var init_get_obj_schema = __esm({
    "src/lib/get-obj-schema.ts"() {
      init_src();
    }
  });

  // src/lib/parse-obj.ts
  function parseOBJ(text, options) {
    const { meshes } = parseOBJMeshes(text);
    const vertexCount = meshes.reduce((s, mesh) => s + mesh.header.vertexCount, 0);
    const attributes = mergeAttributes(meshes, vertexCount);
    const header = {
      vertexCount,
      boundingBox: getMeshBoundingBox(attributes)
    };
    const schema = getOBJSchema(attributes, {
      mode: 4,
      boundingBox: header.boundingBox
    });
    return {
      loaderData: {
        header: {}
      },
      schema,
      header,
      mode: 4,
      attributes
    };
  }
  function mergeAttributes(meshes, vertexCount) {
    const positions = new Float32Array(vertexCount * 3);
    let normals;
    let colors;
    let uvs;
    let i = 0;
    for (const mesh of meshes) {
      const { POSITION, NORMAL, COLOR_0, TEXCOORD_0 } = mesh.attributes;
      positions.set(POSITION.value, i * 3);
      if (NORMAL) {
        normals = normals || new Float32Array(vertexCount * 3);
        normals.set(NORMAL.value, i * 3);
      }
      if (COLOR_0) {
        colors = colors || new Float32Array(vertexCount * 3);
        colors.set(COLOR_0.value, i * 3);
      }
      if (TEXCOORD_0) {
        uvs = uvs || new Float32Array(vertexCount * 2);
        uvs.set(TEXCOORD_0.value, i * 2);
      }
      i += POSITION.value.length / 3;
    }
    const attributes = {};
    attributes.POSITION = { value: positions, size: 3 };
    if (normals) {
      attributes.NORMAL = { value: normals, size: 3 };
    }
    if (colors) {
      attributes.COLOR_0 = { value: colors, size: 3 };
    }
    if (uvs) {
      attributes.TEXCOORD_0 = { value: uvs, size: 2 };
    }
    return attributes;
  }
  var init_parse_obj = __esm({
    "src/lib/parse-obj.ts"() {
      init_src();
      init_parse_obj_meshes();
      init_get_obj_schema();
    }
  });

  // src/lib/parse-mtl.ts
  function parseMTL(text, options) {
    const materials = [];
    let currentMaterial = { name: "placeholder" };
    const lines = text.split("\n");
    for (let line of lines) {
      line = line.trim();
      if (line.length === 0 || line.charAt(0) === "#") {
        continue;
      }
      const pos = line.indexOf(" ");
      let key = pos >= 0 ? line.substring(0, pos) : line;
      key = key.toLowerCase();
      let value = pos >= 0 ? line.substring(pos + 1) : "";
      value = value.trim();
      switch (key) {
        case "newmtl":
          currentMaterial = { name: value };
          materials.push(currentMaterial);
          break;
        case "ka":
          currentMaterial.ambientColor = parseColor(value);
          break;
        case "kd":
          currentMaterial.diffuseColor = parseColor(value);
          break;
        case "map_kd":
          currentMaterial.diffuseTextureUrl = value;
          break;
        case "ks":
          currentMaterial.specularColor = parseColor(value);
          break;
        case "map_ks":
          currentMaterial.specularTextureUrl = value;
          break;
        case "ke":
          currentMaterial.emissiveColor = parseColor(value);
          break;
        case "map_ke":
          currentMaterial.emissiveTextureUrl = value;
          break;
        case "ns":
          currentMaterial.shininess = parseFloat(value);
          break;
        case "map_ns":
          break;
        case "ni":
          currentMaterial.refraction = parseFloat(value);
          break;
        case "illum":
          currentMaterial.illumination = parseFloat(value);
          break;
        default:
          break;
      }
    }
    return materials;
  }
  function parseColor(value, options) {
    const rgb = value.split(DELIMITER_PATTERN, 3);
    const color = [
      parseFloat(rgb[0]),
      parseFloat(rgb[1]),
      parseFloat(rgb[2])
    ];
    return color;
  }
  var DELIMITER_PATTERN;
  var init_parse_mtl = __esm({
    "src/lib/parse-mtl.ts"() {
      DELIMITER_PATTERN = /\s+/;
    }
  });

  // src/obj-loader.ts
  function testOBJFile(text) {
    return text[0] === "v";
  }
  var VERSION, OBJLoader;
  var init_obj_loader = __esm({
    "src/obj-loader.ts"() {
      VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      OBJLoader = {
        name: "OBJ",
        id: "obj",
        module: "obj",
        version: VERSION,
        worker: true,
        extensions: ["obj"],
        mimeTypes: ["text/plain"],
        testText: testOBJFile,
        options: {
          obj: {}
        }
      };
    }
  });

  // src/mtl-loader.ts
  var VERSION2, MTLLoader;
  var init_mtl_loader = __esm({
    "src/mtl-loader.ts"() {
      VERSION2 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      MTLLoader = {
        name: "MTL",
        id: "mtl",
        module: "mtl",
        version: VERSION2,
        worker: true,
        extensions: ["mtl"],
        mimeTypes: ["text/plain"],
        testText: (text) => text.includes("newmtl"),
        options: {
          mtl: {}
        }
      };
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    MTLLoader: () => MTLLoader2,
    OBJLoader: () => OBJLoader2,
    OBJWorkerLoader: () => OBJLoader,
    _typecheckMTLLoader: () => _typecheckMTLLoader,
    _typecheckOBJLoader: () => _typecheckOBJLoader
  });
  var OBJLoader2, MTLLoader2, _typecheckOBJLoader, _typecheckMTLLoader;
  var init_src2 = __esm({
    "src/index.ts"() {
      init_parse_obj();
      init_parse_mtl();
      init_obj_loader();
      init_mtl_loader();
      OBJLoader2 = {
        ...OBJLoader,
        parse: async (arrayBuffer, options) => parseOBJ(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseOBJ(text, options)
      };
      MTLLoader2 = {
        ...MTLLoader,
        parse: async (arrayBuffer, options) => parseMTL(new TextDecoder().decode(arrayBuffer), options?.mtl),
        parseTextSync: (text, options) => parseMTL(text, options?.mtl)
      };
      _typecheckOBJLoader = OBJLoader2;
      _typecheckMTLLoader = MTLLoader2;
    }
  });

  // src/bundle.ts
  var require_bundle = __commonJS({
    "src/bundle.ts"(exports, module) {
      var moduleExports = (init_src2(), src_exports);
      globalThis.loaders = globalThis.loaders || {};
      module.exports = Object.assign(globalThis.loaders, moduleExports);
    }
  });
  require_bundle();
})();
